/*
--------------------------------------------------------------------------------
================================================================================
                          +:                                                   
WWW@*WWWWWWW+  *WWWWWWW*  :=@       @WWWWWWWWW*WWW*  =WWW*WWWWWWWWWW@*WWW+  @WW
WWW@*WWWWWWWWW**WWWWWWWWW=   =*     @WWWWWWWWW*WWW*  =WWW*WWWWWWWWWW@*WWW+  @WW
WWW@*WWW+  WWWW*WWW*  @WWW :WWWWWW+ @WWW*    *+WWW*  =WWW*WWW#=#WWWW#*WWWWW@@WW
WWW@*WWW+  @WWW*WWW*  #WWW @WWWWWWW @WWW#WWWW@+WWW*  =WWW*WWW#WWWWW* *WWWWW@@WW
WWW@*WWW@  @WWW*WWW*  #WWW += =# += @WWW      +WWWW: =WWW*WWW=  @WWW@      *WWW
WWW@ *WWWWWWWWW*WWW*  #WWW   =WW@   @WWW       :WWWWWWWWW*WWW=   WWW@:WWWWWWWW@
@@@@   +@@@@@@@+@@@+  #WWW          @WWW         :WWWWWWW+W@@=   @@@@:@@@@@@#  

###############################################################################
Ion Fury
Code by Jonathan Strander, Fox Martins, Richard Gobeille, and Evan Ramos
All code as written belongs to Voidpoint and the respective authors.
(c) 2019 Voidpoint, LLC
--------------------------------------------------------------------------------
While we encourage you to experiment, modifications are allowed WITHOUT any
warranty or guarantee of support. Editing these files is AT YOUR OWN RISK, and
we encourage you to make backups.
--------------------------------------------------------------------------------

NOTES:
This file contains most of the individual code for enemy actors in the game,
with a few values being set elsewhere.
================================================================================
--------------------------------------------------------------------------------
*/
// Enemy Actors and related code should be included here
var harder_skill4_turret 1 0
var strafe_dir 0 2
var shot_delay 0 2
var reverse_dir 0 2
var respawntemp
var enemy_spawn_health 0 2
var mech_type 0 2
var gunner_type 0 2

var boss_top_id -1 2
var boss_btm_id -1 2
var boss_top_ang 0 2
var boss_turned 0 2
var boss_dir 0 2
var boss_tryfind 0 2
var boss_bestnum 0 2
var boss_numpts 0 2
var boss_mad 0 2
var boss_recog 0 2
var boss_bestpt -1 2
var boss_health MECHBOSS_HEALTH 2
var boss_selfdmg 0 2
var boss_currhp
var boss_hpflash
var boss_type
var boss_statechange -1 2
var boss_grenades 0 2
var boss_canthit 0 2
var boss_lastang 0 2


action AC_ENEMY_BODY   0 1 1 1 1


move AM_ENEMY_SEARCH 60 0
move AM_ENEMY_SEARCH_STOP 0 0
defstate clear_enemy_vels
    geta .xvel se_xvel
    geta .yvel se_yvel
    geta .zvel se_zvel
    ifge se_zvel GRAVITATIONALCONSTANT
        sub se_zvel GRAVITATIONALCONSTANT
    seta .xvel 0
    seta .yvel 0
    seta .zvel 0
    ifoutside
        seta .shade sector.ceilingshade
    else
        seta .shade sector.floorshade
ends

gamevar e_mit_temp
gamevar e_mit_freq 0 2
defstate spawn_sound_emitter
    espawn A_SOUND_EMITTER
    seta[RETURN].extra SE_DIST_ENEMY_DEFAULT // read distance
    seta[RETURN].xrepeat 64
    seta[RETURN].yrepeat 64
    seta[RETURN].cstat 32768
    geta .z e_mit_temp
    sub e_mit_temp 10240
    seta[RETURN].z e_mit_temp
ends

gamevar bowled_temp
defstate enemy_confirm_bowled
    geta .owner bowled_temp
    ifn bowled_temp -1 ifn bowled_temp THISACTOR ifn bowled_temp player.i
    {
        ife sprite[bowled_temp].picnum P_BOWLINGBOMB
        {
            geta[bowled_temp].htowner bowled_temp
            ifn bowled_temp -1 ife bowled_temp player.i
                add bowled_strike 1
        }
    }
ends

defstate enemy_spawn_checkhitag
    ifn se_hitag 0
    {
        ifl se_hitag 0
        {
            changespritestat THISACTOR STAT_ZOMBIEACTOR
            sleeptime 0
            inv se_hitag
        }
        else
        {
            changespritestat THISACTOR STAT_ACTOR
            sleeptime 300
        }
    }
ends

defstate enemy_die_cleartags
    set se_hitag 0
    set se_lotag 0
    set se_xvel 0
    set se_yvel 0
    set se_zvel 0
ends

appendevent EVENT_SPAWN
    ifspawnedby RESPAWN
    {
        switch sprite.picnum
            case A_CULTIST
            case A_CULTIST_STAYPUT
            case A_SHOTGUNNER
            case A_SHOTGUNNER_STAYPUT
            case A_MECHSECT
            case A_MECHSECT_HANG
            case A_GREATER
            case A_GREATER_STAYPUT
            case A_DRONE
                geta .owner respawntemp
                seta .ang sprite[respawntemp].ang // use the respawners angle
                ifg sprite[respawntemp].xvel 0
                    geta[respawntemp].xvel se_hitag
                ifg sprite[respawntemp].zvel 0
                    geta[respawntemp].zvel se_lotag

                ife sprite[sprite.owner].pal 10 // looks red sometimes
                    seta[sprite.owner].pal 9
                ifn sprite[sprite.owner].pal 9
                    setav .enemy_init 1
                else
                    changespritestat THISACTOR STAT_ZOMBIEACTOR
                ifactor A_MECHSECT
                {
                    geta .owner respawntemp
                    ifand sprite[respawntemp].cstat 8
                    {
                        geta .cstat respawntemp
                        ifand respawntemp 8
                            nullop
                        else
                        {
                            or respawntemp 8
                            seta .cstat respawntemp
                        }
                    }
                }
                else ifactor A_MECHSECT_HANG
                {
                    geta .cstat respawntemp
                    or respawntemp 8
                    seta .cstat respawntemp
                }
                else ife sprite.picnum A_CULTIST_STAYPUT
                {
                    seta .picnum A_CULTIST
                    seta .htactorstayput sprite.sectnum
                    seta .extra CULTIST_HEALTH
                }
                else ife sprite.picnum A_SHOTGUNNER_STAYPUT
                {
                    seta .picnum A_SHOTGUNNER
                    seta .htactorstayput sprite.sectnum
                    seta .extra SHOTGUNNER_HEALTH
                }
                else ife sprite.picnum A_GREATER_STAYPUT
                {
                    seta .picnum A_GREATER
                    seta .htactorstayput sprite.sectnum
                    seta .extra GREATER_HEALTH
                }
                ife sprite.picnum A_SHOTGUNNER
                ifspritepal PAL_SHOTGUNNER_ALT
                    seta .extra SHOTGUNNER_ALT_HEALTH

                break
            case A_TURRET_BOTTOM
                geta .owner respawntemp
                seta .ang sprite[respawntemp].ang
                seta .pal sprite[respawntemp].pal
                seta .xrepeat sprite[respawntemp].xrepeat
                seta .yrepeat sprite[respawntemp].yrepeat
                seta .cstat 257
                break
        endswitch
    }
    switch sprite.picnum
        case A_MECHSECT:
        case A_MECHSECT_HANG:
            ifactor A_MECHSECT_HANG
            {
                cstator 8
                seta .picnum A_MECHSECT
            }
            sizeat 18 18
            ifspritepal 9 // legacy
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            spritepal PAL_MECHSECT
            ifand sprite.cstat 8
                cstat 265
            else
                cstat 257
            state clear_enemy_vels
            state enemy_spawn_checkhitag
            gets .floorpal temp
            ifg temp 41
                ifl temp 54
                    seta .pal temp
            break
        case A_MECHSECT_DEAD1:
        case A_MECHSECT_DEAD2:
            spritepal PAL_MECHSECT
            sizeat 18 18
            cstat 256
            break
        case A_CULTIST:
        case A_CULTIST_STAYPUT:
        case A_CULTIST_CROUCH:
            sizeat 22 21
            cstat 257
            ifspritepal 9 // legacy
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            spritepal PAL_CULTIST

            state clear_enemy_vels
            ife sprite.picnum A_CULTIST_STAYPUT
            {
                seta .picnum A_CULTIST
                seta .htactorstayput sprite.sectnum
                seta .extra CULTIST_HEALTH
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            }
            state enemy_spawn_checkhitag
            rand temp 4
            seta[THISACTOR].htg_t 8 temp

            set enemy_spawn_health CULTIST_HEALTH

            break
        case A_SHOTGUNNER:
        case A_SHOTGUNNER_STAYPUT:
        case A_SHOTGUNNER_CROUCH:
            sizeat 25 21
            cstat 257
            ifspritepal 9 // legacy
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            ifspritepal PAL_SHOTGUNNER_ALT
                nullop
            else
                spritepal PAL_SHOTGUNNER

            state clear_enemy_vels
            ife sprite.picnum A_SHOTGUNNER_STAYPUT
            {
                seta .picnum A_SHOTGUNNER
                seta .htactorstayput sprite.sectnum
                seta .extra SHOTGUNNER_HEALTH
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            }
            state enemy_spawn_checkhitag
            rand temp 4
            seta[THISACTOR].htg_t 8 temp
            ifspritepal PAL_SHOTGUNNER_ALT
                seta .extra SHOTGUNNER_ALT_HEALTH

            ifspritepal PAL_SHOTGUNNER_ALT
                set enemy_spawn_health SHOTGUNNER_ALT_HEALTH
            else
                set enemy_spawn_health SHOTGUNNER_HEALTH

            break
        case A_CULTIST_DEAD:
        case A_CULTIST_GIBBED:
            sizeat 22 21
            cstat 256
            spritepal PAL_CULTIST
            break
        case A_SHOTGUNNER_DEAD:
        case A_SHOTGUNNER_GIBBED:
            sizeat 25 21
            cstat 256
            ifspritepal PAL_SHOTGUNNER_ALT
                nullop
            else
            {
                ife gunner_type 1
                    spritepal PAL_SHOTGUNNER_ALT
                else
                    spritepal PAL_SHOTGUNNER
            }
            break
        case A_GREATER:
        case A_GREATER_STAYPUT:
        case A_GREATER_CROUCH:
            sizeat 24 21
            ifspritepal 9 // legacy
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            spritepal PAL_GREATER
            cstat 257
            state clear_enemy_vels
            ife sprite.picnum A_GREATER_STAYPUT
            {
                seta .picnum A_GREATER
                seta .htactorstayput sprite.sectnum
                seta .extra GREATER_HEALTH
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            }
            state enemy_spawn_checkhitag
            break
       case A_GREATER_DEAD1:
       case A_GREATER_DEAD2:
       case A_GREATER_GIBBED:
            sizeat 24 21
            spritepal PAL_GREATER
            cstat 256
            break
       case A_TURRET_BOTTOM:
            ifspritepal PAL_TURRET_ALT
                nullop
            else ifspritepal PAL_TURRET_MOVER
                nullop
            else ifspritepal PAL_TURRET_MOVER_ALT
                nullop
            else ifspritepal PAL_TURRET_FRIENDLY
                nullop
            else ifspritepal 1 // edge case decoration
                nullop
            else
                spritepal PAL_TURRET
            break
       case A_TURRET:
            sizeat 20 20
            ifspritepal PAL_TURRET_ALT
                nullop
            else ifspritepal PAL_TURRET_FRIENDLY
                nullop
            else ifspritepal PAL_TURRET_MOVER
            {
                sleeptime 300
                changespritestat THISACTOR STAT_ACTOR
            }
            else ifspritepal PAL_TURRET_MOVER_ALT
            {
                sleeptime 300
                changespritestat THISACTOR STAT_ACTOR
            }
            else
                spritepal PAL_TURRET
            ifspritepal PAL_TURRET
                ife harder_skill4_turret 1
                    ifge userdef.player_skill 4
                        spritepal PAL_TURRET_ALT
            ifand sprite.cstat 8
                cstat 265
            else
                cstat 257
            state clear_enemy_vels
            break
        case A_DEACON:
        case A_DEACON_DEAD:
            sizeat 25 22
            ifspritepal 9 // legacy
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            spritepal PAL_DEACON
            ifactor A_DEACON_DEAD
                cstat 256
            else
                cstat 257
            state clear_enemy_vels
            state enemy_spawn_checkhitag
            break
    endswitch
endevent

defstate enemy_load_init
    geta .hitag se_hitag
    seta .hitag 0
    geta .lotag se_lotag
    seta .lotag 0
    getu .player_skill temp
    ife VOLUME EP_HORDE
        nullop
    else
    {
        ifand se_lotag 32
            ifl temp 2
                killit
        ifand se_lotag 16
            ifl temp 3
                killit
        ifand se_lotag 64
            ifl temp 4
                killit
    }
    ifn se_hitag 0
    {
        changespritestat THISACTOR 1
        set enemy_init 1
    }
ends

var e_glass_hitscan_return
defstate enemy_hitscan_glass
    set e_glass_hitscan_return 0
    hitscan hitx hity hitz hitsect h_cos h_sin h_zvel hitsect hitwall hitsprite hitx hity hitz CLIPMASK_HITSCAN
    ife hitsprite player.i
        set e_glass_hitscan_return 1
ends

var enemy_init_return
var enemy_init_return_temp
var enemy_init_return_temp2
defstate enemy_check_init // requires cansee_actor before this
    set enemy_init_return 0
    ife enemy_init 0
    {
        set enemy_init_return_temp 0
        
        ifg sprite.htextra 0
            set enemy_init_return_temp 1
        else ife cansee_return 1
            set enemy_init_return_temp 1
        else ifn hitwall -1
        {
            set surface_type wall[hitwall].picnum
            state get_surface_type

            set enemy_init_return_temp2 0
            ifand wall[hitwall].cstat 16
                set enemy_init_return_temp2 1
            ifand wall[hitwall].cstat 32
                set enemy_init_return_temp2 1
            ife enemy_init_return_temp2 1 // if this wall has a maskwall
            {
                // this trick lets us determine if we're in between the ceiling and floor
                // and should be in the masked area
                getw[hitwall].nextsector enemy_init_return_temp2
                ifn enemy_init_return_temp2 -1
                {
                    ifl hitz sector[enemy_init_return_temp2].floorz ifg sprite.z sector[enemy_init_return_temp2].ceilingz
                    {
                        getw[hitwall].nextwall enemy_init_return_temp2
                        getw[enemy_init_return_temp2].overpicnum surface_type // get the masked texture if so
                        state get_surface_type
                    }
                }
            }
            ife surface_type SURFACE_GLASS ifl wall[hitwall].shade 7 ifn wall[hitwall].blend 130
            {
                ifand wall[hitwall].cstat 128
                {
                    ifand wall[hitwall].cstat 16
                    {
                        state enemy_hitscan_glass
                        ife e_glass_hitscan_return 1
                            set enemy_init_return_temp 1
                    }
                    ifand wall[hitwall].cstat 32
                    {
                        state enemy_hitscan_glass
                        ife e_glass_hitscan_return 1
                            set enemy_init_return_temp 1
                    }
                }
            }
        }
        ife enemy_init_return_temp 1
            set enemy_init 1
        else
            set enemy_init_return 1
    }
ends

var crackt
defstate crackhead
    redefinequote 115 gamestate.bin
    readarrayfromfile gamestate 115
    set crackt gamestate[7]
    ifl crackt 100
    {
        add crackt 1
        setarray gamestate[7] crackt
        writearraytofile gamestate 115
        or cheevo_tracker 4096
    }
ends

defstate crackskulls
    redefinequote 115 gamestate.bin
    readarrayfromfile gamestate 115
    set crackt gamestate[9]
    ifl crackt 20
    {
        add crackt 1
        setarray gamestate[9] crackt
        writearraytofile gamestate 115
        or cheevo_tracker 16384
    }
ends

defstate crackthesecretofflight
    redefinequote 115 gamestate.bin
    readarrayfromfile gamestate 115
    set crackt gamestate[10]
    ifl crackt 30
    {
        add crackt 1
        setarray gamestate[10] crackt
        writearraytofile gamestate 115
        or cheevo_tracker 32768
    }
ends

var enemy_medkit_delay
var enemy_medkit 0 2
var enemy_medkit2 0 2

appendevent EVENT_WORLD
    ifg enemy_medkit_delay 0
        sub enemy_medkit_delay 1
    else
        set enemy_medkit_delay 0
endevent

defstate enemy_medkit_spawn
    ifn enemy_medkit_delay 0
        break
        
    set enemy_medkit MAXPLAYERHEALTH
    div enemy_medkit 3
    
    ifg sprite[player.i].extra enemy_medkit
        break
        
    set enemy_medkit 8
    shiftl enemy_medkit userdef.player_skill
    rand enemy_medkit2 255
    
    ifg enemy_medkit enemy_medkit2
        break        
        
    set enemy_medkit 5
    sub enemy_medkit userdef.player_skill
    
    ifge enemy_medkit_count enemy_medkit
        break
        
    rand enemy_medkit enemy_medkit

    ife enemy_gibbed 0
        shiftr enemy_medkit 1

    ifle enemy_medkit 0
        break

    set enemy_medkit_delay ENEMY_KIT_DELAY

    for itervar range enemy_medkit
    {
        espawn I_SYRINGE
        geta[RETURN].z enemy_medkit
        sub enemy_medkit 5120
        seta[RETURN].z enemy_medkit
        rand enemy_medkit 128
        add enemy_medkit 64
        seta[RETURN].xvel enemy_medkit
        rand enemy_medkit -640
        sub enemy_medkit 1024
        seta[RETURN].zvel enemy_medkit
        geta[].htang enemy_medkit
        randvar enemy_medkit2 320
        ifrnd 128
            inv enemy_medkit2
        add enemy_medkit enemy_medkit2
        add enemy_medkit 2048
        and enemy_medkit 2047
        seta[RETURN].ang enemy_medkit
        ssp RETURN CLIPMASK0
        add enemy_medkit_count 1
   } 
ends

eventloadactor A_TURRET_BOTTOM
    geta .hitag se_hitag
    seta .hitag 0
    geta .lotag se_lotag
    seta .lotag 0
    getu .player_skill temp
    ife VOLUME EP_HORDE
        nullop
    else
    {
        ifand se_lotag 32
            ifl temp 2
                seta .xrepeat 0
        ifand se_lotag 16
            ifl temp 3
                seta .xrepeat 0
        ifand se_lotag 64
            ifl temp 4
                seta .xrepeat 0
    }
    ife sprite.xrepeat 0
    {
        changespritestat THISACTOR STAT_ACTOR
        killit
    }   
enda

eventloadactor A_CULTIST
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda
eventloadactor A_CULTIST_STAYPUT
    state enemy_load_init
enda
eventloadactor A_CULTIST_CROUCH
    set enemy_crouched 1
    state enemy_load_init
enda

eventloadactor A_SHOTGUNNER
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda
eventloadactor A_SHOTGUNNER_STAYPUT
    state enemy_load_init
enda
eventloadactor A_SHOTGUNNER_CROUCH
    set enemy_crouched 1
    state enemy_load_init
enda

eventloadactor A_GREATER
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300
enda
eventloadactor A_GREATER_STAYPUT
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300
enda
eventloadactor A_GREATER_CROUCH
    set enemy_crouched 1
    state enemy_load_init
enda

eventloadactor A_MECHSECT
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300
enda

eventloadactor A_MECHSECT_HANG
    state enemy_load_init
    cstator 8
    ifn se_hitag 0
        sleeptime 300
enda


var enemy_xv 0 2
var enemy_yv 0 2
var enemy_tox 0 2
var enemy_toy 0 2
var enemy_toz 0 2
var enemy_tos 0 2
var enemy_strafe 0 2
var enemy_strafe_mod 0 2
var enemy_stop 0 2
var enemy_start 0 2
var enemy_shoot 0 2
var enemy_dodge 0 2
var enemy_lastshot 0 2
var enemy_roamang -1 2
var enemy_lockang 0 2
var enemy_forcejump 0 2
var enemy_faceplayerslow 0 2
var enemy_fps_temp
var enemy_fps_temp2
var enemy_faceplayer 0 2
var enemy_search 0 2 // used to break into hard coded seeking
var enemy_cantsee 0 2
var enemy_target 0 2
var enemy_wake_radius 0 2
var enemy_stepcounter 0 2
var enemy_stepcounter2 0 2
var enemy_annoyance 0 2
var enemy_skipshade 0 2
var enemy_squished 0 2
var enemy_thisisahack 0 2
var enemy_init_hp
var enemy_chatty 0 2
var enemy_kathy 0 2


var e_greater_lastsnd
var e_lesser_lastsnd
var e_lastsnd_temp

defstate enemy_lotag_checkclear
    ifn sprite.xvel 0
        seta .xvel 0
    ifand se_lotag 1
        ifg sprite.htextra 0
            ife enemy_ife 0
                xor se_lotag 1
ends
var eps_return
defstate enemy_check_pause
    set eps_return 0
    ife pause_ai 1
    {
        ifcount 2
            nullop
        else ifcount 0
        {
            resetcount
            changespritestat THISACTOR STAT_ZOMBIEACTOR
        }
        set eps_return 1
    }
ends

var way_temp
var way_temp2
var way_temp3
var way_temp4
var way_temp5
var way_temp6

var way_last 0 2

var way_counter 0 2
var way_ang -1 2
var patrol_num 0 2

// var way_first 0 2

// The state traverses the breadcrumb waypoint paths left for enemies.
// It relies on some follow-up code elsewhere in the states that call
// it to actually face the appropriate waypoint.

appendevent EVENT_SPAWN
    ifand tiledata[sprite.picnum].gameflags 32
        geta .extra enemy_init_hp
endevent

defstate e_wakemeup
    ifg se_hitag 0
    {
        ifg se_lotag 0
        {
            ifn enemy_init 0
            {
                sleeptime 300
                changespritestat THISACTOR STAT_ACTOR
            }
        }
    }
ends

var flame_was_enemy 0 2
var enemy_ohtflags 0 2
defstate smg_flamechance
    ifg enemy_smg_flame 0
    {
        set smgf_temp enemy_smg_flame
        shiftr smgf_temp 2
        clamp smgf_temp 1 65536
        sub enemy_smg_flame smgf_temp
        clamp enemy_smg_flame 0 65536
    }
    ife enemy_smg_flame_id -1
    {
        geta .htflags enemy_ohtflags
        ifg sprite.htextra 0 ife sprite.htpicnum P_SMG2 ife sprite.htowner player.i
        {
            geta .htextra smgf_temp
            add enemy_smg_flame smgf_temp
        }
        set smgf_temp enemy_init_hp
        shiftr smgf_temp 4
        switch sprite.picnum
            case A_GREATER
            case A_NUKEMUTANT
            case A_NUKEMUTANT_GDF
                shiftr smgf_temp 1
                break
        endswitch
        ifg enemy_smg_flame smgf_temp
        {
            ifrnd 8
            {
                ifactor A_GREATER
                {
                    ifg enemy_annoyance ANNOYED
                        shiftr enemy_annoyance 1
                }
                ifactor A_MECHSECT
                {
                    ife ms_faller 1
                    {
                        ife enemy_init 90
                            set enemy_init 10
                    }
                    else
                        set enemy_init 1
                }
                else
                    set enemy_init 1
                espawn A_FIRE2_SMG
                seta[RETURN].cstat 32768
                setav[RETURN].enemy_smg_flame_id THISACTOR
                setav[RETURN].flame_was_enemy 1
                set enemy_smg_flame_id RETURN
                
                set face_target player.i
                state face_actor
                add face_return 1024
                and face_return 2047
                seta[RETURN].ang face_return
                
                set move_v 20
                set move_override enemy_smg_flame_id
                state move_actor
                add move_xv sprite.x
                add move_yv sprite.y
                seta[RETURN].x move_xv
                seta[RETURN].y move_yv
            }
        }
    }
    else
    {
        geta .htflags smgf_temp
        or smgf_temp 64
        ifand tiledata[sprite.picnum].gameflags 64
            xor smgf_temp 64
        spriteflags smgf_temp
        spritepal 73
        ife smgf_counter 0
        {
            set smgf_counter 3
            geta .htextra smgf_temp
            add smgf_temp 1
            switch sprite.picnum
                case A_NUKEMUTANT
                case A_NUKEMUTANT_GDF
                    add smgf_temp 4
                    add smgf_counter 6
                    break
            endswitch
            clamp smgf_temp 1 65536
            seta .htextra smgf_temp
            set enemy_skipshade 1
            seta .shade -50
            ifactor A_GREATER
            {
                ifg enemy_annoyance ANNOYED
                    shiftr enemy_annoyance 1
            }
        }
        else
            sub smgf_counter 1
        ifdead ifactioncount 3
        {
            spritepal 105
            spriteflags enemy_ohtflags
            ife actorvar[enemy_smg_flame_id].smgf_counter 0
                setav[enemy_smg_flame_id].smgf_counter 90
            
        }
    }
ends

action AC_SMG_FLAME -1 1 1 1 1
spritenoshade A_FIRE2_SMG
spritenopal A_FIRE2_SMG
useractor notenemy A_FIRE2_SMG 0 AC_SMG_FLAME
    ifg enemy_smg_flame_id -1
    {
        ife st_do_once 0
        {
            spritepal 0
            set temp tilesizy[sprite[enemy_smg_flame_id].picnum]
            shiftl temp 2
            mul temp sprite[enemy_smg_flame_id].yrepeat
            
            set temp2 tilesizy[sprite.picnum]
            shiftl temp2 2
            mul temp2 sprite[enemy_smg_flame_id].yrepeat
            shiftr temp 4
            shiftr temp2 4
            mul temp temp2
            shiftr temp 14
            ife flame_was_enemy 1
                nullop
            else
                shiftr temp 1
            clamp temp 1 255
            seta .yrepeat temp
            set temp sprite.yrepeat
            
            
            set temp tilesizy[sprite[enemy_smg_flame_id].picnum]
            mul temp sprite[enemy_smg_flame_id].yrepeat
            shiftr temp 2
            
            set temp2 tilesizy[sprite.picnum]
            mul temp2 sprite[enemy_smg_flame_id].yrepeat
            shiftr temp2 2
            
            mul temp temp2
            shiftr temp 14
            ife flame_was_enemy 1
                nullop
            else
                shiftr temp 1
            clamp temp 1 255
            seta .xrepeat temp
            set temp sprite.xrepeat
            
            cstat 2
            ife flame_was_enemy 1
                nullop
            else ifrnd 127
                cstator 4
            seta .shade 40
            seta .blend 129
            set st_do_once 1
        }
        else
        {
            ifl st_do_once 10 ife smgf_counter 0
            {
                geta .shade temp
                sub temp 10
                clamp temp -50 50
                seta .shade temp
                add st_do_once 1
            }
        }
        seta .x sprite[enemy_smg_flame_id].x
        seta .y sprite[enemy_smg_flame_id].y
        seta .z sprite[enemy_smg_flame_id].z
        ife flame_was_enemy 1
            nullop
        else
        {
            set temp sprite.z
            add temp 1024
            seta .z temp
        }
        seta .sectnum sprite[enemy_smg_flame_id].sectnum
        set face_target player.i
        state face_actor
        add face_return 1024
        and face_return 2047
        seta .ang face_return
        
        set move_v 10
        ife flame_was_enemy 1
            nullop
        else
            add move_v 5
        state move_actor
        add move_xv sprite.x
        add move_yv sprite.y
        seta .x move_xv
        seta .y move_yv
        
        ifg smgf_counter 0
        {
            ife counter 1
                set counter 0
            else ifand smgf_counter 1 ifl smgf_counter 60
            {
                geta .xrepeat temp
                sub temp 1
                clamp temp 0 255
                seta .xrepeat temp
                geta .yrepeat temp
                sub temp 1
                clamp temp 0 255
                seta .yrepeat temp
                
                geta .shade temp
                set temp2 temp
                abs temp2
                shiftr temp2 2
                clamp temp2 4 255
                add temp temp2
                clamp temp -127 127
                seta .shade temp
                set counter 1
                ifg temp 40
                    killit
            }
            sub smgf_counter 1
            clamp smgf_counter 1 65536
        }
    }
enda

var e_cw1a_temp
var e_cw1a_temp2
var e_cw1a_temp3
var e_cw1a_temp4
var e_cw1a_count 0 2

defstate enemy_checkw1alt
    set e_cw1a_temp4 aft_return
    ife player.curr_weapon 1 ifg press_alt 0
    {
        set aft_target player.i        
        state angle_from_target
        set e_cw1a_temp 0
        ifle aft_return W1ALT_ANG
            ifg sprite.extra 0
            {
                set weapon1_validtarget 1
                set e_cw1a_temp 1
            }
        ife e_cw1a_temp 0
        {
            set weapon1_validtarget 0
            set need_target_icon 0
            set e_cw1a_temp3 1
            whilen e_cw1a_temp3 7
            {
                set e_cw1a_temp2 num_targets[e_cw1a_temp3]
                ife e_cw1a_temp2 THISACTOR
                    setarray num_targets[e_cw1a_temp3] -1
                add e_cw1a_temp3 1
            }
            set e_cw1a_temp3 1
            whilen e_cw1a_temp3 7
            {
                set e_cw1a_temp2 num_targets[e_cw1a_temp3]
                ife e_cw1a_temp2 -1
                {
                    set e_cw1a_temp e_cw1a_temp3
                    add e_cw1a_temp 1
                    ife e_cw1a_temp 7
                        set e_cw1a_temp 0
                    setarray num_targets[e_cw1a_temp3] num_targets[e_cw1a_temp]
                }
                add e_cw1a_temp3 1
            }
        }
    }
    set aft_return e_cw1a_temp4
ends

defstate enemy_clearw1alt
    set weapon1_validtarget 0
    set need_target_icon 0
    ife weapon1_alt 0
    {
        set e_cw1a_temp3 1
        whilen e_cw1a_temp3 7
        {
            set e_cw1a_temp2 num_targets[e_cw1a_temp3]
            ife e_cw1a_temp2 THISACTOR
                setarray num_targets[e_cw1a_temp3] -1
            add e_cw1a_temp3 1
        }
        set e_cw1a_temp3 1
        whilen e_cw1a_temp3 7
        {
            set e_cw1a_temp2 num_targets[e_cw1a_temp3]
            ife e_cw1a_temp2 -1
            {
                set e_cw1a_temp4 e_cw1a_temp3
                add e_cw1a_temp4 1
                ife e_cw1a_temp4 7
                    set e_cw1a_temp4 0
                setarray num_targets[e_cw1a_temp3] num_targets[e_cw1a_temp4]
            }
            add e_cw1a_temp3 1
        }
    }
ends

var vtc 0 2
defstate enemy_do_target_icon
    ife weapon1_alt 0
        set need_target_icon 0
    else ife need_target_icon 1
    {
        ife target_icon_id -1
        {
            espawn A_TARGET_ICON
            setav[RETURN].target_icon_id THISACTOR
            set target_icon_id RETURN
        }
    }
    ife need_target_icon 0
        set target_icon_id -1
    ife weapon1_validtarget 1
    {
        ifl vtc 15
            add vtc 1
    }
    else
        set vtc 0
    ife vtc 15
    {
        set e_cw1a_temp 0
        ife last_cansee_return 0
            add e_cw1a_count 1
        else
            set e_cw1a_count 0

        ifg e_cw1a_count 15
            set e_cw1a_temp 1
        else ife need_target_icon 0
            set e_cw1a_temp 1
        ife e_cw1a_temp 1
        {
            set vtc 0
            set e_cw1a_count 0
            set weapon1_validtarget 0
            set need_target_icon 0
            set e_cw1a_temp3 1
            whilen e_cw1a_temp3 7
            {
                set e_cw1a_temp2 num_targets[e_cw1a_temp3]
                ife e_cw1a_temp2 THISACTOR
                    setarray num_targets[e_cw1a_temp3] -1
                add e_cw1a_temp3 1
            }
            set e_cw1a_temp3 1
            whilen e_cw1a_temp3 7
            {
                set e_cw1a_temp2 num_targets[e_cw1a_temp3]
                ife e_cw1a_temp2 -1
                {
                    set e_cw1a_temp e_cw1a_temp3
                    add e_cw1a_temp 1
                    ife e_cw1a_temp 7
                        set e_cw1a_temp 0
                    setarray num_targets[e_cw1a_temp3] num_targets[e_cw1a_temp]
                }
                add e_cw1a_temp3 1
            }
        }
    }
    else
        set e_cw1a_count 0
ends

defstate do_add_patrol
    ifg actorvar[way_temp].se_extra 2
    {
        ifand actorvar[way_temp].se_extra 16
            set enemy_forcejump 1

        ifand actorvar[way_temp].se_extra 4
        {
            seta .ang sprite[way_temp].ang
            geta .ang enemy_endoftheline
            set enemy_xv 0
            set enemy_yv 0
            set enemy_stop 7
        }
        else ifand actorvar[way_temp].se_extra 8
        {
            set enemy_endoftheline -1
            set enemy_stop 0
            set enemy_start 7
            add patrol_num 1
        }
        else
            add patrol_num 1
    }
    else
        add patrol_num 1
ends

defstate find_waypoints
    // This opening code block is a poor optimization hack.
    // Poor because it's a bit stupid, but necessary because it
    // speeds up fps by 450% in heavy scenarios.
    ife cansee_return_o 1
        set enemy_idle_count 0
    else
        add enemy_idle_count 1
    sleeptime 300
    ifn way_current -1
    {
        ife sprite[way_current].statnum MAXSTATUS
            set way_current -1
    }
    ifn se_hitag 0
    {
        set way_temp3 0
        for way_temp sprofstat STAT_LOCATOR
        {
            getav[way_temp].se_hitag way_temp2
            ife way_temp2 se_hitag
            {
                getav[way_temp].se_lotag way_temp2
                ife way_temp2 patrol_num
                {
                    set way_current way_temp
                    ldist way_temp2 way_temp THISACTOR
                    ifn sprite[way_temp].pal 9
                        changespritestat THISACTOR STAT_ACTOR
                    switch sprite.picnum
                        case A_DRONE:
                        case A_DEACON:
                            ifand se_lotag 512
                            {
                                ifl way_temp2 256
                                {
                                    ifle way_ang -1
                                        geta .ang way_ang
                                    else
                                        seta .ang way_ang
                                }
                                else
                                    set way_ang -1
                                geta .z way_temp4
                                sub way_temp4 sprite[way_temp].z
                                abs way_temp4
                                ifl way_temp2 way_temp4
                                {
                                    ifg way_temp4 1536
                                        set way_temp2 256
                                    shiftr way_temp4 3
                                    clamp way_temp4 128 131072
                                    ifl sprite.z sprite[way_temp].z
                                        movesprite THISACTOR 0 0 way_temp4 CLIPMASK0 way_temp4
                                    else
                                        movesprite THISACTOR 0 0 -way_temp4 CLIPMASK0 way_temp4
                                }
                            }
                            break
                    endswitch
                    ifl way_temp2 256
                    {
                        set way_ang -1
                        switch sprite[way_temp].pal
                        {
                            case 9:
                            {
                                seta .ang sprite[way_temp].ang
                                geta .ang enemy_endoftheline
                                ifand se_lotag 1
                                    xor se_lotag 1
                                set enemy_xv 0
                                set enemy_yv 0
                                set enemy_stop 7
                                changespritestat THISACTOR STAT_ZOMBIEACTOR
                                break
                            }
                            case 8:
                            {
                                seta .ang sprite[way_temp].ang
                                geta .ang enemy_endoftheline
                                ifand se_lotag 1
                                    xor se_lotag 1
                                set se_hitag 0
                                set enemy_xv 0
                                set enemy_yv 0
                                set enemy_stop 7
                                ife enemy_init 0
                                    set enemy_init 1
                                changespritestat THISACTOR STAT_ACTOR
                                break
                            }
                            case 11:
                            {
                                set enemy_ife 1
                                state do_add_patrol
                                or se_lotag 1
                                break
                            }
                            case 1:
                            {
                                set enemy_ife 0
                                state do_add_patrol
                                break
                            }
                            case 5:
                            {
                                ifand se_lotag 1
                                    xor se_lotag 1
                                set enemy_ife 0
                                state do_add_patrol
                                break
                            }
                            default:
                                state do_add_patrol
                                break
                        }
                        endswitch
                    }
                    else ife patrol_num 0
                    {
                        ife sprite[way_temp].pal 11
                        {
                            set enemy_ife 1
                            or se_lotag 1
                        }
                    }
                    set way_temp3 1
                }
            }
        }
        ife way_temp3 0
            set patrol_num 0
        set enemy_search 0
        stopactorsound THISACTOR S_CULTIST_ROAM1
        stopactorsound THISACTOR S_CULTIST_ROAM2
        stopactorsound THISACTOR S_CULTIST_ROAM3
        break
    }
    else
        set enemy_endoftheline -1
    set way_ang -1
    add way_counter 1
    ifl enemy_idle_count 900
    {
        ifg way_counter 30
            set way_counter 0
    }
    else ifl enemy_idle_count 1800
    {
        ifg way_counter 60
            set way_counter 0
    }
    else ifl enemy_idle_count 2700
    {
        ifg way_counter 90
            set way_counter 0
        stopactorsound THISACTOR S_CULTIST_ROAM1
        stopactorsound THISACTOR S_CULTIST_ROAM2
        stopactorsound THISACTOR S_CULTIST_ROAM3
        stopactorsound THISACTOR S_CULTIST_CHAT1
        stopactorsound THISACTOR S_CULTIST_CHAT2
        stopactorsound THISACTOR S_CULTIST_CHAT3
        stopactorsound THISACTOR S_GREATER_ASCEND
        stopactorsound THISACTOR S_GREATER_FLESHBAG
        stopactorsound THISACTOR S_GREATER_KILL
        stopactorsound THISACTOR S_GREATER_MINE
        stopactorsound THISACTOR S_GREATER_UNCLEAN
    }
    else ifl enemy_idle_count 3600
    {
        ifg way_counter 120
            set way_counter 0
        stopactorsound THISACTOR S_CULTIST_ROAM1
        stopactorsound THISACTOR S_CULTIST_ROAM2
        stopactorsound THISACTOR S_CULTIST_ROAM3
        stopactorsound THISACTOR S_CULTIST_CHAT1
        stopactorsound THISACTOR S_CULTIST_CHAT2
        stopactorsound THISACTOR S_CULTIST_CHAT3
        stopactorsound THISACTOR S_GREATER_ASCEND
        stopactorsound THISACTOR S_GREATER_FLESHBAG
        stopactorsound THISACTOR S_GREATER_KILL
        stopactorsound THISACTOR S_GREATER_MINE
        stopactorsound THISACTOR S_GREATER_UNCLEAN
    }
    else
        changespritestat THISACTOR STAT_ZOMBIEACTOR
    ifn way_counter 0 ife way_current -1
        break

    ife way_current -1 // if there's no waypoint
    {
        geta .z way_temp
        sub way_temp 2048
        seta .z way_temp
        set way_temp5 cansee_return
        set way_temp6 cansee_return_o
        ifn way_nearest -1 // way_nearest is set by the PLAYER when they are close to a waypoint
        {
            set cansee_target way_nearest
            set cansee_height 0
            state cansee_actor
            set way_temp3 cansee_return_o
           //  canseespr THISACTOR way_nearest way_temp3
            ife way_temp3 0 ifn way_last -1
            {
                // canseespr THISACTOR way_last way_temp3
                set cansee_target way_last
                set cansee_height 0
                state cansee_actor
                set way_temp3 cansee_return_o
                ife way_temp3 1
                    set way_temp3 2
            }
        }
        else
            set way_temp3 0
        set cansee_return way_temp5
        set cansee_return_o way_temp6
        add way_temp 2048
        seta .z way_temp
        ife way_temp3 1 // if we can see the player's nearest waypoint then just use that
        {
            set way_current way_nearest
        }
        else ife way_temp3 2 // if we can see the player's last known waypoint use that
        {
            set way_current way_last
        }
        else
        {
            set way_temp3 131072
            set way_temp5 cansee_return
            set way_temp6 cansee_return_o
            for way_temp sprofstat STAT_WAYPOINT  // if we need to find the nearest waypoint instead
            {
                ldist way_temp2 way_temp THISACTOR // we need to do a distance sort...
                set cansee_target way_temp
                set cansee_height 8192
                state cansee_actor
                set way_temp4 cansee_return_o

                ifl way_temp2 way_temp3 ife way_temp4 1 // and if it's visible and close we'll use it
                {
                    set way_current way_temp
                    set way_temp3 way_temp2 // save the distance to compare next loop
                }
            }
            set cansee_return way_temp5
            set cansee_return_o way_temp6
            ife way_current -1
            {
                set enemy_search 120
                break
            }
        }
    }
    else // if we have a current waypoint
    {
        ldist way_temp2 way_current THISACTOR
        ifl way_temp2 192   // if we're close the waypoint then find the next one up
        {
            headspritestat way_temp STAT_WAYPOINT
            ife way_temp -1
            {
                set way_current -1
                break
            }
            set way_temp3 0
            set way_temp4 cansee_return
            set way_temp5 cansee_return_o
            for way_temp sprofstat STAT_WAYPOINT
            {
                ife way_temp3 0
                {
                    geta[way_current].extra way_temp2
                    add way_temp2 1
                    ife way_temp2 sprite[way_temp].extra
                    {
                        geta .z way_temp3
                        sub way_temp3 8192
                        seta .z way_temp3

                        set cansee_height 0
                        set cansee_target way_temp
                        state cansee_actor
                        set way_temp3 cansee_return_o

                        ife way_temp3 0  // if we can't see the next waypoint then don't use it
                        {
                            geta .z way_temp3
                            add way_temp3 8192
                            seta .z way_temp3
                            set way_temp3 -1
                        }
                        else
                        {
                            set way_current way_temp
                            geta .z way_temp3
                            add way_temp3 8192
                            seta .z way_temp3
                            set way_temp3 1
                        }

                    }
                }
            }
            set cansee_return way_temp4
            set cansee_return_o way_temp5
            ifle way_temp3 0 // if we didn't get a good waypoint then say screw it and set to null
            {
                set way_current -1
                break
            }
        }
    }
ends

var angcount 0 2

defstate e_fps // face the player, but with a small bit of lag/time lapse
    ife ignore_me 1
        break
    else ifl ignore_me 0
    {
        seta .ang -ignore_me
        add angcount 1
        ifg angcount 60
            set ignore_me 0
        break
    }


    ife sector.lotag 1
    {
        geta .z enemy_fps_temp2
        sub enemy_fps_temp2 2048
        seta .z enemy_fps_temp2
    }
    set enemy_fps_temp 0
    ifge cansee_return_o 1
        set enemy_fps_temp 1
    else ifge cansee_return 1
        set enemy_fps_temp 1
    ifge enemy_fps_temp 1
        ifn se_hitag 0
            set enemy_fps_temp 0
    ifge enemy_fps_temp 1 // if we can see the player don't use waypoints and don't do any seekplayer
    {
        set way_current -1
        set enemy_search 0
        ifn cansee_return 2 ifg cansee_return 0
            set way_last way_nearest
        set way_counter 0
    }
    else ifn enemy_shoot 0
        set way_current -1
    else
        state find_waypoints
    ife sector.lotag 1
    {
        geta .z enemy_fps_temp2
        add enemy_fps_temp2 2048
        seta .z enemy_fps_temp2
    }
    cstator 256
    ife way_current -1
    {
        getp .i att_target
        set enemy_endoftheline -1
    }
    else // if we're using a waypoint face that directly instead of any other mumbo jumbo
    {
        ifg enemy_endoftheline -1
            seta .ang enemy_endoftheline
        else
        {
            ifn way_ang -1
                seta .ang way_ang
            else
            {
                set att_target way_current
                set face_target way_current
                state face_actor
                seta .ang face_return
            }
            ife enemy_shoot 0
                set enemy_start 7
            set enemy_strafe 0
        }
        break
    }
    set att_noclamp 1
    state angle_to_target
    ife cansee_return_o 1 ifn att_return 0
    {
        set enemy_fps_temp att_return
        shiftr enemy_fps_temp 2
        ifg enemy_fps_temp 4
            set att_return enemy_fps_temp
        else ifl enemy_fps_temp -4
            set att_return enemy_fps_temp
    }
    geta .ang enemy_fps_temp
    sub enemy_fps_temp att_return
    and enemy_fps_temp 2047

    ifn enemy_shoot 0 // if we get hung up then do silly hardcoded "seekplayer" stuff
    {
        move AM_ENEMY_SEARCH_STOP
        set enemy_search 0
    }
    ife enemy_search 0
        seta .ang enemy_fps_temp

    ife reverse_dir 1
         ifle se_hitag 0
         {
            ifrnd 127
                setvar enemy_search 60
            else ifrnd 127
            {
                rand enemy_fps_temp2 64
                ifrnd 127
                    inv enemy_fps_temp2
                add enemy_fps_temp2 sprite.ang
                and enemy_fps_temp2 2047
                seta .ang enemy_fps_temp2
            }
        }
    ifg enemy_search 0
    {
            set way_current -1
            ife enemy_shoot 0
                set enemy_start 7
            set enemy_strafe 0
            ifrnd 127 ife enemy_shoot 0
                move AM_ENEMY_SEARCH 512
            sub enemy_search 1
    }
    else ifmove AM_ENEMY_SEARCH
        move AM_ENEMY_SEARCH_STOP
ends

defstate e_fp // same as above but for facing the player directly
    ife ignore_me 1
        break
    else ifl ignore_me 0
    {
        seta .ang -ignore_me
        add angcount 1
        ifg angcount 60
            set ignore_me 0
        break
    }

    ife sector.lotag 1
    {
        geta .z enemy_fps_temp2
        sub enemy_fps_temp2 2048
        seta .z enemy_fps_temp2
    }
    set enemy_fps_temp 0
    ifge cansee_return_o 1
        set enemy_fps_temp 1
    else ifge cansee_return 1
        set enemy_fps_temp 1
    ifge enemy_fps_temp 1
        ifn se_hitag 0
            set enemy_fps_temp 0
    ifge enemy_fps_temp 1
    {
        set way_current -1
        set enemy_search 0
        ifn cansee_return 2 ifg cansee_return 0
            set way_last way_nearest
        set way_counter 0
    }
    else ifn enemy_shoot 0
        set way_current -1
    else
        state find_waypoints
    ife sector.lotag 1
    {
        geta .z enemy_fps_temp2
        add enemy_fps_temp2 2048
        seta .z enemy_fps_temp2
    }
    cstator 256
    ife way_current -1
    {
        getp .i face_target
        set enemy_endoftheline -1
    }
    else // if we're using a waypoint face that directly instead of any other mumbo jumbo
    {
        ifg enemy_endoftheline -1
            seta .ang enemy_endoftheline
        else
        {
            ifn way_ang -1
                seta .ang way_ang
            else
            {
                set face_target way_current
                state face_actor
                seta .ang face_return
            }
            ife enemy_shoot 0
                set enemy_start 7
            set enemy_strafe 0
        }
        break
    }
    ifg enemy_endoftheline -1
            seta .ang enemy_endoftheline
    else
        state face_actor

    ifn enemy_shoot 0
    {
        move AM_ENEMY_SEARCH_STOP
        set enemy_search 0
    }
    ife enemy_search 0
        seta .ang face_return
    ife reverse_dir 1
         ifle se_hitag 0
         {
            ifrnd 127
                setvar enemy_search 60
            else ifrnd 127
            {
                rand enemy_fps_temp2 64
                ifrnd 127
                    inv enemy_fps_temp2
                add enemy_fps_temp2 sprite.ang
                and enemy_fps_temp2 2047
                seta .ang enemy_fps_temp2
            }
        }
    ifg enemy_search 0
    {
        set way_current -1
        ife enemy_shoot 0
            set enemy_start 7
        set enemy_strafe 0
        ife enemy_shoot 0 ifrnd 127
            move AM_ENEMY_SEARCH 512
        sub enemy_search 1
    }
    else ifmove AM_ENEMY_SEARCH
        move AM_ENEMY_SEARCH_STOP
ends

defstate dying_blood
    ife db_odd 0
    {
        geta .ang temp2
        rand temp3 2047
        seta .ang temp3
        rand temp3 512
        add temp3 1024
        shiftl temp3 1
        ifrnd 127
            inv temp3
        ezshoot temp3 P_BLOOD
        seta[RETURN].shade sprite.htg_t 8

        setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT
        seta[RETURN].xvel 32
        geta[RETURN].z temp3
        add temp3 2048
        seta[RETURN].z temp3
        seta[RETURN].xrepeat 4
        seta[RETURN].yrepeat 4
        seta .ang temp2
        ifrnd 64
            set db_odd 1
        else ifl framerate 15
            set db_odd 1
        else ifn fryall 0
            set db_odd 15
        else ifn killshit 0
            set db_odd 15
    }
    else
    {
        ifg db_odd 1
            sub db_odd 1
        else
            set db_odd 0
    }
    ife db_once 0
    {
        geta .sectnum db_temp
        set db_temp tainted[db_temp]
        ife db_temp 0
        {
            espawn A_GENERIC_BLOODSPLATTER
            getflorzofslope sprite.sectnum sprite.x sprite.y db_temp
            seta[RETURN].z db_temp
            set db_temp sector[sprite.sectnum].floorshade
            add db_temp 7
            seta[RETURN].shade db_temp
            seta[RETURN].xrepeat 18
            seta[RETURN].yrepeat 18
            seta[RETURN].cstat 160
            rand db_temp 2047
            seta[RETURN].ang db_temp
        }
        set db_once 1
    }
ends


var e_res_temp 0 2
var e_res_temp2 0 2
var e_res_temp3 0 2
var e_res_temp4 0 2
var e_res_recursive 0 2
var e_res_recursive_skip 0 2
var e_res_activated 0 2
var e_res_y
var e_res_z
defstate enemy_die_friction
    geta .htextra e_res_temp
    ifg e_res_temp -1
    {
        clamp e_res_temp 0 63
        shiftr e_res_temp 2
        sub e_res_temp 1
        seta .htextra e_res_temp
    }
ends
defstate enemy_die_resolve_e_res_temp2
{
    getav[e_res_temp].se_xvel e_res_temp2
    ife sprite[e_res_temp].picnum A_BRUTE_TOP
        nullop
    else ife sprite[e_res_temp].picnum A_MECHBOSS_TOP
                nullop
    else ife sprite[e_res_temp].picnum A_DIOPEDE_BUTT
                nullop
    else ife e_res_temp2 se_xvel
    {
        getav[e_res_temp].se_yvel e_res_temp2
        ifn e_res_temp2 0
            set e_res_y e_res_temp2
        getav[e_res_temp].se_zvel e_res_temp2
        ifn e_res_temp2 0
            set e_res_z e_res_temp2

        ifg sprite[e_res_temp].extra 0
            add e_res_temp3 1

        getav[e_res_temp].e_res_activated e_res_temp2
        ifn e_res_temp2 0
            add e_res_temp3 1
    }
}
ends

defstate enemy_die_resolve
    
    switch sprite.picnum
        case A_CULTIST
        case A_SHOTGUNNER
        case A_GREATER
        case A_NUKEMUTANT
        case A_NUKEMUTANT_GDF
        case A_ARCHANGEL
            state enemy_medkit_spawn
            break
    endswitch
    addkills 1
    set e_res_y 0
    set e_res_z 0
    ifle se_xvel 0
        break
    set e_res_temp3 0
    set e_res_recursive 0
    whilen e_res_recursive 2
    {
        add e_res_recursive 1
        for e_res_temp4 range num_flag32
        {
            set e_res_temp gameflag32[e_res_temp4]
            set e_res_temp2 0
            state enemy_die_resolve_e_res_temp2
            getav[e_res_temp].se_xvel e_res_temp2
            
            ife sprite[e_res_temp].picnum A_BRUTE_TOP
                nullop
            else ife sprite[e_res_temp].picnum A_MECHBOSS_TOP
                nullop
            else ife sprite[e_res_temp].picnum A_DIOPEDE_BUTT
                nullop
            else ife e_res_temp2 se_xvel
            {
                ifn e_res_y 0
                    setav[e_res_temp].se_yvel e_res_y
                ifn e_res_z 0
                    setav[e_res_temp].se_zvel e_res_z
                ife e_res_recursive_skip 0
                    nullop
                else
                    set e_res_recursive 2
                ife e_res_recursive 2
                    setav[e_res_temp].e_res_recursive_skip 1
                ifg sprite[e_res_temp].extra 0
                    add e_res_temp3 1

                getav[e_res_temp].e_res_activated e_res_temp2
                ifn e_res_temp2 0
                    add e_res_temp3 1
            }
        }
    }
    ife e_res_temp3 0
    {
        ifg se_yvel 0
        {
            operateactivators se_yvel THISACTOR
            operatemasterswitches se_yvel
            operaterespawns se_yvel
            setarray preloadactivations[se_yvel] 1
        }
        ifg se_zvel 0
        {
            espawn I_ACCESSCARD
            switch se_zvel
                case 2
                    seta[RETURN].pal PAL_KEYCARD_2
                    break
                case 3
                    seta[RETURN].pal PAL_KEYCARD_3
                    break
            endswitch
            set face_target player.i
            state face_actor
            seta[RETURN].ang face_return
            ifactor A_MECHBOSS_BOTTOM
            {
                seta[RETURN].zvel -3072
                seta[RETURN].xvel 256
            }
            else
            {
                seta[RETURN].zvel -2048
                seta[RETURN].xvel 48
            }
            ssp RETURN CLIPMASK0
        }
        set e_res_activated 1
        for e_res_temp4 range num_flag32
        {
            set e_res_temp gameflag32[e_res_temp4]
            ifand tiledata[sprite[e_res_temp].picnum].gameflags 32
            {
                getav[e_res_temp].se_xvel e_res_temp2
                ife e_res_temp2 se_xvel
                    setav[e_res_temp].e_res_activated 1
            }
        }
    }
ends

var e_movetemp 0 0
var e_movetemp2 0 0
var e_movetemp3 0 0
var e_movetemp4 0 0
var e_movetemp5 0 0
var e_movetemp6 0 0
var e_move_return 0 0
var e_move_htfloorz 0 2
var e_move_zvel 0 2
var e_dead_count 0 2
var e_move_gtfo 0 0
var e_move_gtfo_sect 0 0
var e_move_gtfo_temp 0 0
var e_move_ztemp 0 2
var e_move_count 0 2

var e_us_x 0 2
var e_us_y 0 2
var e_us_z 0 2
var e_us_zvel 0 2
var e_us_htfloorz 0 2
var e_us_sectnum 0 2

defstate e_uds_cleanup
    ife sprite[e_res_temp].picnum A_BRUTE_TOP
            nullop
    else ife sprite[e_res_temp].picnum A_MECHBOSS_TOP
        nullop
    else ife sprite[e_res_temp].picnum A_MECHBOSS_BOTTOM
    {
        ifn mech_type 0
            state enemy_die_resolve
        else
        {
            addkills 1
            ifg se_yvel 0
            {
                ife st_do_once 0
                {
                    set st_do_once 1
                    operateactivators se_yvel THISACTOR
                    operatemasterswitches se_yvel
                    operaterespawns se_yvel
                    setarray preloadactivations[se_yvel] 1
                }
            }
            ifg se_xvel 0
            {
                operateactivators se_xvel THISACTOR
                operatemasterswitches se_xvel
                operaterespawns se_xvel
                setarray preloadactivations[se_xvel] 1
                set se_xvel 0
            }
        }
    }
    else ife sprite[e_res_temp].picnum A_DIOPEDE_BUTT
        nullop
    else
        state enemy_die_resolve
    killit
ends
defstate enemy_update_sector
    seta .htcgg 1
    ife e_us_count -1
        state e_uds_cleanup
    ifn way_current -1
        set reverse_dir 0
    switch sprite.picnum
        case A_GREATER
        case A_MECHSECT
        case A_SHOTGUNNER
        case A_CULTIST
        case A_MECHBOSS_BOTTOM
        case A_WENTEKO
            break
        case A_DEACON
        case A_DRONE
            ifg reverse_dir 0
            {
                ifl reverse_dir 15
                {
                    inv move_xv
                    inv move_yv
                }
                sub reverse_dir 1
            }
            break
        default
            ifg reverse_dir 0
            {
                ifl reverse_dir 15
                {
                    inv enemy_xv
                    inv enemy_yv
                }
                sub reverse_dir 1
            }
            break
    endswitch
    break
    /* // this code block should be unnecessary with new clipping changes
    mod e_us_count 3
    ife e_us_count 0
    {
        geta .sectnum e_us_count
        ife e_us_count -1
            state e_uds_cleanup
        else
        {
            updatesectorz sprite.x sprite.y sprite.z e_us_count
            ifn e_us_count -1
            {
                geta .x e_us_x
                geta .y e_us_y
                geta .z e_us_z
                geta .sectnum e_us_sectnum
                geta .zvel e_us_zvel
                geta .htfloorz e_us_htfloorz
            }
            else
            {
                seta .x e_us_x
                seta .y e_us_y
                seta .z e_us_z
                seta .sectnum e_us_sectnum
                seta .zvel e_us_zvel
                seta .htfloorz e_us_htfloorz
            }
        }
    }
    add e_us_count 1
    */
ends


defstate e_move_gtfo_check
    set e_move_gtfo 0
    ife sector[e_move_gtfo_sect].lotag 8192
        set e_move_gtfo 8192
    else ife sector[e_move_gtfo_sect].lotag 8193
        set e_move_gtfo 8193
    set e_move_gtfo_temp e_gtfo[e_move_gtfo_sect]
    ifand e_move_gtfo_temp 2
        set e_move_gtfo 8193
    else ifand e_move_gtfo_temp 1
        set e_move_gtfo 8192
ends


var e_block_x 0 2
var e_block_y 0 2
var e_block 0 2
var e_block2 0 2
var e_block3 0 2
var e_block4 0 2
var e_block_counter 0 2
var e_block_pass 0 2
var e_neverblocked 0 2
state enemy_blocked
    break
    // this code is dead/unnecessary
    ife e_neverblocked 0
    {
        set e_block_x sprite.x
        set e_block_y sprite.y
        set e_neverblocked 1
        set e_block_pass 0
        break
    }
    set e_block 0
    
    set e_block2 e_block_x
    set e_block3 e_block_y
    sub e_block2 sprite.x
    sub e_block3 sprite.y
    abs e_block2
    abs e_block3
    
    ife se_hitag 0
    {
        add e_block2 e_block3
        set e_block3 enemy_yv
        abs e_block3
        set e_block4 enemy_xv
        abs e_block4
        add e_block3 e_block4
        sub e_block3 e_block2
        ifg e_block3 30
        {
            
            add e_block_counter 1
            ifge e_block_counter 60
            {
                ifg e_block3 30 ife e_block_counter 79
                {
                    rand e_block 2047
                    seta .ang e_block
                }
                add e_block_counter 1
                ifg e_block_counter 80
                    set e_block_counter 0
            }
        }
        else
            set e_block_counter 0
    }
    set e_block_pass 0
    set e_block_x sprite.x
    set e_block_y sprite.y
ends

defstate enemy_squish_move
    ifn sprite.sectnum -1
    {
        getflorzofslope sprite.sectnum sprite.x sprite.y e_movetemp
        getceilzofslope sprite.sectnum sprite.x sprite.y e_movetemp2
        sub e_movetemp2 e_movetemp
        abs e_movetemp2
        ifand sector.floorstat 1024
        {
            ifand sector.floorstat 512
                nullop
            else ifl e_movetemp2 3072
                set e_movetemp2 3072
        }
        ifand sector.ceilingstat 1024
        {
            ifand sector.ceilingstat 512
                nullop
            else ifl e_movetemp2 3072
                set e_movetemp2 3072
        }
        ifl e_movetemp2 3072 // changed from ifgapzl 12, which also accounted for sprites
        {
            set e_move_ztemp 0
            ife sprite.picnum A_DEACON
                iffloordistl 6
                    set e_move_ztemp 1
            iffloordistl 4
                set e_move_ztemp 1
            ife e_move_ztemp 1
            {
                ifdead
                    nullop
                else
                {
                    switch sprite.picnum
                        case A_DEACON
                            set e_movetemp 0
                            break
                        default
                            geta .extra e_movetemp
                            shiftr e_movetemp 1
                            seta .extra e_movetemp
                            break
                    endswitch
                    ifle e_movetemp 0
                    {
                        set enemy_gibbed 1
                        set p_face_grin 30
                        seta .extra 1
                        
                        switch sprite.picnum
                            case A_DEACON
                            case A_BRUTE
                            case A_ARCHANGEL
                            case A_MECHBOSS_BOTTOM
                                seta .htextra 200
                                seta .htowner player.i
                                break
                            default
                                seta .htextra 100
                                seta .htowner player.i
                                break
                        endswitch
                        seta .htpicnum BULLET
                        soundonce S_GIBSPLODE03
                        soundonce S_IMPACT_HEADSHOT
                        ifactor A_DIOPEDE_HEAD
                        {
                            setp .sound_pitch 480
                            sound S_EXPL_SM005
                            setp .sound_pitch 0
                        }
                        else
                        {
                            geta .ang e_movetemp
                            set e_movetemp2 0
                            for e_movetemp2 range 15
                            {
                                rand e_movetemp3 2047
                                seta .ang e_movetemp3
                                rand e_movetemp3 768
                                add e_movetemp3 1024
                                ifrnd 127
                                    inv e_movetemp3
                                ezshoot e_movetemp3 P_BLOOD
                                seta[RETURN].shade sprite.htg_t 8

                                setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT
                                rand e_movetemp3 64
                                add e_movetemp3 32
                                seta[RETURN].xvel e_movetemp3
                                geta[RETURN].z e_movetemp3
                                add e_movetemp3 2048
                                seta[RETURN].z e_movetemp3
                                seta[RETURN].xrepeat 4
                                seta[RETURN].yrepeat 4
                            }
                            ifactor A_MECHSECT
                            {
                                state generic_gibs
                                spawn A_STRINGY_GUTS2
                            }
                            else
                            {
                                ifrnd 127
                                    spawn A_STRINGY_GUTS2
                                else
                                    spawn A_STRINGY_GUTS
                            }
                            set enemy_squished 1
                            seta .ang e_movetemp
                        }
                        ife enemy_init 0
                            set enemy_init 1
                    }
                }
            }
        }
    }
ends

defstate enemy_do_move
    state enemy_update_sector
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
    }
    else
        set enemy_skipshade 0
    ife cansee_return 1 ife skip_see 0 ifn enemy_init 0
    {
        ifand se_lotag 1
            nullop
        else
            set se_hitag 0
    }
    ifge userdef.player_skill 4
    {
        mul enemy_xv 3
        mul enemy_yv 3
        shiftr enemy_xv 1
        shiftr enemy_yv 1
        switch sprite.picnum
            case A_DEACON
            case A_DRONE
                ifn way_current -1
                {
                    ife sprite[way_current].picnum LOCATORS
                    {
                        mul enemy_xv 28
                        mul enemy_yv 28
                        shiftr enemy_xv 5
                        shiftr enemy_yv 5
                        ldist e_movetemp THISACTOR way_current
                        ifl e_movetemp 512
                        {
                            shiftr enemy_xv 1
                            shiftr enemy_yv 1
                        }
                    }
                }
                break
        endswitch
    }
    ifle sprite.extra 0
    {
        ife e_dead_count 0
        {
            set e_dead_count 1
            mul enemy_shotgun_xv 3
            mul enemy_shotgun_yv 3
            shiftr enemy_shotgun_xv 1
            shiftr enemy_shotgun_yv 1
        }
    }
        ifn enemy_shotgun_xv 0
        {
            add enemy_xv enemy_shotgun_xv
            ifle sprite.extra 0
                shiftr enemy_shotgun_xv 1
            else
                shiftr enemy_shotgun_xv 2
            ifg enemy_shotgun_xv -2 ifl enemy_shotgun_xv 2
                set enemy_shotgun_xv 0
        }
        ifn enemy_shotgun_yv 0
        {
            add enemy_yv enemy_shotgun_yv
            ifle sprite.extra 0
                shiftr enemy_shotgun_yv 1
            else
                shiftr enemy_shotgun_yv 2
            ifg enemy_shotgun_yv -2 ifl enemy_shotgun_yv 2
                set enemy_shotgun_yv 0
        }
    // no more cyclone
    /* ifn cyclone_mod_xv 0
    {
        add enemy_xv cyclone_mod_xv
        set cyclone_mod_xv 0
    }
    ifn cyclone_mod_yv 0
    {
        add enemy_yv cyclone_mod_yv
        set cyclone_mod_yv 0
    } */
    set e_move_gtfo_sect sprite.sectnum
    state e_move_gtfo_check
    set e_movetemp 0
    switch sprite.picnum
        case A_CULTIST
        case A_SHOTGUNNER
        case A_GREATER
            getflorzofslope e_move_gtfo_sect sprite.x sprite.y e_movetemp2
            getceilzofslope e_move_gtfo_sect sprite.x sprite.y e_movetemp3
            sub e_movetemp2 12288
            ifl e_movetemp2 e_movetemp3
                ife e_move_gtfo 8192
                    set e_movetemp 1
                else ife e_move_gtfo 8193
                    set e_movetemp 1
            ife e_move_gtfo 8192
                set e_movetemp 1
            else ife e_move_gtfo 8193
                set e_movetemp 1
            break
        case A_DRONE
        case A_DEACON
            set e_movetemp 0
            ife e_move_gtfo 8192
                set e_movetemp 1
            break
        default
            ife e_move_gtfo 8192
                set e_movetemp 1
            else ife e_move_gtfo 8193
                set e_movetemp 1
            break
    endswitch
    ife e_movetemp 0
    {
        geta .x enemy_tox
        geta .y enemy_toy
        geta .z enemy_toz
        geta .sectnum enemy_tos
        geta .zvel e_move_zvel
        geta .htfloorz e_move_htfloorz
    }
    movesprite THISACTOR enemy_xv enemy_yv 0 CLIPMASK0 temp
    add e_move_count 1
    ifg e_move_count 4
    {
        ifge temp 32768
        {
            rand e_move_return 64
            ifrnd 127
                inv e_move_return
            add e_move_return sprite.ang
            and e_move_return 2047
            seta .ang e_move_return
        }
    }
    set e_move_return temp
    ifvarn temp -1 ife reverse_dir 0
    {
        ifge temp 49152
        {
            sub temp 49152
            ife temp player.i
                nullop
            else
            {
                set e_movetemp3 0
                ifactor A_MECHSECT
                {
                    switch sprite[temp].picnum
                        case T_GRATE
                        case T_FAN
                            ife sprite[temp].picnum T_GRATE
                                seta[temp].picnum T_GRATEBROKE
                            else ife sprite[temp].picnum T_FAN
                                seta[temp].picnum T_FANBROKE
                            rand temp2 1
                            add temp2 S_BULLET_METAL1
                            setp .sound_pitch -480
                            soundvar temp2
                            setp .sound_pitch -1024
                            sound S_MELEE_THUD01
                            sound S_BBOMB_THROW_ALT
                            setp .sound_pitch 0
                            break
                         default
                            geta[temp].picnum e_movetemp2
                            set e_movetemp4 tilesizy[e_movetemp2]
                            shiftl e_movetemp4 2
                            mul e_movetemp4 sprite[temp].yrepeat
                            abs e_movetemp4
                            ifle e_movetemp4 5120
                            {
                                set enemy_forcejump 1
                                ifrnd 127
                                    set e_movetemp3 1
                            }
                            break
                    endswitch
                }
                ife e_movetemp3 0
                {
                    ifl reverse_dir 25
                        setvar reverse_dir 30
                    else
                        setvar reverse_dir 0
                }
            }
            getav[temp].actor_moveable temp2
            ife temp2 1
            {
                getav[temp].actor_moveable_xv temp2
                set temp3 enemy_xv
                shiftr temp3 1
                ifl temp3 2 ifg temp3 -2
                    set temp3 0
                add temp2 temp3
                setav[temp].actor_moveable_xv temp2

                getav[temp].actor_moveable_yv temp2
                set temp3 enemy_yv
                shiftr temp3 1
                ifl temp3 2 ifg temp3 -2
                    set temp3 0
                add temp2 temp3
                setav[temp].actor_moveable_yv temp2
            }

        }
        else ifand temp 32768
        {
            set temp6 0
            sub temp 32768
            set e_movetemp4 temp
            ifn wall[temp].nextsector -1
            {
                ifn wall[temp].nextwall -1
                {
                    getw[temp].nextsector temp
                    ifn temp -1
                    {
                        ifactor A_MECHSECT
                        {
                            getflorzofslope temp sprite.x sprite.y temp2
                            getflorzofslope sprite.sectnum sprite.x sprite.y temp3
                            sub temp3 4096
                            ifle temp3 temp2
                                set temp6 1
                        }
                        switch sector[temp].lotag
                            case 9
                            case 20
                            case 21
                            case 22
                            case 23
                            case 25
                            case 3276
                                set temp2 temp
                                set temp 0
                                ifactor A_GREATER set temp 1
                                else ifactor A_CULTIST set temp 1
                                else ifactor A_SHOTGUNNER set temp 1
                                
                                ife temp 1
                                {
                                    shiftl enemy_xv 1
                                    shiftl enemy_yv 1
                                    movesprite THISACTOR enemy_xv enemy_yv 0 CLIPMASK0 temp
                                    shiftr enemy_xv 1
                                    shiftr enemy_yv 1
                                    ifg sprite.extra 0
                                        ife sect_activator[temp2] 0
                                            ife sect_activator[sprite.sectnum] 0
                                                operate
                                    set temp6 1
                                }
                                ifrnd 64
                                    set temp6 1
                                break
                        endswitch
                    }
                }
                ifand wall[e_movetemp4].cstat 1
                    nullop
                else ife sector.lotag 1 iffloordistl 4
                {
                    ifn wall[e_movetemp4].nextwall -1
                    getw[e_movetemp4].nextsector temp
                    ifn temp -1
                    {
                        set e_move_gtfo_sect temp
                        state e_move_gtfo_check
                        set e_movetemp4 0
                        switch sprite.picnum
                            case A_DRONE
                            case A_DEACON
                                ife e_move_gtfo 8192
                                    set e_movetemp4 1
                                break
                            default
                                ife e_move_gtfo 8192
                                    set e_movetemp4 1
                                else ife e_move_gtfo 8193
                                    set e_movetemp4 1
                                break
                        endswitch
                        ife e_movetemp4 0
                        {
                            getflorzofslope temp sprite.x sprite.y e_movetemp4
                            getflorzofslope sprite.sectnum sprite.x sprite.y temp
                            sub temp 5120
                            ifle temp e_movetemp4
                            {
                                seta .z e_movetemp4
                                set temp6 1
                                movesprite THISACTOR enemy_xv enemy_yv -512 CLIPMASK0 temp
                                set e_movetemp4 enemy_xv
                                shiftr e_movetemp4 1
                                set temp enemy_yv
                                shiftr temp 1
                                movesprite THISACTOR e_movetemp4 temp -512 CLIPMASK0 temp
                            }
                        }
                    }
                }
            }
            ifactor A_MECHSECT
            {
                ifrnd 64
                {
                    set enemy_forcejump 1
                    ifrnd 127
                        set temp6 1
                }
            }
            ife temp6 0
            {
                ifl reverse_dir 25
                    setvar reverse_dir 30
                else
                    setvar reverse_dir 0
            }
        }


    }
    state enemy_squish_move
    set e_move_gtfo_sect sprite.sectnum
    state e_move_gtfo_check
    ife e_move_gtfo 8192
    {
        seta .x enemy_tox
        seta .y enemy_toy
        seta .z enemy_toz
        seta .htbposx enemy_tox
        seta .htbposy enemy_toy
        seta .htbposz enemy_toz
        seta .sectnum enemy_tos
        seta .zvel e_move_zvel
        seta .htfloorz e_move_htfloorz
        set enemy_xv 0
        set enemy_yv 0
    }
    else ife e_move_gtfo 8193
    {
        switch sprite.picnum
            case A_DRONE
            case A_DEACON
                break
             default
                seta .x enemy_tox
                seta .y enemy_toy
                seta .z enemy_toz
                seta .htbposx enemy_tox
                seta .htbposy enemy_toy
                seta .htbposz enemy_toz
                seta .sectnum enemy_tos
                seta .zvel e_move_zvel
                seta .htfloorz e_move_htfloorz
                set enemy_xv 0
                set enemy_yv 0
                break
        endswitch
    }
    else
    {
        set e_movetemp 0
        switch sprite.picnum
            case A_CULTIST
            case A_GREATER
            case A_SHOTGUNNER
                getflorzofslope sprite.sectnum sprite.x sprite.y e_movetemp2
                getceilzofslope sprite.sectnum sprite.x sprite.y e_movetemp3
                sub e_movetemp2 12288
                ifl e_movetemp2 e_movetemp3
                    set e_movetemp 1
                break
        endswitch
        ife e_movetemp 1
        {
            seta .x enemy_tox
            seta .y enemy_toy
            seta .z enemy_toz
            seta .htbposx enemy_tox
            seta .htbposy enemy_toy
            seta .htbposz enemy_toz
            seta .sectnum enemy_tos
            seta .zvel e_move_zvel
            seta .htfloorz e_move_htfloorz
            inv enemy_xv
            inv enemy_yv
            movesprite THISACTOR enemy_xv enemy_yv 0 CLIPMASK0 e_movetemp
            inv enemy_xv
            inv enemy_yv
            seta .zvel e_move_zvel
            seta .htfloorz e_move_htfloorz
        }
    }
    ife se_hitag 0 ifn enemy_init 0
    {
        ife e_mit_freq 0
        {
            state spawn_sound_emitter
            seta[RETURN].extra SE_DIST_ENEMY_MOVE
            add e_mit_freq 1
        }
        else ifge e_mit_freq 30
            set e_mit_freq 0
    }
    state enemy_blocked
ends

var e_dronemove_ang
var e_dronemove_return
defstate enemy_movedrone
    state enemy_update_sector
    geta .ang e_dronemove_ang

    set e_move_gtfo_sect sprite.sectnum
    state e_move_gtfo_check
    set e_movetemp 0
    switch sprite.picnum
        case A_DRONE
        case A_DEACON
            ife e_move_gtfo 8192
                set e_movetemp 1
            break
         default
            ife e_move_gtfo 8192
                set e_movetemp 1
            else ife e_move_gtfo 8193
                set e_movetemp 1
            break
    endswitch
    
    ife e_movetemp 0
    {
        geta .x enemy_tox
        geta .y enemy_toy
        geta .z enemy_toz
        geta .sectnum enemy_tos
        geta .zvel e_move_zvel
        geta .htfloorz e_move_htfloorz
    }
    
    ifge userdef.player_skill 4
    {
        mul move_xv 5
        mul move_yv 5
        shiftr move_xv 2
        shiftr move_yv 2
        ifge userdef.player_skill 4
        {
            mul move_xv 3
            mul move_yv 3
            shiftr move_xv 1
            shiftr move_yv 1
            switch sprite.picnum
                case A_DEACON
                case A_DRONE
                    ifn way_current -1
                    {
                        ife sprite[way_current].picnum LOCATORS
                        {
                            
                            mul move_xv 28
                            mul move_yv 28
                            shiftr move_xv 5
                            shiftr move_yv 5
                            ldist e_movetemp THISACTOR way_current
                            ifl e_movetemp 512
                            {
                                shiftr move_xv 1
                                shiftr move_yv 1
                            }
                        }
                    }
                    break
            endswitch
        }
    }
    
    ifn enemy_shotgun_xv 0
    {
        add move_xv enemy_shotgun_xv
        ifle sprite.extra 0
            shiftr enemy_shotgun_xv 1
        else
            shiftr enemy_shotgun_xv 2
        ifg enemy_shotgun_xv -2 ifl enemy_shotgun_xv 2
            set enemy_shotgun_xv 0
    }
    ifn enemy_shotgun_yv 0
    {
        add move_yv enemy_shotgun_yv
        ifle sprite.extra 0
            shiftr enemy_shotgun_yv 1
        else
            shiftr enemy_shotgun_yv 2
        ifg enemy_shotgun_yv -2 ifl enemy_shotgun_yv 2
            set enemy_shotgun_yv 0
    }
    
    movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 e_movetemp
    set e_dronemove_return e_movetemp
    set e_movetemp5 e_movetemp
    ifvarn e_movetemp -1 ife reverse_dir 0
    {
        ifge e_movetemp 49152
        {
            sub e_movetemp 49152
            ife e_movetemp player.i
                nullop
            else
            {
                ifl reverse_dir 25
                    setvar reverse_dir 30
                else
                    setvar reverse_dir 0
            }
            getav[e_movetemp].actor_moveable e_movetemp2
            ife e_movetemp2 1
            {
                getav[e_movetemp].actor_moveable_xv e_movetemp2
                set e_movetemp3 move_xv
                shiftr e_movetemp3 1
                ifl e_movetemp3 2 ifg e_movetemp3 -2
                    set e_movetemp3 0
                add e_movetemp2 e_movetemp3
                setav[e_movetemp].actor_moveable_xv e_movetemp2

                getav[e_movetemp].actor_moveable_yv e_movetemp2
                set e_movetemp3 move_yv
                shiftr e_movetemp3 1
                ifl e_movetemp3 2 ifg e_movetemp3 -2
                    set e_movetemp3 0
                add e_movetemp2 e_movetemp3
                setav[e_movetemp].actor_moveable_yv e_movetemp2
            }

        }
        else ifand e_movetemp 32768
        {
            set e_movetemp6 0
            sub e_movetemp 32768
            set e_movetemp4 e_movetemp
            ifn wall[e_movetemp].nextsector -1
            {
                ifn wall[e_movetemp].nextwall -1
                {
                    getw[e_movetemp].nextsector e_movetemp
                    ifn e_movetemp -1
                    {
                        switch sector[e_movetemp].lotag
                            case 9
                            case 20
                            case 21
                            case 22
                            case 23
                            case 25
                                ifrnd 64
                                    set e_movetemp6 1
                                break
                        endswitch
                    }
                }
            }
            ife e_movetemp6 0
            {
                ifl reverse_dir 25
                    setvar reverse_dir 30
                else
                    setvar reverse_dir 0
            }
        }


    }
    ifn sprite.sectnum -1
    {
        getflorzofslope sprite.sectnum sprite.x sprite.y e_movetemp
        getceilzofslope sprite.sectnum sprite.x sprite.y e_movetemp2
        sub e_movetemp2 e_movetemp
        abs e_movetemp2
        ifand sector.floorstat 1024
        {
            ifand sector.floorstat 512
                nullop
            else ifl e_movetemp2 3072
                set e_movetemp2 3072
        }
        ifand sector.ceilingstat 1024
        {
            ifand sector.ceilingstat 512
                nullop
            else ifl e_movetemp2 3072
                set e_movetemp2 3072
        }
        ifl e_movetemp2 3072 // changed from ifgapzl 12, which also accounted for sprites
        {
            iffloordistl 4
            {
                ifdead
                    nullop
                else
                {
                    geta .extra e_movetemp
                    shiftr e_movetemp 1
                    seta .extra e_movetemp
                    ifle e_movetemp 0
                    {
                        set enemy_gibbed 1
                        set p_face_grin 30
                        seta .extra 1
                        seta .htextra 100
                        soundonce S_GIBSPLODE03
                        soundonce S_IMPACT_HEADSHOT
                        geta .ang e_movetemp
                        set e_movetemp2 0
                        for e_movetemp2 range 15
                        {
                            rand e_movetemp3 2047
                            seta .ang e_movetemp3
                            rand e_movetemp3 768
                            add e_movetemp3 1024
                            ifrnd 127
                                inv e_movetemp3
                            ezshoot e_movetemp3 P_BLOOD
                            seta[RETURN].shade sprite.htg_t 8

                            setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT
                            rand e_movetemp3 64
                            add e_movetemp3 32
                            seta[RETURN].xvel e_movetemp3
                            geta[RETURN].z e_movetemp3
                            add e_movetemp3 2048
                            seta[RETURN].z e_movetemp3
                            seta[RETURN].xrepeat 4
                            seta[RETURN].yrepeat 4
                        }
                        spawn A_STRINGY_GUTS2
                        seta .ang e_movetemp
                        ife enemy_init 0
                            set enemy_init 1
                    }
                }
            }
        }
    }
    set e_move_gtfo_sect sprite.sectnum
    state e_move_gtfo_check
    ife e_move_gtfo 8192
    {
        seta .x enemy_tox
        seta .y enemy_toy
        seta .z enemy_toz
        seta .htbposx enemy_tox
        seta .htbposy enemy_toy
        seta .htbposz enemy_toz
        seta .sectnum enemy_tos
        seta .zvel e_move_zvel
        seta .htfloorz e_move_htfloorz
        set enemy_xv 0
        set enemy_yv 0
    }
    else ife e_move_gtfo 8193
    {
        switch sprite.picnum
            case A_DRONE
            case A_DEACON
                break
             default
                seta .x enemy_tox
                seta .y enemy_toy
                seta .z enemy_toz
                seta .htbposx enemy_tox
                seta .htbposy enemy_toy
                seta .htbposz enemy_toz
                seta .sectnum enemy_tos
                seta .zvel e_move_zvel
                seta .htfloorz e_move_htfloorz
                set enemy_xv 0
                set enemy_yv 0
                break
        endswitch
    }
    ife se_hitag 0
    {
        ife e_mit_freq 0
        {
            state spawn_sound_emitter
            seta[RETURN].extra SE_DIST_ENEMY_MOVE
            add e_mit_freq 1
        }
        else ifge e_mit_freq 30
            set e_mit_freq 0
    }
    seta .ang e_dronemove_ang
    state enemy_blocked
ends

var pup_damage_temp
defstate pup_damage_adjust
    ifg sprite.htextra 0
        ife sprite.htowner player.i
            set shot_cross_buns 1
    ifle p_pup_damage_time 0
        break
    geta .htextra pup_damage_temp
    ifg pup_damage_temp -1 ifn sprite.htowner -1
    {
        ife sprite.htowner player.i
        {
            shiftl pup_damage_temp 1
            seta .htextra pup_damage_temp
        }
    }
ends

defstate spawn_blood
//    state spawn_bloodsplatter
break
    geta .ang temp2
    geta .htang temp3
    seta .ang temp3
    ezshoot temp3 P_BLOOD
    seta[RETURN].shade sprite.htg_t 8
    add temp3 1024
    and temp3 2047
    seta .ang temp3
    ezshoot temp3 P_BLOOD
    seta .ang temp2
    seta[RETURN].shade sprite.htg_t 8
ends

var ebc_doonce 0 2
var ebc_update 0 2
defstate enemy_body_code
    add ebc_update 1
    ifg ebc_update 3
    {
        geta .sectnum temp
        updatesector sprite.x sprite.y temp
        ifn temp -1
            seta .sectnum temp
        set ebc_update 0
    }
    fall
    ifmove AM_ENEMY_SEARCH
        move AM_ENEMY_SEARCH_STOP
    clipdist 32
    cstator 256
    ife ebc_doonce 0
    {
        geta .extra temp
        set temp2 temp
        shiftr temp 1
        add temp temp2
        seta .extra temp
        geta .htflags temp
        or temp 2048
        seta .htflags temp
        set ebc_doonce 1
        switch sprite.picnum
            case A_MECHSECT_DEAD1
            case A_MECHSECT_DEAD2
                spritepal PAL_MECHSECT
                break
        endswitch
        break
    }

    geta .htextra temp2
    state enemy_squish_move
    ifdead
    {
        ifg se_lotag 0
            state switch_activate
        ife enemy_squished 1
        {
            for gib_temp range 10
            {
                geta .ang gib_temp2
                rand gib_temp3 2047
                seta .ang temp3
                rand gib_temp3 2048

                shiftl gib_temp3 1
                ifrnd 127
                    inv gib_temp3
                ezshoot gib_temp3 P_BLOOD
                ifvarl sprite.htg_t 8 5
                    ifvarg sprite.htg_t 8 0
                        seta[RETURN].shade sprite.htg_t 8

                setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT

                geta[RETURN].z gib_temp3
                sub gib_temp3 2048
                seta[RETURN].z gib_temp3

                seta[RETURN].xrepeat 4
                seta[RETURN].yrepeat 4
                seta .ang gib_temp2
            }
            killit
            break
        }
        switch sprite.picnum
            case A_WENTEKO_DEAD1
            case A_WENTEKO_DEAD2
                espawn A_GENERIC_GIB_SPLASH
                set gib_temp sprite.xrepeat
                shiftr gib_temp 1
                seta[RETURN].xrepeat gib_temp
                set gib_temp sprite.yrepeat
                shiftr gib_temp 1
                seta[RETURN].yrepeat gib_temp
                espawn A_GIBBER
                seta[RETURN].htextra 1000
                rand gib_temp 3
                add gib_temp 6
                for itervar range gib_temp
                {
                    espawn A_GENERIC_DEBRIS
                    setav[RETURN].debris_type DEBRIS_METAL
                    setav[RETURN].debris_add_size 2
                    seta[RETURN].pal 1
                    rand temp6 256
                    add temp6 sprite.htang
                    and temp6 2047
                    seta[RETURN].ang temp6
                    geta .z temp6
                    add temp6 -1024
                    seta[RETURN].z temp6
                }
                killit
                break
            case A_MECHSECT_DEAD1
            case A_MECHSECT_DEAD2
                state skull_gibs
                killit
                break
            case A_CULTIST_DEAD
            case A_SHOTGUNNER_DEAD
                state generic_gibs
                action AC_BASE
                state enemy_die_cleartags
                cactor A_CULTIST_GIBBED
                break
            case A_GREATER_DEAD1
            case A_GREATER_DEAD2
                state generic_gibs
                action AC_BASE
                state enemy_die_cleartags
                cactor A_GREATER_GIBBED
                break
            case A_DEACON_DEAD
                state generic_gibs
                espawn A_EXPLOSION
                seta[RETURN].xrepeat 16
                seta[RETURN].yrepeat 16
                state dying_blood
                killit
                break
            case A_BRUTE_TOP_DEAD
                rand gib_temp 3
                add gib_temp 8
                for itervar range gib_temp
                {
                    espawn A_GENERIC_DEBRIS
                    setav[RETURN].debris_type DEBRIS_METAL
                    seta[RETURN].pal sprite.pal
                    rand temp6 256
                    add temp6 sprite.htang
                    and temp6 2047
                    seta[RETURN].ang temp6
                    geta .z temp6
                    add temp6 -1024
                    seta[RETURN].z temp6
                }
                state skull_gibs
                espawn A_GENERIC_GIB_SPLASH
                set gib_temp sprite.xrepeat
                shiftr gib_temp 1
                seta[RETURN].xrepeat gib_temp
                set gib_temp sprite.yrepeat
                shiftr gib_temp 1
                seta[RETURN].yrepeat gib_temp
                killit
                break
            case A_NUKEMUTANT_DEAD
                state generic_gibs
                action AC_BASE
                state enemy_die_cleartags
                cactor A_NUKEMUTANT_GIBBED
                break
            case A_NUKEMUTANT_GDF_DEAD
                state generic_gibs
                action AC_BASE
                state enemy_die_cleartags
                cactor A_NUKEMUTANT_GDF_GIBBED
                break
            default
                state generic_gibs
                killit
                break
        endswitch
    }
    state pup_damage_adjust
    ifhitweapon
    {
        state spawn_blood
        seta .ang sprite.htang
        set move_v sprite.htextra
        shiftl move_v 8
        inv move_v

        state move_actor
        movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp

        ifwasweapon EXPLOSION
            strength 0
    }
ends
appendevent EVENT_LOADACTOR
    switch sprite.picnum
        case A_MECHSECT_DEAD1
        case A_MECHSECT_DEAD2
        case A_CULTIST_DEAD
        case A_SHOTGUNNER_DEAD
        case A_GREATER_DEAD1
        case A_GREATER_DEAD2
        case A_WENTEKO_DEAD1
        case A_WENTEKO_DEAD2
        case A_NUKEMUTANT_DEAD
        case A_NUKEMUTANT_GDF_DEAD
        case A_BRUTE_TOP_DEAD
        case A_DEACON_DEAD
            ifg sprite.lotag 0
            {
                geta .lotag se_lotag
                seta .lotag 0
            }
            break
    endswitch
endevent

defstate spawn_shard
    espawn I_ARMOR_SHARD
    geta[RETURN].z temp
    sub temp 6144
    seta[RETURN].z temp
    rand temp 128
    add temp 64
    seta[RETURN].xvel temp
    rand temp -640
    sub temp 1024
    seta[RETURN].zvel temp
    geta .ang temp
    randvar temp2 256
    ifrnd 128
        inv temp2
    add temp temp2
    add temp 2048
    and temp 2047
    seta[RETURN].ang temp
    ssp RETURN CLIPMASK0
ends

action AC_MECHSECT_IDLE     0 1 5 1 1
action AC_MECHSECT_WALK     5 4 5 1 16
action AC_MECHSECT_WALK_DEAD 5 4 5 1 1
action AC_MECHSECT_STRAFE   5 4 5 1 12
action AC_MECHSECT_DODGE    5 4 5 1 12
action AC_MECHSECT_SHOOT    25 3 5 1 20
action AC_MECHSECT_HIT      0 1 5 1 1
action AC_MECHSECT_SHOCKED  -5 2 5 1 1
action AC_MECHSECT_DYING1    45 5 1 1 4
action AC_MECHSECT_DEAD1     49 1 1 1 1
action AC_MECHSECT_DYING2    50 4 1 1 4
action AC_MECHSECT_DEAD2     56 7 1 1 1

var ms_die_xv 0 2
var ms_die_yv 0 2
defstate mechsect_debris
    ifg temp4 temp3
    {
        state skull_gibs
        rand gib_temp 3
        add gib_temp 8
        for itervar range gib_temp
        {
            espawn A_GENERIC_DEBRIS
            setav[RETURN].debris_type DEBRIS_METAL
            seta[RETURN].pal sprite.pal
            rand temp6 256
            add temp6 sprite.htang
            and temp6 2047
            seta[RETURN].ang temp6
            geta .z temp6
            add temp6 -1024
            seta[RETURN].z temp6
        }
        set gib_temp 1
    }
ends

useractor notenemy A_MECHSECT_DEAD1 CORPSE_HEALTH
    state enemy_body_code
enda
useractor notenemy A_MECHSECT_DEAD2 CORPSE_HEALTH
    state enemy_body_code
enda
spritenopal A_MECHSECT_HANG
useractor enemy A_MECHSECT_HANG MECHSECT_HEALTH AC_MECHSECT_IDLE
    cstator 8
    cactor A_MECHSECT
enda
spritenopal A_MECHSECT
spritenoshade A_MECHSECT


useractor enemy A_MECHSECT MECHSECT_HEALTH AC_MECHSECT_IDLE
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break

    state e_wakemeup
    state enemy_do_target_icon

    ifand sprite.cstat 8
    {
        set ms_faller 1
        ife enemy_init 0
            set enemy_init 90
        else ifl enemy_init 3
        {
            geta .cstat temp
            xor temp 8
            seta .cstat temp
        }
        else iffloordistl 4
            set enemy_init 2
    }

    ife ms_faller 1
    {
        ifl enemy_init 30
            fall
        ifl enemy_init 90 ifg enemy_init 10
            sub enemy_init 1
    }
    else
        fall

    ifg shot_delay 0
        sub shot_delay 1

    clipdist 16
    ifonwater
    {
        iffloordistl 2
        {
            geta .mdflags temp
            or temp 16
            seta .mdflags temp
            geta .z temp

            getflorzofslope sprite.sectnum sprite.x sprite.y temp2
            set temp3 temp2
            add temp2 2560
            ifg temp temp2
                set temp temp2

            ifaction AC_MECHSECT_SHOOT
            {
                geta .htg_t 2 temp4
                ifl temp4 3
                {
                    shiftl temp4 10
                    sub temp temp4
                    ifpdistl 800
                        nullop
                    else
                    {
                        set move_v 32
                        state move_actor
                        add enemy_xv move_xv
                        add enemy_yv move_yv
                    }
                }
                sub temp 2048
                
                set surface_type sector.floorpicnum
                state get_surface_type
                set temp4 0
                ife surface_type SURFACE_WATER
                    set temp4 1
                else ife surface_type SURFACE_SLIME
                    set temp4 2
                ifn temp4 0
                {
                    ifand sprite.htg_t 2 1
                    {
                        ife sprite.htg_t 2 1
                        {
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 124
                            seta[RETURN].z temp3
                            ife temp4 2
                                setav[RETURN].particle_force_pal 5
                            ifn sector.floorpal 0
                                setav[RETURN].particle_force_pal sector.floorpal
                        }
                        else ife sprite.htg_t 2 4
                        {
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 124
                            seta[RETURN].z temp3
                            ife temp4 2
                                setav[RETURN].particle_force_pal 5
                            ifn sector.floorpal 0
                                setav[RETURN].particle_force_pal sector.floorpal
                        }
                    }
                }
            }
            getceilzofslope sprite.sectnum sprite.x sprite.y temp2
            add temp2 2048
            ifl temp temp2
                set temp temp2
            seta .z temp
        }
        else
        {
            geta .mdflags temp
            ifand temp 16
            {
                xor temp 16
                seta .mdflags temp
            }
        }
    }
    else
    {
        geta .mdflags temp
        ifand temp 16
        {
            xor temp 16
            seta .mdflags temp
        }
    }
    ifspritepal 69
        nullop
    else
    {
        spritepal PAL_MECHSECT
        gets .floorpal temp
        ifg temp 41
            ifl temp 54
                seta .pal temp
    }
    ifdead
    {
        state enemy_die_friction
        ifg enemy_init 2
            set enemy_init 2
        state enemy_clearw1alt

        ifaction AC_MECHSECT_WALK_DEAD
        {
            cstat 0
            soundonce S_SECT_DEATHSPIRAL
            ife ms_flashpal 0
                geta .pal ms_flashpal
            ifand sprite.htg_t 2 1
            {   
                set enemy_skipshade 1
                seta .shade -127
            }
            ifspritepal 69
                seta .pal ms_flashpal
            else
                spritepal 69
            ifn counter3 0
                ifge sprite.htg_t 2 1
                {
                    state spawn_sound_emitter
                    seta[RETURN].extra SE_DIST_ENEMY_MS_DIE // read distance
                    cstat 0
                    state skull_gibs
                    stopactorsound THISACTOR S_SECT_DEATHSPIRAL
                    or p_wantline TALK_GIB
                    ifpdistl 1024
                    {
                        set face_target player.i
                        state face_actor
                        seta .ang face_return
                        getu .vm_distance temp
                        sub temp 1024
                        inv temp
                        shiftr temp 3
                        set move_v temp
                        state move_actor
                        shiftl move_xv 14
                        shiftl move_yv 14
                        add move_xv player.posxv
                        add move_yv player.posyv
                        setp .posxv move_xv
                        setp .posyv move_yv
                    }
                    killit
                }    

            ifactioncount 56
            {
                state spawn_sound_emitter
                seta[RETURN].extra SE_DIST_ENEMY_MS_DIE // read distance
                cstat 0
                state skull_gibs
                stopactorsound THISACTOR S_SECT_DEATHSPIRAL
                or p_wantline TALK_GIB
                ifpdistl 1024
                {
                    set face_target player.i
                    state face_actor
                    seta .ang face_return
                    getu .vm_distance temp
                    sub temp 1024
                    inv temp
                    shiftr temp 3
                    set move_v temp
                    state move_actor
                    shiftl move_xv 14
                    shiftl move_yv 14
                    add move_xv player.posxv
                    add move_yv player.posyv
                    setp .posxv move_xv
                    setp .posyv move_yv
                }
                killit
            }

            geta .ang temp
            rand temp2 32
            add temp2 64
            ifrnd 32
                inv temp2
            ife counter3 0
                add temp temp2
            and temp 2047
            seta .ang temp
            rand move_v 20
            add move_v 64
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            add enemy_xv ms_die_xv
            add enemy_yv ms_die_yv
            shiftr ms_die_xv 1
            shiftr ms_die_yv 1
            ifrnd 64
            {
                espawn A_SMOKE2
                seta[RETURN].cstat 32768
                seta[RETURN].zvel -1280
                geta .z temp
                sub temp 4096
                seta[RETURN].z temp
                ssp RETURN CLIPMASK0
            }
            state enemy_do_move
        }
        else
        {
            cstat 0
            ifactioncount 5
            {
                state spawn_sound_emitter
                seta[RETURN].extra SE_DIST_ENEMY_MS_DIE // read distance

                ifaction AC_MECHSECT_DYING2
                    action AC_MECHSECT_DEAD2
                else ifaction AC_MECHSECT_DYING1
                    action AC_MECHSECT_DEAD1
                cstat 0
            }

            state dying_blood
            state enemy_do_move
        }

        ifn enemy_xv 0
            shiftr enemy_xv 1
        ifn enemy_yv 0
            shiftr enemy_yv 1
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        ifn enemy_gibbed 0
        {

            ifaction AC_MECHSECT_DEAD1
                killit
            ifaction AC_MECHSECT_DEAD2
                killit
            ifactioncount 2
                cstat 32768
        }
        else
        {
            ifaction AC_MECHSECT_DEAD1
            {
                strength MECHSECT_HEALTH
                action AC_ENEMY_BODY
                state enemy_die_cleartags
                cactor A_MECHSECT_DEAD1
            }
            else ifaction AC_MECHSECT_DEAD2
            {
                strength MECHSECT_HEALTH
                action AC_ENEMY_BODY
                state enemy_die_cleartags
                cactor A_MECHSECT_DEAD2
            }
        }
        break
    }
    state pup_damage_adjust
    geta .htextra temp4
    ife sprite.htpicnum BULLET ife sprite.htowner player.i ifg temp4 0
    {
        ife player.curr_weapon WEAPON_SMG 
        {
            shiftl temp4 1
            seta .htextra temp4
        }
        else ife player.curr_weapon WEAPON_LOVERBOY ifn weapon1_alt 0
        {
            shiftl temp4 1
            seta .htextra temp4
        }
        else ife player.curr_weapon WEAPON_MINIGUN
        {
            add enemy_minigun_dmg temp4
        }
    }
    else ife sprite.htpicnum P_SMG2 ife sprite.htowner player.i ifg temp4 0
    {
        shiftl temp4 1
        seta .htextra temp4
    }
    else ifg sprite.extra 0
    {
        set temp5 enemy_minigun_dmg
        shiftr temp5 3
        sub enemy_minigun_dmg temp5
        clamp enemy_minigun_dmg 0 65536
    }
    
    set temp8 0
    ife sprite.htpicnum P_SHOCKER
        ife sprite.htowner player.i
            ife player.curr_weapon WEAPON_SHOCKER
                ifg temp4 0
                    set temp8 1

    ifhitweapon
    {
        geta .owner temp5
        ifn temp5 -1 ifn temp5 THISACTOR ifn temp5 player.i
        {
            ife sprite[temp5].picnum A_SHOCKCANISTER_BROKE
                seta .htpicnum P_SHOCKER
            else ife sprite[temp5].picnum A_SHOCKCANISTER
                seta .htpicnum P_SHOCKER
        }
        ife enemy_init 90
            set enemy_init 10

        state spawn_blood

        ifwasweapon P_SHOCKER
        {
            add enemy_shocked 1
            ifg enemy_shocked 3
                set enemy_shocked 1
            set temp2 temp4
            mul temp2 enemy_shocked

            geta .extra temp3
            sub temp3 temp2
            ife temp5 player.i
            {
                ife w0alt 0
                    sub temp3 temp2
            }
            else
                sub temp3 temp2
            seta .extra temp3
        }

        ifdead
        {
            ife counter3 1
                set enemy_shocked 0
            state enemy_die_resolve
            sound S_SECT_HURT1
            state enemy_confirm_bowled
            set gib_temp 0
            ifwasweapon EXPLOSION
            {
                set temp3 MECHSECT_HEALTH
                shiftr temp3 2
                add temp3 MECHSECT_HEALTH
                ifg temp4 temp3
                {
                    state mechsect_debris
                    cstat 32768
                }
            }
            else ifwasweapon BULLET
            {
                set temp3 MECHSECT_HEALTH
                shiftr temp3 2
                add temp3 MECHSECT_HEALTH
                add temp3 MECHSECT_HEALTH
                ife sprite.htowner player.i ife player.curr_weapon WEAPON_MINIGUN
                {
                    ifg enemy_minigun_dmg MECHSECT_HEALTH
                        add temp4 temp3
                }
            /* redefinequote 11 %ld
            qsprintf 11 11 enemy_minigun_dmg
            quote 11 */
                state mechsect_debris
                cstat 32768
            }

            ifn gib_temp 0
                set enemy_gibbed 1

            ifrnd 32
                or p_wantline TALK_KILL
            else ifn enemy_gibbed 0
                or p_wantline TALK_GIB
            geta .ang temp
            seta .ang sprite.htang
            set move_v temp4

            ifn enemy_shocked 0
            {
                ife temp8 1
                    state crackskulls
                action AC_MECHSECT_WALK_DEAD
                shiftl move_v 5
            }
            else
            {
                ifrnd 128
                {
                    action AC_MECHSECT_DYING2
                    shiftl move_v 5
                }
                else
                {
                    action AC_MECHSECT_DYING1
                    shiftl move_v 4
                }
            }

            clamp move_v -512 512
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            ifaction AC_MECHSECT_WALK_DEAD
            {
                set ms_die_xv enemy_xv
                set ms_die_yv enemy_yv
            }
            seta .ang temp

            ifwasweapon EXPLOSION
            {
                ifaction AC_MECHSECT_DYING1
                    shiftr move_v 1
                seta .zvel -move_v
                ssp THISACTOR CLIPMASK0
            }
        }
        else
        {
            ife enemy_shocked 0
            {
                action AC_MECHSECT_HIT
                sound S_SECT_HURT2
            }
            else
                action AC_MECHSECT_SHOCKED
            set enemy_strafe 0
            set enemy_start 0
            set enemy_stop 1
            geta .ang temp
            seta .ang sprite.htang
            set move_v temp4
            shiftl move_v 3
            clamp move_v -512 512
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            seta .ang temp
            fall
            state enemy_do_move
        }
        break
    }
    getp .i cansee_target
    set cansee_height 9728
    getceilzofslope sprite.sectnum sprite.x sprite.y temp
    geta .z temp2
    sub temp2 cansee_height
    ifl temp2 temp
    {
        geta .z temp2
        sub temp2 4096
        ifl temp2 temp
            set cansee_height 1024
        else
            set cansee_height 4096
    }
    set temp3 sprite.z
    sub temp3 player.posz
    sub temp3 4096
    abs temp3
    ifl temp3 2048
    {
        ifg cansee_height 1024
            shiftr cansee_height 2
    }
    getp .i temp2
    getflorzofslope sprite[temp2].sectnum sprite[temp2].x sprite[temp2].y temp3
    geta[temp2].z temp4
    geta .z temp5
    ifg sprite[temp2].z temp3
        seta[temp2].z temp3
    ifg sprite.z temp3
        seta .z temp3
    state cansee_actor
    seta[temp2].z temp4
    seta .z temp5
    ife cansee_return_o 1
    {
        ife ms_faller 1
        {
            ldist temp THISACTOR player.i
            ifl temp 700
            {
                ife enemy_init 90
                    set enemy_init 10
            }
            else ifl temp 3072
            {
                ife player_target THISACTOR
                {
                    ifl counter2 14
                        add counter2 1
                    else
                        ife enemy_init 90
                            set enemy_init 10
                }
            }
        }
        else
            set enemy_init 2
        state enemy_checkw1alt
    }

    ifaction AC_MECHSECT_HIT
    {
        ifactioncount 7
            action AC_MECHSECT_IDLE
        break
    }
    else ifaction AC_MECHSECT_SHOCKED
    {
        soundonce S_AMB_NEONFLICKR01
        soundonce S_AMB_NEONFLICKR02
        ifn enemy_shocked 0
        {
            switch enemy_shocked
            {
                case 1
                    ifactioncount 11
                    {
                        action AC_MECHSECT_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
                case 2
                    ifactioncount 15
                    {
                        action AC_MECHSECT_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
                case 3
                    ifactioncount 25
                    {
                        action AC_MECHSECT_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
            }
            endswitch
            set enemy_shocked 0
        }
        else
        {
            ifactioncount 7
                action AC_MECHSECT_IDLE
        }
        ife ms_flashpal 0
            geta .pal ms_flashpal
               
        ifspritepal 69
            seta .pal ms_flashpal
        else
        {
            set enemy_skipshade 1
            seta .shade -127
            spritepal 69
        }
        break
    }
    else ifspritepal 69
        seta .pal ms_flashpal
    state enemy_check_init
    ife enemy_init_return 1
        break
    ifg enemy_init 2
    {
        iffloordistl 1
        {
            set enemy_init 2
            ifpdistl 1024
            {
                addphealth -10
                add shakeitbaby 6
            }
        }

        break
    }

    cstat 257

    ife enemy_strafe 0
        state e_fp

    ifrnd 96
        ife enemy_start 0
            ife enemy_shoot 0
            {
                set enemy_start 1
                ifg enemy_strafe 0
                    sub enemy_strafe 1
            }
    getp .i att_target
    state angle_to_target

    ifpdistl 1024 ife cansee_return 1
        state e_fp
    else ifrnd 32 ife enemy_strafe 0 ife enemy_shoot 0 ife enemy_start 0 ife se_hitag 0
    {
        set enemy_strafe 1
        rand strafe_dir 1
    }

    ife se_hitag 0
    {
        ifn cansee_return 1
        {
            ifrnd 32 ife enemy_strafe 0
            {
                ifrnd 64
                    state e_fp
                set enemy_strafe 1
                rand strafe_dir 1
            }
        }
        else ifrnd 16 ifpdistl 1024 ifl att_return 256 ife cansee_return 1 ife enemy_forcejump 0 ife shot_delay 0 ife enemy_shoot 0
            set enemy_shoot 1
    }
    ifrnd 2 ife enemy_stop 0 ife se_hitag 0 ife enemy_start 8
        set enemy_stop 1

    ifpdistl 800 ife enemy_stop 0 ife se_hitag 0
        set enemy_stop 8

    ifn enemy_start 0 ife enemy_stop 0
    {
        set move_v enemy_start

        shiftl move_v 4
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        add enemy_start 1
        ifg enemy_start 8
            set enemy_start 8

        set enemy_stop 0
        ifg enemy_strafe 0
            sub enemy_strafe 1
    }

    ifn enemy_strafe 0 ife enemy_stop 0
    {
        state e_fp
        set move_v enemy_start
        ifl move_v 4
            set move_v 4
        ifn way_current -1
            shiftl move_v 3
        else
            shiftl move_v 4
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv

        geta .ang temp
        set temp2 temp // save for later
        add temp 256
        ife strafe_dir 1
            add temp 1024
        and temp 2047
        seta .ang temp

        set move_v enemy_strafe
        ifn way_current -1
            shiftl move_v 4
        else
            shiftl move_v 3
        state move_actor
        add enemy_xv move_xv
        add enemy_yv move_yv
        seta .ang temp2

        add enemy_strafe 1
        ifg enemy_strafe 8
            set enemy_strafe 8

        set enemy_stop 0
        ifg enemy_start 0
            sub enemy_start 1
        set enemy_shoot 0
    }
    ifpdistl 4096 ifrnd 1 ife cansee_return 1 iffloordistl 1
    {
        ifpdistl 1024
        {
            ife enemy_shoot 0
                set enemy_shoot 1
        }
        else
            set enemy_forcejump 1
        shiftl enemy_xv 1
        shiftl enemy_yv 1
    }
    ifn enemy_stop 0
    {
        shiftr enemy_xv 1
        shiftr enemy_yv 1
        add enemy_stop 1
        ifn enemy_start 0
            sub enemy_start 1
        ifn enemy_strafe 0
            sub enemy_strafe 1
        ifg enemy_stop 8
        {
            set enemy_xv 0
            set enemy_yv 0
            set enemy_stop 0
            set enemy_start 0
            set enemy_strafe 0
        }
    }
    ifn enemy_shoot 0
    {
        shiftr enemy_xv 3
        shiftr enemy_yv 3
        add enemy_shoot 1
        ifn enemy_start 0
            sub enemy_start 1
        ifn enemy_strafe 0
            sub enemy_strafe 1
        ifg enemy_shoot 30
        {
            set enemy_xv 0
            set enemy_yv 0
            set enemy_stop 0
            set enemy_shoot 0
            set enemy_start 0
            set enemy_strafe 0
        }
    }
    ifn enemy_shoot 0
    {
        ifaction AC_MECHSECT_SHOOT
        {
            ifceilingdistl 16
            {
                ifl sprite.zvel GRAVITATIONALCONSTANT
                {

                    geta .zvel temp
                    add temp GRAVITATIONALCONSTANT
                    seta .zvel GRAVITATIONALCONSTANT
                    getceilzofslope sprite.sectnum sprite.x sprite.y temp
                    getflorzofslope sprite.sectnum sprite.x sprite.y temp2
                    add temp 4096
                    ifg temp temp2
                    {
                        sub temp2 1024
                        set temp temp2
                    }
                    ifl sprite.z temp
                        seta .z temp
                    shiftr reverse_dir 1
                }
            }
            else
            {
                geta .zvel temp
                ifl temp -1536
                    set temp -1536
                seta .zvel temp
            }
            
            ldist temp player.i THISACTOR
            ifl temp 1024 ifl sprite.z player.posz ifl sprite.zvel 0
            {
                geta .zvel temp
                shiftr temp 1
                seta .zvel temp
                seta .z player.posz
            }

            getu .vm_distance temp
            ifp pducking
                set temp2 1280
            else
                set temp2 1024
            ifl att_return 256 ifl temp temp2 ife enemy_shoot 10
            {
                setp .sound_pitch -1024
                sound S_MELEE_THUD01
                setp .sound_pitch 0
                addphealth -10
                add shakeitbaby 6
            }
            ifactioncount 3
            {
                action AC_MECHSECT_IDLE
                set enemy_shoot 0
                iffloordistl 1
                    state mechsect_footstep
            }
        }
        else
        {
            iffloordistl 1
                state mechsect_footstep
            setp .sound_pitch -1024
            sound S_BBOMB_THROW_ALT
            setp .sound_pitch 0
            action AC_MECHSECT_SHOOT
            setactor[THISACTOR].zvel -1536
            ssp THISACTOR CLIPMASK0
            state e_fp

            set shot_delay 60
        }
    }
    else ifn enemy_forcejump 0
    {
        ifaction AC_MECHSECT_SHOOT
        {
            ifceilingdistl 16
            {
                ifl sprite.zvel GRAVITATIONALCONSTANT
                {

                    geta .zvel temp
                    add temp GRAVITATIONALCONSTANT
                    seta .zvel GRAVITATIONALCONSTANT
                }
            }
            else
            {
                geta .zvel temp
                ifl temp -1536
                    set temp -1536
                seta .zvel temp
            }

            ifactioncount 3
            {
                action AC_MECHSECT_IDLE
                iffloordistl 1
                    state mechsect_footstep
                set enemy_forcejump 2
            }
        }
        else ife enemy_forcejump 2
        {
            iffloordistl 1
                set enemy_forcejump 0
        }
        else
        {
            iffloordistl 1
                state mechsect_footstep
            setp .sound_pitch -768
            sound S_BBOMB_THROW_ALT
            setp .sound_pitch 0
            action AC_MECHSECT_SHOOT
            setactor[THISACTOR].zvel -3072
            set reverse_dir 0
            set move_v 10
            state move_actor
            add enemy_xv move_xv
            add enemy_yv move_yv
            ssp THISACTOR CLIPMASK0
        }
    }
    else ifn enemy_strafe 0
    {
        ifaction AC_MECHSECT_STRAFE
            nullop
        else
            action AC_MECHSECT_STRAFE
    }
    else ifn enemy_start 0
    {
        ifaction AC_MECHSECT_WALK
            nullop
        else
            action AC_MECHSECT_WALK
    }
    else ifg enemy_stop 2
    {
        ifaction AC_MECHSECT_IDLE
            nullop
        else
            action AC_MECHSECT_IDLE
    }

    ifpdistl 8192
    {
        set temp 0

        ifaction AC_MECHSECT_WALK
            set temp 1
        else ifaction AC_MECHSECT_STRAFE
            set temp 1

        ife temp 1
        {
            add enemy_stepcounter 1
            ifrnd 64
                add enemy_stepcounter 1
            ifg enemy_stepcounter 4
            {
                iffloordistl 1
                    state mechsect_footstep
                set enemy_stepcounter 0
            }
        }
    }
    ifn way_current -1
        set reverse_dir 0
    ifn reverse_dir 0
    {
        inv enemy_xv
        inv enemy_yv
        shiftr enemy_xv 1
        shiftr enemy_yv 1
        sub reverse_dir 1
    }
    state enemy_do_move
enda


appendevent EVENT_ANIMATESPRITES
    ifactor A_MECHSECT
    {
        ifn sprite.pal 77
        {
            getflorzofslope sprite.sectnum sprite.x sprite.y temp
            add temp 2560
            ifg sprite.z temp
                seta .z temp
        }
    }
endevent

var enemy_horiz 0 2

state grenade_drop_aim
    ldist temp THISACTOR player.i
    set temp2 sprite[player.i].z
    sub temp2 sprite.z
    ifg temp2 -8192
        add temp2 8192 // aim at the player feet
    set temp3 temp2
    scalevar enemy_horiz temp2 projectile[P_GRENADE].vel temp

    // compensate for the drop
    sub temp 256 // player clipdist
    set temp2 temp
    shiftl temp2 1
    add temp2 projectile[P_GRENADE].vel
    set temp3 temp2
    scalevar temp2 temp2 temp2 projectile[P_GRENADE].vel
    sub temp2 temp3
    scalevar temp2 temp2 projectile[P_GRENADE].drop temp
    shiftr temp2 2
    add enemy_horiz temp2

    clamp enemy_horiz -32768 32767 // prevent overflow
ends

action AC_CULTIST_IDLE     64 1 5 1 1
action AC_CULTIST_WALK     0 4 5 1 12
action AC_CULTIST_STRAFE   0 4 5 1 16
action AC_CULTIST_DODGE    32 4 5 1 12
action AC_CULTIST_SHOOT    64 3 5 1 1
action AC_CULTIST_IDLE_CRC 96 1 5 1 1
action AC_CULTIST_SHOOT_CRC 96 3 5 1 1  //
action AC_CULTIST_HIT      126 1 1 1 1
action AC_CULTIST_SHOCKED  134 2 5 1 1
action AC_CULTIST_DYING    126 8 1 1 8
action AC_CULTIST_SUFFER   127 2 1 1 12
action AC_CULTIST_DEAD     131 1 1 1 4
action AC_CULTIST_GIBBED   145 8 1 1 8
action AC_CULTIST_HEADACHE 154 8 1 1 8
action AC_SHOTGUNNER_HEADACHE 111 8 1 1 8

spriteshadow A_CULTIST
spriteshadow A_CULTIST_DEAD
spriteshadow A_CULTIST_GIBBED
spriteshadow A_SHOTGUNNER
spriteshadow A_SHOTGUNNER_DEAD
spriteshadow A_SHOTGUNNER_GIBBED
/* spriteflags A_CULTIST 33554432 */

var was_lost_sound 1 2

// spritenoshade 6801
spriteflags A_TARGET_ICON 10308
action ICON_NIL 1860 1 1 1 1
appendevent EVENT_SPAWN
    ifactor A_TARGET_ICON
    {
        cstat 32768
        changespritestat THISACTOR STAT_TARGET_ICON
    }
endevent


useractor notenemy A_TARGET_ICON 0 ICON_NIL
enda

appendevent EVENT_WORLD
    for temp9 sprofstat STAT_TARGET_ICON
    {
        setu .vm_sprite temp9
        ife target_icon_id -1
            sizeat 0 0
        else ife sprite[target_icon_id].statnum STAT_MAXSTATUS
            sizeat 0 0
        ife sprite.xrepeat 0
            changespritestat THISACTOR STAT_ACTOR
        else
        {
            ifspawnedby A_SECTOR_SWITCH
                seta .xrepeat 0
            else
            {
                sizeat 7 6
                seta .shade -127
                ife st_do_once 0
                {
                    set st_do_once 1
                    set se_zvel tilesizy[sprite[target_icon_id].picnum]
                    shiftl se_zvel 2
                    mul se_zvel sprite[target_icon_id].yrepeat
                    add se_zvel 256
                    switch sprite[target_icon_id].picnum
                        case A_MECHSECT
                        case A_MECHSECT_HANG
                            ifand sprite[target_icon_id].cstat 8
                                inv se_zvel
                            break
                    endswitch
                }
                seta .blend 129
                add counter 1
                clamp counter 0 65536
                ifg counter 2
                {
                    cstat 2
                    switch sprite[target_icon_id].picnum
                        case A_MECHSECT
                        case A_MECHSECT_HANG
                            ifand sprite[target_icon_id].cstat 8
                                cstator 8
                            break
                    endswitch
                }
                seta .x sprite[target_icon_id].x
                seta .y sprite[target_icon_id].y
                geta[target_icon_id].z temp
                sub temp se_zvel
                seta .z temp
                seta .sectnum sprite[target_icon_id].sectnum
                
                ife actorvar[target_icon_id].need_target_icon 0
                    seta .xrepeat 0
                ife actorvar[target_icon_id].target_icon_id -1
                    seta .xrepeat 0
            }
        }
    }
endevent

useractor notenemy A_CULTIST_GIBBED 0 AC_BASE
    ifand sprite.cstat 4
        cstat 4
    else
        cstat 0
    fall
    set actor_gib 2
    changespritestat THISACTOR STAT_STATIC_GIB
enda
action AC_CULTIST_DEADHEAD 28 1 1 1 1
useractor notenemy A_CULTIST_DEAD CORPSE_HEALTH
    ife enemy_headache 1
        action AC_CULTIST_DEADHEAD
    state enemy_body_code
enda
useractor notenemy A_CULTIST_DEADHEAD CORPSE_HEALTH
    set enemy_headache 1
    action AC_CULTIST_DEADHEAD
    state enemy_die_cleartags
    cactor A_CULTIST_DEAD
enda
action AC_CULTIST_CRC 0 1 5 1 1 1
useractor enemy A_CULTIST_CROUCH CULTIST_HEALTH AC_CULTIST_CRC
    fall
    action AC_CULTIST_IDLE_CRC
    set enemy_shoot 1
    cactor A_CULTIST
enda
action AC_CULTIST_SP -1 1 5 1 1 1
useractor enemy A_CULTIST_STAYPUT CULTIST_HEALTH AC_CULTIST_IDLE
    fall
    action AC_CULTIST_IDLE
    cactor A_CULTIST
enda



useractor notenemy A_SHOTGUNNER_GIBBED 0 AC_BASE
    ifand sprite.cstat 4
        cstat 4
    else
        cstat 0
    fall
    set actor_gib 2
    changespritestat THISACTOR STAT_STATIC_GIB
enda
action AC_SHOTGUNNER_DEADHEAD -14 1 1 1 1
useractor notenemy A_SHOTGUNNER_DEAD CORPSE_HEALTH
    ife enemy_headache 1
        action AC_SHOTGUNNER_DEADHEAD
    state enemy_body_code
enda
useractor notenemy A_SHOTGUNNER_DEADHEAD CORPSE_HEALTH
    set enemy_headache 1
    action AC_SHOTGUNNER_DEADHEAD
    state enemy_die_cleartags
    cactor A_SHOTGUNNER_DEAD
enda
useractor enemy A_SHOTGUNNER_CROUCH SHOTGUNNER_HEALTH AC_CULTIST_CRC
    fall
    action AC_CULTIST_IDLE_CRC
    cactor A_SHOTGUNNER
enda
useractor enemy A_SHOTGUNNER_STAYPUT SHOTGUNNER_HEALTH AC_CULTIST_IDLE
    fall
    action AC_CULTIST_IDLE
    cactor A_SHOTGUNNER
enda

defstate lesser_shotgun_shared
    ife st_do_once 0
    {
        set st_do_once 1
        ifspritepal PAL_SHOTGUNNER_ALT
        {
            seta .extra SHOTGUNNER_ALT_HEALTH
            set gunner_type 1
        }
    }
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break
    state e_wakemeup
    ifpdistl 8192
    {
        ifaction AC_CULTIST_WALK
        {
            add enemy_stepcounter 1
            ifg enemy_stepcounter 12
            {
                gets .floorpicnum surface_type
                geta .xvel p_xvel
                ifg p_xvel 96
                    set p_steptype 1
                iffloordistl 1
                    state player_footstep
                set enemy_stepcounter 0
            }
        }
        else ifaction AC_CULTIST_STRAFE
        {
            add enemy_stepcounter 1
            ifg enemy_stepcounter 8
            {
                gets .floorpicnum surface_type
                geta .xvel p_xvel
                ifg p_xvel 96
                    set p_steptype 1
                iffloordistl 1
                    state player_footstep
                set enemy_stepcounter 0
            }
        }
        else ifaction AC_CULTIST_DODGE
        {
            add enemy_stepcounter 1
            ifg enemy_stepcounter 8
            {
                gets .floorpicnum surface_type
                geta .xvel p_xvel
                ifg p_xvel 96
                    set p_steptype 1
                iffloordistl 1
                    state player_footstep
                set enemy_stepcounter 0
            }
        }
        else
            set enemy_stepcounter 0
    }
    else
        set enemy_stepcounter 0

    state enemy_do_target_icon
    
    fall
    ifactor A_SHOTGUNNER
        clipdist 48
    else
        clipdist 32

    ifg shot_delay 0
        sub shot_delay 1
    state smg_flamechance
    ifdead
    {
        state enemy_die_friction
        set enemy_init 1
        set temp3 0

        ifaction AC_CULTIST_DYING
        {
            set temp3 1
            seta .ang sprite.htang
            set move_v sprite.htextra
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            shiftr move_v 1
            inv move_v
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
        }
        else ifaction AC_CULTIST_HEADACHE
        {
            set temp3 1
            seta .ang sprite.htang
            set move_v sprite.htextra
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            shiftr move_v 1
            inv move_v
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
            ifl sprite.htg_t 2 2
            {
                for temp3 range 2
                {
                    set temp4 tilesizy[sprite.picnum]
                    shiftl temp4 2
                    mul temp4 sprite.yrepeat
                    set temp2 sprite.z
                    sub temp2 temp4
                    add temp2 1024
                    
                    rand temp4 512
                    add temp4 512
                    shiftl temp4 1
                    ifrnd 127
                        inv temp4
                    ezshoot temp4 P_BLOOD
                    seta[RETURN].shade sprite.htg_t 8

                    setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT
                    seta[RETURN].xvel 32
                    seta[RETURN].z temp2
                    seta[RETURN].xrepeat 4
                    seta[RETURN].yrepeat 4
                    rand temp4 2047
                    seta[RETURN].ang temp4
                }
            }
        }
        else ifaction AC_SHOTGUNNER_HEADACHE
        {
            set temp3 1
            seta .ang sprite.htang
            set move_v sprite.htextra
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            shiftr move_v 1
            inv move_v
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
            ifl sprite.htg_t 2 2
            {
                for temp3 range 2
                {
                    set temp4 tilesizy[sprite.picnum]
                    shiftl temp4 2
                    mul temp4 sprite.yrepeat
                    set temp2 sprite.z
                    sub temp2 temp4
                    add temp2 1024
                    
                    rand temp4 512
                    add temp4 512
                    shiftl temp4 1
                    ifrnd 127
                        inv temp4
                    ezshoot temp4 P_BLOOD
                    seta[RETURN].shade sprite.htg_t 8

                    setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT
                    seta[RETURN].xvel 32
                    seta[RETURN].z temp2
                    seta[RETURN].xrepeat 4
                    seta[RETURN].yrepeat 4
                    rand temp4 2047
                    seta[RETURN].ang temp4
                }
            }
        }
        else ifaction AC_CULTIST_GIBBED
        {
            set temp3 1
            seta .ang sprite.htang
            set move_v sprite.htextra
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            shiftr move_v 1
            inv move_v
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
        }
        else ifaction AC_CULTIST_SUFFER
            set temp3 1

        ife temp3 1
        {
            state enemy_clearw1alt

            ifaction AC_CULTIST_SUFFER
            {
                randvar temp 32
                ifg sprite.htg_t 2 temp
                {
                    state spawn_sound_emitter
                    action AC_CULTIST_DYING
                    ifrnd 128 cstat 4
                    else cstat 0
                    seta .htextra 0

                    set e_lastsnd_temp 0
                    whilen e_lastsnd_temp 1
                    {
                        rand temp 2
                        switch temp
                        {
                            case 0 set temp S_CULTIST_DEAD1 break
                            case 1 set temp S_CULTIST_DEAD2 break
                            case 2 set temp S_CULTIST_DEAD3 break
                        }
                        endswitch
                        ifn temp e_lesser_lastsnd
                            set e_lastsnd_temp 1
                    }
                    ifactor A_SHOTGUNNER
                        setp .sound_pitch -222
                    ifpdistl ENEMY_SOUND_DIST
                        soundoncevar temp
                    setp .sound_pitch 0
                    set e_lesser_lastsnd temp
                }
                else
                {
                    ifrnd 64
                    {
                        ifactor A_SHOTGUNNER
                            setp .sound_pitch -222
                        sound S_CULTIST_PAINHUGE
                        setp .sound_pitch 0
                    }
                    state spawn_sound_emitter
                    set move_v sprite.htextra
                    shiftl move_v 5
                    inv move_v
                    state move_actor
                    set enemy_xv move_xv
                    set enemy_yv move_yv
                    mul enemy_shotgun_xv 3
                    mul enemy_shotgun_yv 3
                    shiftr enemy_shotgun_xv 1
                    shiftr enemy_shotgun_yv 1
                    state enemy_do_move
                }
            }
            else
            {
                
                ifactioncount 8
                {
                    state spawn_sound_emitter
                    action AC_CULTIST_DEAD

                    ifn enemy_gibbed 1
                    {
                        action AC_ENEMY_BODY
                         strength CORPSE_HEALTH
                        ifactor A_SHOTGUNNER
                        {
                            ife enemy_headache 1
                                action AC_SHOTGUNNER_DEADHEAD
                            state enemy_die_cleartags
                            cactor A_SHOTGUNNER_DEAD
                        }
                        else
                        {
                            ife enemy_headache 1
                                action AC_CULTIST_DEADHEAD
                            state enemy_die_cleartags
                            cactor A_CULTIST_DEAD
                        }
                        set p_steptype 3
                        state player_footstep
                    }
                }
            }
            state dying_blood

        }
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        ife enemy_gibbed 1
        {
            ifaction AC_CULTIST_DEAD
            {
                action AC_BASE
                state enemy_die_cleartags
                cactor A_CULTIST_GIBBED
            }
            else ifaction AC_CULTIST_DYING
                action AC_CULTIST_GIBBED
        }
        break
    }
    getp .i cansee_target
    set cansee_height 9728
    state cansee_actor
    ife cansee_return_o 1
        state enemy_checkw1alt

    ife need_spot_sound -30
    {
        set enemy_dodge 90
        ife enemy_strafe 0
        {
            ifrnd 96
                state e_fp
            set enemy_strafe 1
            rand strafe_dir 1

            set e_lastsnd_temp 0
            whilen e_lastsnd_temp 1
            {
                rand temp 1
                ifactor A_SHOTGUNNER
                    add temp S_SHOTGUNNER_FEAR1
                else
                    add temp S_CULTIST_FEAR1
                ifn temp e_lesser_lastsnd
                    set e_lastsnd_temp 1
            }
            ife sound_enemy_buffer[temp] 0
            {
                ifpdistl ENEMY_SOUND_DIST
                    soundoncevar temp
                set e_lesser_lastsnd temp
            }
            setp .sound_pitch 0
        }
    }

    state pup_damage_adjust
    geta .htextra temp4
    set temp8 0
    ifg temp4 0
    {
        ifactor A_SHOTGUNNER ife gunner_type 1 ife sprite.htowner THISACTOR
        {
            shiftr temp4 2
            seta .htextra temp4
        }
        ife sprite.htpicnum BULLET ife sprite.htowner player.i
        {
            switch player.curr_weapon
                case WEAPON_SMG 
                    ifg p_pup_damage_time 0
                        clamp temp4 0 24
                    else
                        clamp temp4 0 12
                    seta .htextra temp4
                    break
                case WEAPON_MINIGUN
                    add enemy_minigun_dmg temp4
                    break
                case WEAPON_SHOTGUN
                    set temp8 1
                    break
                case WEAPON_LOVERBOY
                    ifn weapon1_alt 0
                    {
                        set temp2 temp4
                        shiftr temp2 3
                        add temp4 temp2
                        seta .htextra temp4
                    }
                    break
            endswitch
        }
        else ife sprite.htpicnum P_SMG2 ife sprite.htowner player.i
        {
            ifg p_pup_damage_time 0
                    clamp temp4 0 24
                else
                    clamp temp4 0 12
            seta .htextra temp4
        }
        else ifg sprite.extra 0
        {
            set temp5 enemy_minigun_dmg
            shiftr temp5 3
            sub enemy_minigun_dmg temp5
            clamp enemy_minigun_dmg 0 65536
        }
    }
    else ifg sprite.extra 0
    {
        set temp5 enemy_minigun_dmg
        shiftr temp5 3
        sub enemy_minigun_dmg temp5
        clamp enemy_minigun_dmg 0 65536
    }
    ifhitweapon
    {
        geta .owner temp5
        ifn temp5 -1 ifn temp5 THISACTOR ifn temp5 player.i
        {
            ife sprite[temp5].picnum A_SHOCKCANISTER_BROKE
                seta .htpicnum P_SHOCKER
            else ife sprite[temp5].picnum A_SHOCKCANISTER
                seta .htpicnum P_SHOCKER
        }

        ife cansee_return 0 ife enemy_dodge 0
        {
                set enemy_dodge 90
                ife enemy_strafe 0
                {
                    ifrnd 96
                        state e_fp
                    set enemy_strafe 1
                    rand strafe_dir 1
                }
        }
        geta .extra temp
        ifpdistl ENEMY_SOUND_DIST ifg temp 0
        {
            set temp2 temp4
            mul temp2 100
            div temp2 temp
            ifg temp2 50
            {
                set e_lastsnd_temp 0
                whilen e_lastsnd_temp 1
                {
                    randvar temp 3
                    add temp S_CULTIST_PAINBIG1
                    ifn temp e_lesser_lastsnd
                        set e_lastsnd_temp 1
                }
                ifactor A_SHOTGUNNER
                    setp .sound_pitch -222
                soundvar temp
                setp .sound_pitch 0
                set e_lesser_lastsnd temp
            }
            else
            {
                set e_lastsnd_temp 0
                whilen e_lastsnd_temp 1
                {
                    randvar temp 3
                    add temp S_CULTIST_PAIN1
                    ifn temp e_lesser_lastsnd
                        set e_lastsnd_temp 1
                }
                ifactor A_SHOTGUNNER
                    setp .sound_pitch -222
                soundvar temp
                setp .sound_pitch 0
                set e_lesser_lastsnd temp
            }
        }
        state spawn_blood

        cstat 257

        ifwasweapon P_PLASMA_BOLT
        {
            ifn sprite.htowner player.i
            {
                shiftr temp4 2
                geta .extra temp3
                sub temp3 temp4
                seta .extra temp3
            }
            geta .ang temp
            geta .htang temp2
            seta .ang temp2

            ifg sprite.extra 0
            {
                set move_v temp4
                state move_actor
                add enemy_xv move_xv
                add enemy_yv move_yv
            }
            seta .ang temp
        }
        ifwasweapon P_SHOCKER
        {
            add enemy_shocked 1
            ifg enemy_shocked 3
                set enemy_shocked 1
            set temp2 temp4
            mul temp2 enemy_shocked
            shiftr temp2 2
            geta .extra temp3
            sub temp3 temp2
            sub temp3 temp2
            seta .extra temp3
        }
        else
        {
            set temp3 temp4
            shiftl temp3 1
            set move_v temp3
            geta .ang temp3
            seta .ang sprite.htang
            state move_actor
            add enemy_xv move_xv
            add enemy_yv move_yv
            state enemy_do_move
            seta .ang temp3

        }
        set enemy_init 1
        sleeptime 300

        ifdead
        {
            state enemy_die_resolve
            ifn enemy_headsound 0
            {
                soundonce S_IMPACT_HEADSHOT
                or p_wantline TALK_KILL
                ifrnd 208
                {
                    state crackhead
                    set enemy_headache 1
                    ifrnd 96
                        state skull_gibs
                }
            }
            state enemy_confirm_bowled
            stopactorsound THISACTOR S_CULTIST_RECOG1
            stopactorsound THISACTOR S_CULTIST_RECOG2
            stopactorsound THISACTOR S_CULTIST_RECOG3
            stopactorsound THISACTOR S_CULTIST_ROAM1
            stopactorsound THISACTOR S_CULTIST_ROAM2
            stopactorsound THISACTOR S_CULTIST_ROAM3
            stopactorsound THISACTOR S_CULTIST_CHAT1
            stopactorsound THISACTOR S_CULTIST_CHAT2
            stopactorsound THISACTOR S_CULTIST_FIRE1
            stopactorsound THISACTOR S_CULTIST_FEAR1
            stopactorsound THISACTOR S_CULTIST_FEAR2
            stopactorsound THISACTOR S_CULTIST_HIT1
            stopactorsound THISACTOR S_CULTIST_HIT2
            stopactorsound THISACTOR S_SHOTGUN_RELOAD1
            stopactorsound THISACTOR S_SHOTGUN_RELOAD2
            stopactorsound THISACTOR S_AMB_NEONFLICKR01
            stopactorsound THISACTOR S_AMB_NEONFLICKR02
            stopactorsound THISACTOR S_SHOTGUNNER_RECOG1
            stopactorsound THISACTOR S_SHOTGUNNER_RECOG2
            stopactorsound THISACTOR S_SHOTGUNNER_RECOG3
            stopactorsound THISACTOR S_SHOTGUNNER_ROAM1
            stopactorsound THISACTOR S_SHOTGUNNER_ROAM2
            stopactorsound THISACTOR S_SHOTGUNNER_ROAM3
            stopactorsound THISACTOR S_SHOTGUNNER_CHAT1
            stopactorsound THISACTOR S_SHOTGUNNER_CHAT2
            stopactorsound THISACTOR S_SHOTGUNNER_FIRE1
            stopactorsound THISACTOR S_SHOTGUNNER_FEAR1
            stopactorsound THISACTOR S_SHOTGUNNER_FEAR2
            ifrnd 56
            {
                ifactor A_SHOTGUNNER
                {
                    ife gunner_type 1
                        espawn I_GRENADELAUNCHER_AMMO
                    else
                    {
                        ifrnd 128 espawn I_SHOTGUN
                        else espawn I_SHOTGUN_AMMO
                    }
                }
                else espawn I_LOVERBOY_AMMO2

                geta[RETURN].z temp
                sub temp 6144
                seta[RETURN].z temp
                rand temp 64
                add temp 64
                seta[RETURN].xvel temp
                rand temp -512
                sub temp 1024
                seta[RETURN].zvel temp
                geta .ang temp
                ifrnd 127
                    sub temp 256
                else
                    add temp 256
                and temp 2047
                seta[RETURN].ang temp
                ssp RETURN CLIPMASK0
            }


            set gib_temp 0
            ifwasweapon EXPLOSION
            {
                set temp3 enemy_spawn_health
                shiftr temp3 2
                add temp3 enemy_spawn_health
                ifg temp4 temp3
                    state generic_gibs
            }
            else ifwasweapon BULLET
            {
                set temp3 enemy_spawn_health

                mul temp3 3
                shiftr temp3 1
                set temp2 enemy_spawn_health
                shiftl temp2 1
                add temp3 temp2
                set temp2 enemy_spawn_health
                shiftr temp2 2
                add temp2 enemy_spawn_health
                shiftr temp2 1
                add temp3 temp2

                /* redefinequote 11 hit:%ld threshold:%ld
                qsprintf 11 11 temp4 temp3
                quote 11 */
                ife sprite.htowner player.i ife player.curr_weapon WEAPON_MINIGUN
                {
                    ifg enemy_minigun_dmg enemy_spawn_health
                        add temp4 temp3
                }
                ifg temp4 temp3
                    state generic_gibs
            }
          /*  redefinequote 11 %ld
            qsprintf 11 11 enemy_minigun_dmg
            quote 11 */

            action AC_CULTIST_DYING
            ifrnd 128 cstat 4
            else cstat 0

            ifn gib_temp 0
            {
                state dying_blood
                set enemy_gibbed 1
                or p_wantline TALK_GIB
                set p_face_grin 30
                shiftr temp4 4 // damage amount
                ifwasweapon EXPLOSION
                    nullop
                else ifg temp4 10
                    shiftr temp4 1

                clamp temp4 1 5

                for temp3 range temp4
                    state spawn_shard
            }
            else ife enemy_headsound 0
            {
                ife sprite.htowner player.i ife player.curr_weapon WEAPON_MINIGUN
                {
                    set e_lastsnd_temp 0
                    whilen e_lastsnd_temp 1
                    {
                        rand temp 2
                        add temp S_CULTIST_DEAD1
                        ifn temp e_lesser_lastsnd
                            set e_lastsnd_temp 1
                    }
                    ifactor A_SHOTGUNNER
                        setp .sound_pitch -222
                    ifpdistl ENEMY_SOUND_DIST
                        soundoncevar temp
                    setp .sound_pitch 0
                    set e_lesser_lastsnd temp
                }
                else ifrnd 48
                {
                    ifactor A_SHOTGUNNER
                    {
                        setp .sound_pitch -222
                        sound S_CULTIST_PAINHUGE
                        setp .sound_pitch 0
                    }
                    else
                        action AC_CULTIST_SUFFER
                }
                else
                {
                    set e_lastsnd_temp 0
                    whilen e_lastsnd_temp 1
                    {
                        rand temp 2
                        add temp S_CULTIST_DEAD1
                        ifn temp e_lesser_lastsnd
                            set e_lastsnd_temp 1
                    }
                    ifactor A_SHOTGUNNER
                        setp .sound_pitch -222
                    ifpdistl ENEMY_SOUND_DIST
                        soundoncevar temp
                    setp .sound_pitch 0
                    set e_lesser_lastsnd temp
                }
            }
            else ife enemy_headache 1
            {
                ifactor A_CULTIST
                    action AC_CULTIST_HEADACHE
                else
                    action AC_SHOTGUNNER_HEADACHE
            }
            break
        }
        else
        {
            ifn enemy_shocked 0
                action AC_CULTIST_SHOCKED
            else
            {
                set temp2 temp4
                shiftl temp2 2
                rand temp2 temp2

                ifg temp2 100
                {
                    action AC_CULTIST_HIT
                    set enemy_strafe 0
                    set enemy_start 0
                    set enemy_stop 1
                    ife need_spot_sound 1 ifrnd 96
                    {
                        set e_lastsnd_temp 0
                        whilen e_lastsnd_temp 1
                        {
                            rand temp 1
                            add temp S_CULTIST_HIT1
                            ifn temp e_lesser_lastsnd
                                set e_lastsnd_temp 1
                        }
                        ifpdistl ENEMY_SOUND_DIST
                            soundoncevar temp
                        set e_lesser_lastsnd temp
                    }
                }
            }
        }
        break
    }
    ifaction AC_CULTIST_HIT
    {
        set enemy_init 1
        {
            ifactioncount 5
            {
                ifrnd 128
                {
                    action AC_CULTIST_IDLE
                    set enemy_strafe 1
                    rand strafe_dir 1
                }
                else action AC_CULTIST_IDLE_CRC
            }
        }
        ifn enemy_shotgun_xv 0
            state enemy_do_move
        else ifn enemy_shotgun_yv 0
            state enemy_do_move
        break
    }
    else ifaction AC_CULTIST_SHOCKED
    {
        soundonce S_AMB_NEONFLICKR01
        soundonce S_AMB_NEONFLICKR02
        ifand sprite.htg_t 2 1
        {
            set enemy_skipshade 1
            seta .shade -127
        }
        ifn enemy_shocked 0
        {
            ife enemy_shocked 1
            {
                ifactioncount 10
                {
                    action AC_CULTIST_IDLE_CRC
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                    stopactorsound THISACTOR S_AMB_NEONFLICKR01
                    stopactorsound THISACTOR S_AMB_NEONFLICKR02
                }
            }
            else ife enemy_shocked 2
            {
                ifactioncount 20
                {
                    action AC_CULTIST_IDLE_CRC
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                    stopactorsound THISACTOR S_AMB_NEONFLICKR01
                    stopactorsound THISACTOR S_AMB_NEONFLICKR02
                }
            }
            else ife enemy_shocked 3
            {
                ife sprite.htg_t 2 1
                    state enemy_do_move
                ifactioncount 30
                {
                    action AC_CULTIST_IDLE_CRC
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                    stopactorsound THISACTOR S_AMB_NEONFLICKR01
                    stopactorsound THISACTOR S_AMB_NEONFLICKR02
                }
                else ifactioncount 2
                {
                    ifand sprite.htg_t 2 2
                    {
                        for temp6 sprofstat STAT_ACTOR
                        {
                            ifn temp6 THISACTOR
                            {
                                ifand tiledata[sprite[temp6].picnum].gameflags 32 ifg sprite[temp6].extra 0
                                {
                                    geta .z temp5
                                    sub temp5 8192
                                    seta .z temp5
                                    canseespr THISACTOR temp6 temp2
                                    add temp5 8192
                                    seta .z temp5
                                    ife temp2 1
                                    {
                                        dist temp2 THISACTOR temp6
                                        ifl temp2 1280
                                        {
                                            getav[temp6].enemy_shocked temp2
                                            ife temp2 2
                                            {

                                                geta .ang temp5
                                                set face_target temp6
                                                state face_actor
                                                seta .ang face_return
                                                espawn A_LIGHTNINGBALL
                                                ifrnd 127
                                                {
                                                    seta[RETURN].z sprite[temp6].z
                                                    seta[RETURN].y sprite[temp6].y
                                                    seta[RETURN].x sprite[temp6].x
                                                    seta[RETURN].sectnum sprite[temp6].sectnum
                                                }
                                                geta[RETURN].z temp2
                                                sub temp2 8192
                                                seta[RETURN].z temp2
                                                seta .ang temp5
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else ifactioncount 1
                {
                    for temp6 sprofstat STAT_ACTOR
                    {
                        ifn temp6 THISACTOR
                        {
                            ifand tiledata[sprite[temp6].picnum].gameflags 32 ifg sprite[temp6].extra 0
                            {
                                geta .z temp5
                                sub temp5 8192
                                seta .z temp5
                                canseespr THISACTOR temp6 temp2
                                add temp5 8192
                                seta .z temp5
                                ife temp2 1
                                {
                                    dist temp2 THISACTOR temp6
                                    ifl temp2 1280
                                    {
                                        geta .ang temp5
                                        set face_target temp6
                                        state face_actor
                                        seta .ang face_return
                                        espawn A_LIGHTNINGBALL
                                        ifrnd 127
                                        {
                                            seta[RETURN].z sprite[temp6].z
                                            seta[RETURN].y sprite[temp6].y
                                            seta[RETURN].x sprite[temp6].x
                                            seta[RETURN].sectnum sprite[temp6].sectnum
                                        }
                                        geta[RETURN].z temp2
                                        sub temp2 8192
                                        seta[RETURN].z temp2
                                        seta .ang temp5
                                        geta[temp6].htextra temp2
                                        add temp2 WEAPON0_DMG
                                        seta[temp6].htextra temp2
                                        setav[temp6].enemy_shocked 2
                                        setav[temp6].enemy_init 1
                                    }
                                }
                            }
                        }
                    }
                    for itervar range num_flag32
                    {
                        set temp6 gameflag32[itervar]
                        ifn temp6 THISACTOR
                        {
                            ifg sprite[temp6].extra 0
                            {
                                geta .z temp5
                                sub temp5 8192
                                seta .z temp5
                                canseespr THISACTOR temp6 temp2
                                add temp5 8192
                                seta .z temp5
                                ife temp2 1
                                {
                                    dist temp2 THISACTOR temp6
                                    ifl temp2 1280
                                    {
                                        geta[temp6].htextra temp2
                                        add temp2 WEAPON0_DMG
                                        seta[temp6].htextra temp2
                                        setav[temp6].enemy_shocked 2
                                        setav[temp6].enemy_init 1
                                        changespritestat temp6 STAT_ACTOR
                                    }
                                }
                            }
                        }
                    }
                }

            }
        }
        else
            action AC_CULTIST_HIT
        break
    }
    
    cstat 257
    ife enemy_init 0
    {
        getp .i att_target
        state angle_to_target
        ldist temp THISACTOR player.i
        set temp2 att_return
        div temp2 36
        ife temp2 0
            set temp2 1
        else
        {
            shiftr temp2 2
            mul temp2 3
            ife temp2 0
                set temp2 1
        }
        set temp3 CULTIST_CONE
        div temp3 temp2
        set temp4 0
        ife cansee_return 1
            set temp4 1
        else ifn hitwall -1
        {
            set surface_type wall[hitwall].picnum
            state get_surface_type

            set temp5 0
            ifand wall[hitwall].cstat 16
                set temp5 1
            ifand wall[hitwall].cstat 32
                set temp5 1
            ife temp5 1 // if this wall has a maskwall
            {
                // this trick lets us determine if we're in between the ceiling and floor
                // and should be in the masked area
                getw[hitwall].nextsector temp5
                ifn temp5 -1
                {
                    ifl hitz sector[temp5].floorz ifg sprite.z sector[temp5].ceilingz
                    {
                        getw[hitwall].nextwall temp5
                        getw[temp5].overpicnum surface_type // get the masked texture if so
                        state get_surface_type
                    }
                }
            }
            ife surface_type SURFACE_GLASS ifl wall[hitwall].shade 7 ifn wall[hitwall].blend 130
            {
                ifand wall[hitwall].cstat 128
                {
                    ifand wall[hitwall].cstat 16
                    {
                        state enemy_hitscan_glass
                        ife e_glass_hitscan_return 1
                            set temp4 1
                    }
                    ifand wall[hitwall].cstat 32
                    {
                        state enemy_hitscan_glass
                        ife e_glass_hitscan_return 1
                            set temp4 1
                    }
                }
            }
        }
        ife temp4 1
        {
            ifl temp temp3
                set enemy_init 1
            else ifl sprite.extra enemy_spawn_health
                set enemy_init 1
            else ifl att_return 448
                set enemy_init 1
            else
            {
                state enemy_do_move
                break
            }
        }
        else
        {
            state enemy_do_move
            break
        }
    }

    set enemy_faceplayerslow 1
    ife enemy_faceplayerslow 1 ife enemy_strafe 0 ife enemy_shoot 0
        state e_fp

    ifpdistl CULTIST_SLOW
    {
        ifpdistl CULTIST_STOP
        {
            ifrnd 32 ife enemy_stop 0 ife enemy_shoot 0 ife se_hitag 0
                set enemy_stop 1
            ifmove AM_ENEMY_SEARCH
                move AM_ENEMY_SEARCH_STOP
        }
        else
        {
            ifrnd 32 ife enemy_start 0 ife enemy_shoot 0
            {
                set enemy_start 1
            }
        }
    }
    else ifrnd 111 ife enemy_start 0 ife enemy_shoot 0
        set enemy_start 1

    ifrnd 64 ife enemy_strafe 0 ife enemy_shoot 0 ife se_hitag 0 // ife enemy_start 0
    {
        set enemy_strafe 1
        rand strafe_dir 1
        ife need_spot_sound 1 ifrnd 16
        {
            state spawn_sound_emitter
            rand temp 2
            ifactor A_SHOTGUNNER
                add temp S_SHOTGUNNER_CHAT1
            else
                add temp S_CULTIST_CHAT1
            ifn temp e_lesser_lastsnd ife sound_enemy_buffer[temp] 0
            {
                ifpdistl ENEMY_SOUND_DIST
                    soundoncevar temp
                set e_lesser_lastsnd temp
            }
            set need_spot_sound 30
        }
    }

    getp .i att_target
    state angle_to_target

    ifg need_spot_sound 1
        sub need_spot_sound 1
    else ifl need_spot_sound 1
        add need_spot_sound 1

    set temp4 0
    ife cansee_return 1
        set temp4 1
    else ife cansee_return_o 1
        set temp4 1

    ife temp4 1 ife need_spot_sound 0
    {
        rand temp 2
        ifactor A_SHOTGUNNER
            add temp S_SHOTGUNNER_RECOG1
        else
            add temp S_CULTIST_RECOG1
        ifn temp e_lesser_lastsnd ife sound_enemy_buffer[temp] 0
        {
            ifpdistl ENEMY_SOUND_DIST
                soundoncevar temp
            set e_lesser_lastsnd temp
        }
        set need_spot_sound 30
        set was_lost_sound 0
    }
    
    ifn way_current -1
    {
        ifl counter3 15
            add counter3 1
    }
    else ifg counter3 0
    {
        sub counter3 2
        clamp counter3 0 15
    }
    ifn temp4 1 ife se_hitag 0
    {
        ifrnd 96 ife enemy_strafe 0
        {
            state e_fp
            set enemy_strafe 1
            rand strafe_dir 1
        }

    }
    else ife enemy_shoot 0 ife se_hitag 0
    {
        ife cansee_return 1 ifl counter3 10
        {
            rand temp 255
            ifactor A_SHOTGUNNER
            {
                ife gunner_type 1
                    set temp2 SHOTGUNNER_ALT_ATTK_FREQ
                else
                    set temp2 SHOTGUNNER_ATTK_FREQ
                ifge enemy_lastshot 90
                    shiftl temp2 1
            }
            else
                set temp2 CULTIST_ATTK_FREQ
                
            getu .player_skill temp4    
            mul temp2 temp4
            shiftr temp2 1
            
            ifg temp2 17408 set temp2 17408
                
            ifle temp temp2
                ife shot_delay 0
                    ifl att_return 128
                    {
                        ifactor A_SHOTGUNNER ife gunner_type 1
                        {
                            getu .player_skill temp4    
                            mul temp4 SHOTGUNNER_ALT_ATTK
                            shiftr temp4 1
                            ifn sprite.htactorstayput -1
                            {
                                mul temp4 3
                                shiftr temp4 1
                            }
                            ifl userdef.vm_distance temp4
                            {
                                ldist temp THISACTOR player.i
                                set temp2 sprite[player.i].z
                                sub temp2 sprite.z
                                shiftr temp2 3
                                add temp temp2
                                ifg temp 0
                                {
                                    state grenade_drop_aim
                                    set enemy_shoot 1
                                }
                            }
                        }
                        else ifactor A_SHOTGUNNER
                        {
                            getu .player_skill temp4
                            mul temp4 SHOTGUNNER_ATTK
                            shiftr temp4 1
                            ifn sprite.htactorstayput -1
                            {
                                mul temp4 3
                                shiftr temp4 1
                            }
                            ifl userdef.vm_distance temp4
                                set enemy_shoot 1
                        }
                        else
                        {
                            getu .player_skill temp4
                            mul temp4 CULTIST_ATTK
                            shiftr temp4 1
                            ifn sprite.htactorstayput -1
                            {
                                mul temp4 3
                                shiftr temp4 1
                            }
                        
                            ifl userdef.vm_distance temp4
                                set enemy_shoot 1
                        }
                    }
        }
        ife enemy_shoot 0 ife cansee_return_o 1
        {
            ife enemy_strafe 0
            {
                ifrnd 64
                {
                    ifl att_return 128
                    {
                        ifpdistl CULTIST_STRF
                        {
                            state e_fp
                            set enemy_strafe 1
                            rand strafe_dir 1
                        }
                    }
                }
                else
                {
                    ifrnd 64
                    {
                        ifpdistl CULTIST_DODG
                        {
                            ifp pfacing
                            {
                                ifrnd CULTIST_DODG_FREQ
                                    state e_fp
                                set enemy_strafe 1
                                rand strafe_dir 1
                            }
                        }
                    }
                }
            }
        }
    }

    ifpdistl 800 ife cansee_return 1
    {
        ife enemy_stop 0 ife se_hitag 0
            set enemy_stop 8
    }
    ifrnd 4
    {   ife enemy_stop 0 ife enemy_shoot 0 ife se_hitag 0
            set enemy_stop 1
    }
    ifn enemy_start 0 ife enemy_stop 0
    {
        set move_v enemy_start
        ifactor A_SHOTGUNNER
            add move_v 2
        ifn way_current -1
            shiftl move_v 4
        else
            shiftl move_v 4
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        add enemy_start 1
        ifg enemy_start 8
            set enemy_start 8

        set enemy_stop 0
        ifg enemy_strafe 0
            sub enemy_strafe 1
        else
        {
            set enemy_roamang -1
            set enemy_strafe_mod 0
        }
    }
    
    ife shot_delay 58
        ifn enemy_strafe 0
            set enemy_strafe 0
    ifn enemy_strafe 0 ife enemy_stop 0
    {
        ifnotmoving
        {
            ifn enemy_roamang -1
            {
               set enemy_roamang -1
               state e_fp
            }
        }
        geta .ang temp
        ife enemy_roamang -1
        {
            set temp2 temp // save for later
            add temp 512
            ife strafe_dir 1
                add temp 1024
            and temp 2047
        }
        else
            set temp enemy_roamang
        seta .ang temp

        ifl reverse_dir 10
        {
            ife enemy_strafe 1
            {
                ife enemy_roamang -1
                {
                    getu .player_skill temp3
                    ifactor A_SHOTGUNNER
                    {
                        ifrnd 16
                            set enemy_roamang temp
                    }
                    else
                    {
                        ifrnd 32
                            set enemy_roamang temp
                    }
                }
                ifrnd 127
                    set enemy_strafe_mod 1
            }
        }
        else
            set enemy_roamang -1
        set move_v enemy_strafe
        ifactor A_SHOTGUNNER
        {
            set enemy_strafe_mod 1
            add move_v 3
            ifn enemy_dodge 0
                add move_v 3
        }
        ifn enemy_roamang -1
            add move_v 8
        else ife enemy_strafe_mod 1
            add move_v 4
        clamp move_v 0 24
        ifn way_current -1
            mul move_v 6
        else
            mul move_v 10
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ife enemy_roamang -1
            seta .ang temp2

        add enemy_strafe 1
        ifg enemy_strafe 8
            set enemy_strafe 8

        set enemy_stop 0
        ifg enemy_start 0 ifg enemy_strafe 3
            sub enemy_start 1
        ifactor A_SHOTGUNNER
        {
            ifn enemy_shoot 1
                set enemy_shoot 0
        }
        else ifrnd 16
            set enemy_shoot 0
        state e_fp
        ifn enemy_roamang -1
            seta .ang enemy_roamang
    }
    else ifactor A_SHOTGUNNER ifn enemy_dodge 0 ife enemy_start 0
    {
        set enemy_start 1
        set enemy_stop 0
    }
    ifn enemy_stop 0
    {
        // ifrnd 
            state e_fp
        shiftr enemy_xv 1
        shiftr enemy_yv 1
        add enemy_stop 1
        ifn enemy_start 0
            sub enemy_start 1
        ifn enemy_strafe 0
            sub enemy_strafe 1
        ifg enemy_stop 8
        {
            set enemy_xv 0
            set enemy_yv 0
            set enemy_stop 0
            set enemy_start 0
            set enemy_strafe 0
        }
    }
    ifn enemy_shoot 0
    {
        set enemy_lastshot 0
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        shiftr enemy_xv 4
        shiftr enemy_yv 4
        add enemy_shoot 1
        ifn enemy_start 0
            sub enemy_start 1
        ifn enemy_stop 0
            sub enemy_stop 1
        ifn enemy_strafe 0
            sub enemy_strafe 1
//        ifl enemy_shoot 8
            
        ifg enemy_shoot 59
        {
            set enemy_xv 0
            set enemy_yv 0
            set enemy_stop 0
            set enemy_shoot 0
            set enemy_start 0
            set enemy_strafe 0
        }
        ife shot_delay 58
        {
            rand temp 1
            add temp S_SHOTGUN_RELOAD1
            setp .sound_pitch -512
            ifpdistl ENEMY_SOUND_DIST
            {
                ifactor A_SHOTGUNNER
                {
                    ife gunner_type 1
                    {
                        soundvar temp
                        setp .sound_pitch -128
                        sound S_SHOTGUN_CLIPOUT
                    }
                    else
                    {
                        setp .sound_pitch -128
                        soundvar temp
                        setp .sound_pitch 512
                        sound S_SHOTGUN_OPENCLOSE
                    }
                }
                else
                    soundvar temp
            }
            setp .sound_pitch 0
        }
    }
    else   
    {
        ifg shot_delay 50
        {
            stopactorsound THISACTOR S_SHOTGUN_RELOAD1
            stopactorsound THISACTOR S_SHOTGUN_RELOAD2
        }
        ifactor A_SHOTGUNNER
            add enemy_lastshot 1
    }
    ifn enemy_shoot 0
    {
        getu .player_skill temp
        mul temp 10
        ifl shot_delay temp
        {
            ifg userdef.player_skill 2
                state e_fp
            else state e_fps
            geta .ang enemy_lockang
        }
        
        set temp 0

        ifaction AC_CULTIST_SHOOT_CRC
            set temp 1
        else ifaction AC_CULTIST_SHOOT
            set temp 1

        ife temp 1
        {
            ifg shot_delay 50
            {
                ifn enemy_dodge 0
                    action AC_CULTIST_SHOOT_CRC
                else
                {
                    ifaction AC_CULTIST_SHOOT_CRC
                        action AC_CULTIST_SHOOT_CRC
                    else
                        action AC_CULTIST_SHOOT
                }
            }
            else ife shot_delay 50
            {
                ifrnd 2 ifaction AC_CULTIST_SHOOT_CRC
                    action AC_CULTIST_SHOOT
                else ifrnd 2 ifaction AC_CULTIST_SHOOT
                    action AC_CULTIST_SHOOT_CRC
            }
            //seta .ang enemy_lockang

            ifactor A_SHOTGUNNER
            {
                switch shot_delay
                    case 50
                    case 49
                    case 48
                        seta .shade -127
                        set enemy_skipshade 1
                        break
                endswitch
                ife shot_delay 49
                {
                    ifaction AC_CULTIST_SHOOT_CRC
                    {
                        geta .z temp6
                        add temp6 3072
                        seta .z temp6
                    }
                    geta .z temp6
                    sub temp6 1536

                    seta .z temp6
                    geta .x temp6
                    geta .y temp7
                    geta .ang temp3
                    sub temp3 128
                    and temp3 2047
                    cos temp temp3
                    sin temp2 temp3
                    shiftr temp 7
                    shiftr temp2 7
                    add temp temp6
                    add temp2 temp7
                    seta .x temp
                    seta .y temp2

                    ife gunner_type 1
                    {
                        getprojectile[P_GRENADE].extra temp8
                        getprojectile[P_GRENADE].extra_rand temp9
                        
                        getprojectile[P_GRENADE].extra temp4
                        getu .player_skill temp3
                        sub temp3 4
                        clamp temp3 -4 -1
                        inv temp3
                        div temp4 temp3
                        ifg userdef.player_skill 2
                            shiftr temp4 1
                        else ife userdef.player_skill 1
                            shiftl temp4 1
                        setprojectile[P_GRENADE].extra temp4
                        getprojectile[P_GRENADE].extra_rand temp4
                        div temp4 temp3
                        set temp3 temp4
                        shiftr temp3 2
                        sub temp4 temp3
                        setprojectile[P_GRENADE].extra_rand temp4
                        
                        getprojectile[P_GRENADE].workslike temp4
                        or temp4 4096
                        setprojectile[P_GRENADE].workslike temp4
                        zshoot enemy_horiz P_GRENADE
                        xor temp4 4096
                        setprojectile[P_GRENADE].workslike temp4
                        setprojectile[P_GRENADE].extra temp8
                        setprojectile[P_GRENADE].extra_rand temp9
                    }
                    else
                    {
                        eshoot P_SHOTGUN
                        eshoot P_SHOTGUN
                        eshoot P_SHOTGUN
                        eshoot P_SHOTGUN
                        eshoot P_SHOTGUN
                        eshoot P_SHOTGUN
                        eshoot P_SHOTGUN
                    }

                    seta .x temp6
                    seta .y temp7

                    geta .z temp6
                    add temp6 1536
                    seta .z temp6

                    ife gunner_type 1
                    {
                        ifpdistl ENEMY_SOUND_DIST
                            sound S_MECH_GRENADE
                    }
                    else
                    {
                        getp .sound_pitch temp
                        randvar temp3 64
                        add temp3 512
                        add temp temp3
                        setp .sound_pitch temp
                        rand temp2 1
                        add temp2 S_SHOTGUN_FIRE1
                        ifpdistl ENEMY_SOUND_DIST
                            soundvar temp2
                        sub temp temp3
                        setp .sound_pitch temp
                    }
                    ifaction AC_CULTIST_SHOOT_CRC
                    {
                        sub temp6 3072
                        seta .z temp6
                    }
                    state spawn_sound_emitter

                    seta .shade -127
                    set enemy_skipshade 1

                    seta .ang enemy_lockang
                }
                else ifl shot_delay 48
                {
                    ifaction AC_CULTIST_SHOOT
                        action AC_CULTIST_SHOOT
                    else ifaction AC_CULTIST_SHOOT_CRC
                        action AC_CULTIST_SHOOT_CRC
                    ifl shot_delay 40
                    {
                        ifaction AC_CULTIST_SHOOT_CRC
                        {
                            ifrnd 127
                                set enemy_dodge 30
                        }
                        else ifrnd 64
                        {
                            set enemy_dodge 30
                            action AC_CULTIST_IDLE
                        }
                        set enemy_shoot 0
                        set shot_delay 30
                        ifrnd 64
                            set enemy_start 1
                        else
                            set enemy_strafe 1
                    }
                    seta .ang enemy_lockang
                }
            }
            else
            {
                switch shot_delay
                    case 50
                    case 48
                    case 46
                    case 44
                    case 42
                    case 40
                        seta .shade -127
                        set enemy_skipshade 1
                        break
                    case 49
                    case 45
                    case 41
                        ifaction AC_CULTIST_SHOOT_CRC
                        {
                            geta .z temp6
                            add temp6 2048
                            seta .z temp6
                        }
                        else
                        {
                            geta .z temp6
                            sub temp6 512
                            seta .z temp6
                        }

                        ifn shot_delay 45
                        {
                            ifg framerate 30
                            {
                                eshoot A_SHELL1
                                ifpdistl 8192
                                {
                                    ife shot_delay 41
                                        setav[RETURN].se_zvel 32767
                                }
                                else
                                    setav[RETURN].se_zvel 32767

                            }
                        }

                        setprojectile[P_LOVERBOY].extra 3
                        getu .vm_distance temp
                        add temp 256
                        shiftr temp 7
                        clamp temp 16 32
                        setprojectile[P_LOVERBOY].tnum temp
                        set temp2 0
                        ife shot_delay 49
                            set temp2 1
                        getu .player_skill temp
                        ifge temp 3
                        {
                            ife shot_delay 41
                                set temp2 1
                            else ifg temp 3
                                set temp2 1
                        }
                        ife temp2 1
                        {
                            setprojectile[P_LOVERBOY].workslike 1179649
                            ifl userdef.player_skill 4
                            {
                                set temp5 WEAPON1_DMG
                                shiftr temp5 1
                                setprojectile[P_LOVERBOY].extra_rand temp5
                            }
                        }
                        geta .x temp5
                        geta .y temp7
                        ifpdistl 800
                            nullop
                        else
                        {
                            geta .ang temp3
                            sub temp3 512
                            and temp3 2047
                            cos temp temp3
                            sin temp2 temp3
                            shiftr temp 9
                            shiftr temp2 9
                            add temp temp5
                            add temp2 temp7
                            seta .x temp
                            seta .y temp2
                        }
                        eshoot P_LOVERBOY
                        seta .x temp5
                        seta .y temp7
                        setprojectile[P_LOVERBOY].extra WEAPON1_DMG
                        setprojectile[P_LOVERBOY].extra_rand WEAPON1_DMG
                        setprojectile[P_LOVERBOY].workslike 1
                        setprojectile[P_LOVERBOY].tnum 32
                        getp .sound_pitch temp
                        randvar temp3 64
                        add temp3 512
                        add temp temp3
                        setp .sound_pitch temp

                        set temp2 shot_delay
                        mod temp2 3
                        add temp2 S_TRIFIRE_OLD1
                        ifpdistl ENEMY_SOUND_DIST
                            soundvar temp2

                        sub temp temp3
                        setp .sound_pitch temp
                        seta .shade -127
                        set enemy_skipshade 1
                        ifaction AC_CULTIST_SHOOT_CRC
                        {
                            sub temp6 2048
                            seta .z temp6
                        }
                        else
                        {
                            add temp6 512
                            seta .z temp6
                        }
                        ife shot_delay 49
                            state spawn_sound_emitter

                        break
                endswitch
            }

            ifactioncount 24
            {
                action AC_CULTIST_IDLE
                set enemy_shoot 0
            }
            else ifactioncount 12
            {
                ifaction AC_CULTIST_SHOOT_CRC
                    action AC_CULTIST_IDLE_CRC
                else action AC_CULTIST_IDLE
                set enemy_shoot 0
            }
        }
        else ife shot_delay 0
        {
            set enemy_shoot 1
            ifn enemy_dodge 0
                action AC_CULTIST_SHOOT_CRC
            else
            {
                ifaction AC_CULTIST_SHOOT_CRC
                    nullop
                else ifaction AC_CULTIST_IDLE_CRC
                    action AC_CULTIST_SHOOT_CRC
                else ifrnd 64
                    action AC_CULTIST_SHOOT_CRC
                else
                    action AC_CULTIST_SHOOT
            }
            state e_fp

            set shot_delay 60
            geta .ang enemy_lockang

            rand temp2 255
            getu .player_skill temp
            ifge temp 3
                set temp2 0
            ifle temp2 127
            {
                set temp2 player.posxv
                set temp3 player.posyv
                
                ifl userdef.player_skill 4
                {
                    shiftr temp2 14
                    rand temp temp2
                    add temp2 temp
                }
                else
                    shiftr temp2 12
                
                ifl userdef.player_skill 4
                {
                    shiftr temp3 14
                    rand temp temp3
                    add temp3 temp
                }
                else
                    shiftr temp3 12
                add temp2 player.posx
                add temp3 player.posy

                sub temp2 sprite.x
                sub temp3 sprite.y

                getangle enemy_lockang temp2 temp3
            }
            ife need_spot_sound 1 ifrnd 32
            {
                ifactor A_SHOTGUNNER
                    set temp S_SHOTGUNNER_FIRE1
                else
                    set temp S_CULTIST_FIRE1
                ifn temp e_lesser_lastsnd ife sound_enemy_buffer[temp] 0
                {
                    ifpdistl ENEMY_SOUND_DIST
                        soundoncevar temp
                    set e_lesser_lastsnd temp
                }
                set need_spot_sound 30
            }
        }
    }
    else ifn enemy_dodge 0
    {
        ifaction AC_CULTIST_DODGE
            nullop
        else
            action AC_CULTIST_DODGE
        sub enemy_dodge 1
    }
    else ifn enemy_strafe 0
    {
        ifaction AC_CULTIST_STRAFE
            nullop
        else
            action AC_CULTIST_STRAFE
    }
    else ifn enemy_start 0
    {
        ifaction AC_CULTIST_WALK
            nullop
        else
            action AC_CULTIST_WALK
    }
    else ifg enemy_stop 2
    {
        ifaction AC_CULTIST_IDLE
            nullop
        else ifaction AC_CULTIST_IDLE_CRC
            nullop
        else action AC_CULTIST_IDLE
    }

    ifn way_current -1
        set reverse_dir 0
    ifn reverse_dir 0
    {
        inv enemy_xv
        inv enemy_yv
        shiftr enemy_xv 1
        shiftr enemy_yv 1
        sub reverse_dir 1
        ifrnd 96
        {
            ife enemy_shoot 0
            {
                ife enemy_strafe 0
                {
                    state e_fp
                    set enemy_strafe 6
                    rand strafe_dir 1
                    set reverse_dir 0
                }
                else
                {
                    ifl enemy_start 6
                        set enemy_start 8
                    set reverse_dir 0
                }
            }
        }
    }
    set temp7 0
    geta .x temp8
    geta .y temp9
    state enemy_do_move
    sub temp8 sprite.x
    sub temp9 sprite.y
    abs temp8
    abs temp9
    ife se_hitag 0
    {
        add temp8 temp9
        ifg temp8 10
            set temp7 1
        ife temp7 0
        {
            ifl counter2 10
                add counter2 1
        }
        else
            ifl counter2 10
                ifg counter2 0
                    sub counter2 1
        ifge counter2 10
        {
            ife sprite.htactorstayput sprite.sectnum
            {       
                
                set enemy_xv 0
                set enemy_yv 0
                set enemy_start 0
                set enemy_strafe 0
                set enemy_dodge 0
                set enemy_roamang -1
                set reverse_dir 0
                ife enemy_stop 0
                    set enemy_stop 7
                ifaction AC_CULTIST_WALK
                {
                    action AC_CULTIST_IDLE
                    ife counter2 39
                    {
                        rand temp7 2047
                        seta .ang temp7
                    }
                }
                ifaction AC_CULTIST_STRAFE
                    action AC_CULTIST_IDLE
                ifaction AC_CULTIST_DODGE
                    action AC_CULTIST_IDLE
            }
            add counter2 1
            ifg counter2 40
                set counter2 0
        }
    }
ends
useractor enemy A_CULTIST CULTIST_HEALTH AC_CULTIST_IDLE
    state lesser_shotgun_shared
enda

useractor enemy A_SHOTGUNNER SHOTGUNNER_HEALTH AC_CULTIST_IDLE
    state lesser_shotgun_shared
enda

action AC_GREATER_IDLE     64 1 5 1 1
action AC_GREATER_WALK     0 4 5 1 16
action AC_GREATER_STRAFE   0 4 5 1 16
action AC_GREATER_DODGE    32 4 5 1 16
action AC_GREATER_CHARGE   64 2 5 1 1
action AC_GREATER_SHOOT    64 3 5 1 28
action AC_GREATER_CHARGE_CRC   96 2 5 1 1
action AC_GREATER_SHOOT_CRC    96 3 5 1 28
action AC_GREATER_HIT      132 1 1 1 1
action AC_GREATER_SHOCKED  152 2 5 1 1
action AC_GREATER_DYING    132 7 1 1 8
action AC_GREATER_DEAD     138 1 1 1 4
action AC_GREATER_DYING2   142 8 1 1 8
action AC_GREATER_DEAD2    149 1 1 1 4
action AC_GREATER_GIBBED   163 8 1 1 8
action AC_GREATER_HEADACHE 172 8 1 1 8
spriteshadow A_GREATER
spriteshadow A_GREATER_DEAD1
spriteshadow A_GREATER_DEAD2
spriteshadow A_GREATER_GIBBED
/* spriteflags A_GREATER 33554432 */
var greater_discharge 0 2

defstate greater_plasma_bolt
    and temp 2047
    eshoot P_PLASMA_BOLT
    seta[RETURN].ang temp
    seta[RETURN].zvel temp2
    getthisprojectile[RETURN].workslike temp3
    orvar temp3 4096
    setthisprojectile[RETURN].workslike temp3
    setthisprojectile[RETURN].extra 2
    seta[RETURN].extra 2
ends
useractor notenemy A_GREATER_GIBBED 0 AC_BASE
    ifand sprite.cstat 4
        cstat 4
    else
        cstat 0
    fall
    set actor_gib 2
    changespritestat THISACTOR STAT_STATIC_GIB
enda
useractor notenemy A_GREATER_DEAD1 CORPSE_HEALTH
    state enemy_body_code
enda
useractor notenemy A_GREATER_DEAD2 CORPSE_HEALTH
    state enemy_body_code
enda

useractor enemy A_GREATER_STAYPUT GREATER_HEALTH AC_GREATER_IDLE
    fall
    action AC_GREATER_IDLE
    cactor A_GREATER
enda
action AC_GREATER_CRC 0 1 5 1 1 1
useractor enemy A_GREATER_CROUCH CULTIST_HEALTH AC_GREATER_CRC
    fall
    action AC_GREATER_CHARGE_CRC
    set enemy_shoot 1
    set enemy_dodge 300
    cactor A_GREATER
enda

useractor enemy A_GREATER GREATER_HEALTH AC_GREATER_IDLE
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break
    state e_wakemeup
    ifpdistl 8192
    {
        ifaction AC_GREATER_WALK
        {
            add enemy_stepcounter 1
            ifg enemy_stepcounter 12
            {
                gets .floorpicnum surface_type
                geta .xvel p_xvel
                ifg p_xvel 96
                    set p_steptype 1
                setp .sound_pitch -512
                iffloordistl 1
                    state player_footstep
                setp .sound_pitch 0
                set enemy_stepcounter 0
            }
        }
        else ifaction AC_GREATER_STRAFE
        {
            add enemy_stepcounter 1
            ifg enemy_stepcounter 8
            {
                gets .floorpicnum surface_type
                geta .xvel p_xvel
                ifg p_xvel 96
                    set p_steptype 1
                setp .sound_pitch -512
                iffloordistl 1
                    state player_footstep
                setp .sound_pitch 0
                set enemy_stepcounter 0
            }
        }
        else ifaction AC_GREATER_DODGE
        {
            add enemy_stepcounter 1
            ifg enemy_stepcounter 8
            {
                gets .floorpicnum surface_type
                geta .xvel p_xvel
                ifg p_xvel 96
                    set p_steptype 1
                setp .sound_pitch -512
                iffloordistl 1
                    state player_footstep
                setp .sound_pitch 0
                set enemy_stepcounter 0
            }
        }
        else
            set enemy_stepcounter 0
    }
    else
        set enemy_stepcounter 0

    state enemy_do_target_icon
    
    fall
    ifg shot_delay 0
        sub shot_delay 1
    clipdist 32
    state smg_flamechance
    ifdead
    {
        state enemy_die_friction
        geta .htextra temp6
        set enemy_init 1
        ifaction AC_GREATER_DYING
        {
            seta .ang sprite.htang
            set move_v temp6
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            ifactioncount 4
                nullop
            else
            {
                shiftr move_v 4
                inv move_v
            }
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move

            state enemy_clearw1alt
            cstat 0
            ifactioncount 7
            {
                action AC_GREATER_DEAD
                cstat 0
                ifn enemy_gibbed 1
                {
                    strength CORPSE_HEALTH
                    action AC_ENEMY_BODY
                    state enemy_die_cleartags
                    cactor A_GREATER_DEAD1
                    set p_steptype 3
                    state player_footstep
                }
            }
            state dying_blood
            ifactioncount 2
                nullop
            else
                stopactorsound THISACTOR S_CROSSBOW_CHARGE

        }
        else ifaction AC_GREATER_DYING2
        {

            seta .ang sprite.htang
            set move_v temp6
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            shiftr move_v 3
            inv move_v
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move

            state enemy_clearw1alt
            cstat 0
            ifactioncount 8
            {
                state spawn_sound_emitter
                action AC_GREATER_DEAD2
                cstat 0
                ifn enemy_gibbed 1
                {
                    strength CORPSE_HEALTH
                    action AC_ENEMY_BODY
                    state enemy_die_cleartags
                    cactor A_GREATER_DEAD2
                    set p_steptype 3
                    state player_footstep
                }
            }
            state dying_blood
            ifactioncount 2
                nullop
            else
                stopactorsound THISACTOR S_CROSSBOW_CHARGE
        }
        else ifaction AC_GREATER_HEADACHE
        {

            seta .ang sprite.htang
            set move_v temp6
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            shiftr move_v 3
            inv move_v
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move

            state enemy_clearw1alt
            cstat 0
            ifactioncount 8
            {
                state spawn_sound_emitter
                action AC_GREATER_DEAD2
                cstat 0
                ifn enemy_gibbed 1
                {
                    strength CORPSE_HEALTH
                    action AC_ENEMY_BODY
                    state enemy_die_cleartags
                    cactor A_GREATER_DEAD2
                    set p_steptype 3
                    state player_footstep
                }
            }
            state dying_blood
            ifactioncount 2
                nullop
            else
                stopactorsound THISACTOR S_CROSSBOW_CHARGE
        }
        else ifaction AC_GREATER_GIBBED
        {
            seta .ang sprite.htang
            set move_v temp6
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            ifactioncount 4
                nullop
            else
            {
                shiftr move_v 4
                inv move_v
            }
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move

            state enemy_clearw1alt
            cstat 0
            ifactioncount 8
            {
                state spawn_sound_emitter
                action AC_GREATER_DEAD
            }
            state dying_blood
            ifactioncount 2
                nullop
            else
                stopsound S_CROSSBOW_CHARGE

        }
        ifn enemy_gibbed 0
        {
            ifaction AC_GREATER_DEAD
            {
                action AC_BASE
                state enemy_die_cleartags
                cactor A_GREATER_GIBBED
            }
            else ifaction AC_GREATER_DEAD2
            {
                action AC_BASE
                state enemy_die_cleartags
                cactor A_GREATER_GIBBED
            }
            else ifaction AC_GREATER_GIBBED
                nullop
            else
                action AC_GREATER_GIBBED
        }
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        break
    }
    getp .i cansee_target
    set cansee_height 9728
    state cansee_actor
    ife cansee_return_o 1
        state enemy_checkw1alt
    state pup_damage_adjust
    geta .htextra temp
    ifg temp 0
    {
        shiftr temp 2
        add enemy_annoyance temp
    }
   /* redefinequote 11 %ld
    qsprintf 11 11 enemy_annoyance
    quote 11 */
    geta .htextra temp6
    ife sprite.htowner player.i ifg temp6 0
    {
        ife sprite.htpicnum BULLET
        {
            ife player.curr_weapon 2
            {
                set temp2 temp6
                ifg temp2 90
                    sub temp2 45
                /* // clamp temp2 1 400
                redefinequote 11 %ld
            qsprintf 11 11 temp2
            quote 11 */
                seta .htextra temp2
            }
            else ife player.curr_weapon 3
            {
                ifg p_pup_damage_time 0
                    clamp temp6 0 36
                else
                    clamp temp6 0 18
                seta .htextra temp6
            }
            else ife player.curr_weapon 1 ifn weapon1_alt 0
            {
                set temp2 temp6
                shiftl temp2 1
                // addlogvar temp2
                /* // clamp temp2 1 400
                redefinequote 11 %ld
            qsprintf 11 11 temp2
            quote 11 */
                seta .htextra temp2
            }
            else ife player.curr_weapon WEAPON_MINIGUN
            {
                add enemy_minigun_dmg temp6
            }
        }
        else ife sprite.htpicnum P_SMG2
        {
            ifg p_pup_damage_time 0
                clamp temp6 0 36
            else
                clamp temp6 0 18
            seta .htextra temp6
        }
    }
    else ifg sprite.extra 0
    {
        set temp5 enemy_minigun_dmg
        shiftr temp5 3
        sub enemy_minigun_dmg temp5
        clamp enemy_minigun_dmg 0 65536
    }
    
    ifhitweapon
    {

        geta .owner temp5
        ifn temp5 -1 ifn temp5 THISACTOR ifn temp5 player.i
        {
            ife sprite[temp5].picnum A_SHOCKCANISTER_BROKE
                seta .htpicnum P_SHOCKER
            else ife sprite[temp5].picnum A_SHOCKCANISTER
                seta .htpicnum P_SHOCKER
        }
        ifg enemy_annoyance ANNOYED
        {
            ife enemy_shoot 0 ife cansee_return 1 ife shot_delay 0 ifl att_return 128
            {
                set enemy_shoot 1
            }
        }
        ifwasweapon P_SHOCKER
        {
            add enemy_shocked 1
            ifg enemy_shocked 3
                set enemy_shocked 1
            set temp2 temp6
            mul temp2 enemy_shocked
            shiftr temp2 2
            geta .extra temp3
            sub temp3 temp2
            sub temp3 temp2
            seta .extra temp3
        }
        else
        {
            set temp3 temp6
            shiftl temp3 1
            set move_v temp3
            geta .ang temp3
            seta .ang sprite.htang
            state move_actor
            add enemy_xv move_xv
            add enemy_yv move_yv
            state enemy_do_move
            seta .ang temp3

        }
        ife enemy_shocked 0
        {
                ifn shot_delay 0
                        set greater_discharge 1
        }
        ife cansee_return 0 ife enemy_dodge 0
        {
                set enemy_dodge 90
                ife enemy_strafe 0
                {
                    ifrnd 96
                        state e_fp
                    set enemy_strafe 1
                    rand strafe_dir 1
                }
        }

        state spawn_blood
        ifn weapon1_alt 0 ife player.curr_weapon 1 ife sprite.htpicnum BULLET ife sprite.htowner player.i
        {
            ife w1alt 0
            {
                geta .htextra temp
                geta .extra temp2
                shiftl temp 3
                add temp2 temp
                ifl temp2 0
                    set temp2 0
                seta .extra temp2
            }
            else
            {
                geta .htextra temp
                geta .extra temp2
                shiftl temp 4
                add temp2 temp
                ifl temp2 0
                    set temp2 0
                seta .extra temp2
            }
        }

        cstat 257

        set enemy_init 1
        sleeptime 300

        ifdead
        {
            state enemy_die_resolve
            ifn enemy_headsound 0
            {
                soundonce S_IMPACT_HEADSHOT
                or p_wantline TALK_KILL
                
                ifrnd 208
                {
                    state crackhead
                    set enemy_headache 1
                    ifrnd 96
                        state skull_gibs
                }

            }
            state enemy_confirm_bowled
            set gib_temp 0
            ifwasweapon EXPLOSION
            {
                set temp3 GREATER_HEALTH
                shiftr temp3 3
                add temp3 GREATER_HEALTH
                set temp4 temp3
                shiftr temp4 3
                sub temp3 temp4
                ifg temp6 temp3
                {
                    geta .z temp3
                    sub temp3 4096
                    seta .z temp3
                    state generic_gibs
                    geta .z temp3
                    add temp3 4096
                    seta .z temp3
                    rand gib_temp 6
                    add gib_temp 8
                    for itervar range gib_temp
                    {
                        espawn A_GENERIC_DEBRIS
                        setav[RETURN].debris_type DEBRIS_METAL
                        seta[RETURN].pal sprite.pal
                        rand temp3 256
                        add temp3 sprite.htang
                        and temp3 2047
                        seta[RETURN].ang temp3
                        geta[RETURN].z temp3
                        add temp3 -6144
                        seta[RETURN].z temp3
                        ifand gib_temp 2
                        {
                            espawn A_GENERIC_DEBRIS
                            setav[RETURN].debris_type DEBRIS_FABRIC
                            seta[RETURN].pal sprite.pal
                            rand temp3 256
                            add temp3 sprite.htang
                            and temp3 2047
                            seta[RETURN].ang temp3
                            geta .z temp3
                            add temp3 -6144
                            seta[RETURN].z temp3
                        }

                    }
                    set gib_temp 1
                    cstat 32768
                }
            }
            else ifwasweapon BULLET
            {
                set temp3 GREATER_HEALTH
                shiftr temp3 1
                add temp3 GREATER_HEALTH
                shiftr temp3 1
                add temp3 GREATER_HEALTH
                shiftr temp3 1
                add temp3 GREATER_HEALTH
                shiftr temp3 1
                add temp3 GREATER_HEALTH
                /* redefinequote 11 hit:%ld threshold:%ld
                qsprintf 11 11 temp6 temp3
                quote 11 */
                ife sprite.htowner player.i ife player.curr_weapon WEAPON_MINIGUN
                {
                    /* redefinequote 11 %ld
                    qsprintf 11 11 enemy_minigun_dmg
                    quote 11 */
                    set temp4 GREATER_HEALTH
                    shiftr temp4 1
                    add temp4 GREATER_HEALTH
                    shiftr temp4 1
                    ifg enemy_minigun_dmg temp4
                        add temp6 temp3
                }
                ifg temp6 temp3
                {
                    geta .z temp3
                    sub temp3 4096
                    seta .z temp3
                    state generic_gibs
                    geta .z temp3
                    add temp3 4096
                    seta .z temp3
                    rand gib_temp 6
                    add gib_temp 8
                    for itervar range gib_temp
                    {
                        espawn A_GENERIC_DEBRIS
                        setav[RETURN].debris_type DEBRIS_METAL
                        seta[RETURN].pal sprite.pal
                        rand temp3 256
                        add temp3 sprite.htang
                        and temp3 2047
                        seta[RETURN].ang temp3
                        geta[RETURN].z temp3
                        add temp3 -6144
                        seta[RETURN].z temp3
                        ifand gib_temp 2
                        {
                            espawn A_GENERIC_DEBRIS
                            setav[RETURN].debris_type DEBRIS_FABRIC
                            seta[RETURN].pal sprite.pal
                            rand temp3 256
                            add temp3 sprite.htang
                            and temp3 2047
                            seta[RETURN].ang temp3
                            geta .z temp3
                            add temp3 -6144
                            seta[RETURN].z temp3
                        }

                    }
                    set gib_temp 1
                }
            }
            ifn gib_temp 0
            {
                state dying_blood
                set enemy_gibbed 1
                or p_wantline TALK_GIB
                set p_face_grin 30
                shiftr temp6 4 // damage amount
                ifwasweapon EXPLOSION
                    nullop
                else ifg temp6 10
                    shiftr temp6 1

                clamp temp6 1 5

                set temp3 0
                for temp3 range temp6
                    state spawn_shard
            }
            else ife enemy_headache 1
                action AC_GREATER_HEADACHE
            else
            {
                ifrnd 127
                    action AC_GREATER_DYING2
                else
                    action AC_GREATER_DYING
            }
            stopactorsound THISACTOR S_GREATER_ASCEND
            stopactorsound THISACTOR S_GREATER_FLESHBAG
            stopactorsound THISACTOR S_GREATER_KILL
            stopactorsound THISACTOR S_GREATER_MINE
            stopactorsound THISACTOR S_GREATER_UNCLEAN
            stopactorsound THISACTOR S_GREATER_DIE1
            stopactorsound THISACTOR S_GREATER_TAUNT1
            stopactorsound THISACTOR S_GREATER_TAUNT2
            stopactorsound THISACTOR S_CROSSBOW_CHARGE
            set temp 0
            ife player.gotweapon WEAPON_CROSSBOW 1
                set temp 1
            else ife userdef.user_map 1
                set temp 1
            else ife force_um 1
                set temp 1
            else ifg VOLUME EP_MAIN
            {
                ifn VOLUME EP_PREVIEW
                    set temp 1
            }
            else ifg LEVEL 9
                set temp 1
            ife temp 1 ifrnd 42
            {
                espawn I_PLASMACROSSBOW_AMMO
                geta[RETURN].z temp
                sub temp 6144
                seta[RETURN].z temp
                rand temp 64
                add temp 64
                seta[RETURN].xvel temp
                rand temp -512
                sub temp 1024
                seta[RETURN].zvel temp
                geta .ang temp
                ifrnd 127
                    sub temp 256
                else
                    add temp 256
                and temp 2047
                seta[RETURN].ang temp
                ssp RETURN CLIPMASK0

            }
            ife enemy_gibbed 0 ife enemy_headsound 0
            {
                set temp S_GREATER_DIE1
                ifpdistl ENEMY_SOUND_DIST
                    soundoncevar temp
            }
            break
        }
        else
        {
            set temp temp6
            shiftl temp 1
            rand temp temp
            ifn enemy_shocked 0
                set temp 101
            ifg temp 100
            {
                ife enemy_shocked 0
                    action AC_GREATER_HIT
                else
                    action AC_GREATER_SHOCKED
                set enemy_strafe 0
                set enemy_start 0
                set enemy_stop 1
                ife need_spot_sound 1 ifrnd 96
                {
                    set e_lastsnd_temp 0
                    whilen e_lastsnd_temp 1
                    {
                        rand temp 1
                        add temp S_GREATER_TAUNT1
                        ifn temp e_greater_lastsnd
                            set e_lastsnd_temp 1
                    }
                    ife sound_enemy_buffer[temp] 0
                    {
                        ifpdistl ENEMY_SOUND_DIST
                            soundoncevar temp
                        set e_greater_lastsnd temp
                    }
                    set need_spot_sound 30
                }
            }
        }
        break
    }
    ifaction AC_GREATER_HIT
    {
        set enemy_init 1
        ifn enemy_shocked 0
        {
            ifand sprite.htg_t 2 1
            {
                set enemy_skipshade 1
                seta .shade -127
            }
            ife enemy_shocked 1
            {
                ifactioncount 10
                {
                    action AC_GREATER_IDLE
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                }
            }
            else ife enemy_shocked 2
            {
                ifactioncount 20
                {
                    action AC_GREATER_IDLE
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                }
            }
            else ife enemy_shocked 3
            {
                ife sprite.htg_t 2 1
                    state enemy_do_move
                ifactioncount 30
                {
                    action AC_GREATER_IDLE
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                }
            }
        }
        else
        {
            ifactioncount 5
            {
                action AC_GREATER_IDLE
                set enemy_strafe 1
                rand strafe_dir 1
                set enemy_shocked 0
                ife greater_discharge 1 ifle shot_delay 40
                {
                    geta .z temp2
                    getu .vm_distance temp3
                    ifl temp3 1600
                    {
                        ifl temp3 1024
                            set temp3 0
                        else
                            shiftr temp3 2
                        sub temp2 temp3
                    }
                    else ife enemy_dodge 0
                        sub temp2 3072
                    seta .z temp2
                    setprojectile[P_PLASMA_BOLT].vel 720
                    setprojectile[P_PLASMA_BOLT].velmult 1
                    ifle shot_delay 35
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        setthisprojectile[RETURN].extra 2
                        seta[RETURN].extra 2
                        geta[RETURN].ang temp
                        geta[RETURN].zvel temp2

                        add temp 24
                        state greater_plasma_bolt

                        sub temp 12
                        state greater_plasma_bolt

                        sub temp 36
                        state greater_plasma_bolt

                        add temp 12
                        state greater_plasma_bolt
                    }
                    else ifle shot_delay 40
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        geta[RETURN].ang temp
                        geta[RETURN].zvel temp2
                        seta[RETURN].xrepeat 0
                        seta[RETURN].yrepeat 0
                        seta[RETURN].extra 0
                        seta[RETURN].statnum STAT_ACTOR


                        add temp 24
                        state greater_plasma_bolt

                        sub temp 12
                        state greater_plasma_bolt

                        state greater_plasma_bolt
                        sub temp 24

                        add temp 12
                        state greater_plasma_bolt
                    }
                    else ifle shot_delay 45
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        geta[RETURN].ang temp
                        geta[RETURN].zvel temp2
                        setthisprojectile[RETURN].extra 2
                        seta[RETURN].extra 2

                        add temp 12
                        state greater_plasma_bolt

                        sub temp 24
                        state greater_plasma_bolt

                    }
                    else ifle shot_delay 50
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        geta[RETURN].ang temp
                        geta[RETURN].zvel temp2
                        seta[RETURN].xrepeat 0
                        seta[RETURN].yrepeat 0
                        seta[RETURN].extra 0
                        seta[RETURN].statnum STAT_ACTOR

                        add temp 6
                        state greater_plasma_bolt


                        sub temp 12
                        state greater_plasma_bolt
                    }
                    else
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        setthisprojectile[RETURN].extra 2
                        seta[RETURN].extra 2
                    }
                    setprojectile[P_PLASMA_BOLT].vel PLASMA_VEL_DEFAULT

                    stopactorsound THISACTOR S_CROSSBOW_CHARGE
                    rand temp2 3
                    add temp2 S_CROSSBOW_FIRE1
                    ifpdistl ENEMY_SOUND_DIST
                    {
                        soundvar temp2
                        sound S_CROSSBOW_LOAD
                    }
                    state spawn_sound_emitter

                    geta .z temp2
                    getu .vm_distance temp3
                    ifl temp3 1600
                    {
                        ifl temp3 1024
                            set temp3 0
                        else
                            shiftr temp3 2
                        add temp2 temp3
                    }
                    else ife enemy_dodge 0
                        add temp2 3072
                    seta .z temp2
                    set enemy_shoot 60
                    set shot_delay 0
                }
                set shot_delay 0
                set enemy_shoot 60
                stopactorsound THISACTOR S_CROSSBOW_CHARGE
                set greater_discharge 0
            }
        }
        break
    }
    else ifaction AC_GREATER_SHOCKED
    {
        ifpdistl ENEMY_SOUND_DIST
        {
            soundonce S_AMB_NEONFLICKR01
            soundonce S_AMB_NEONFLICKR02
        }
        set enemy_init 1
        ifn enemy_shocked 0
        {
            ifand sprite.htg_t 2 1
            {
                set enemy_skipshade 1
                seta .shade -127
            }
            ife enemy_shocked 1
            {
                ifactioncount 10
                {
                    action AC_GREATER_IDLE
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                    stopactorsound THISACTOR S_AMB_NEONFLICKR01
                    stopactorsound THISACTOR S_AMB_NEONFLICKR02
                }
            }
            else ife enemy_shocked 2
            {
                ifactioncount 20
                {
                    action AC_GREATER_IDLE
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                    stopactorsound THISACTOR S_AMB_NEONFLICKR01
                    stopactorsound THISACTOR S_AMB_NEONFLICKR02
                }
            }
            else ife enemy_shocked 3
            {
                ife sprite.htg_t 2 1
                    state enemy_do_move
                ifactioncount 30
                {
                    action AC_GREATER_IDLE
                    set enemy_strafe 1
                    rand strafe_dir 1
                    set enemy_shocked 0
                    stopactorsound THISACTOR S_AMB_NEONFLICKR01
                    stopactorsound THISACTOR S_AMB_NEONFLICKR02
                }
                else ifactioncount 2
                {
                    ifand sprite.htg_t 2 2
                    {
                        for temp6 sprofstat STAT_ACTOR
                        {
                            ifn temp6 THISACTOR
                            {
                                ifand tiledata[sprite[temp6].picnum].gameflags 32 ifg sprite[temp6].extra 0
                                {
                                    geta .z temp5
                                    sub temp5 8192
                                    seta .z temp5
                                    canseespr THISACTOR temp6 temp2
                                    add temp5 8192
                                    seta .z temp5
                                    ife temp2 1
                                    {
                                        dist temp2 THISACTOR temp6
                                        ifl temp2 1280
                                        {
                                            getav[temp6].enemy_shocked temp2
                                            ife temp2 2
                                            {

                                                geta .ang temp5
                                                set face_target temp6
                                                state face_actor
                                                seta .ang face_return
                                                espawn A_LIGHTNINGBALL
                                                ifrnd 127
                                                {
                                                    seta[RETURN].z sprite[temp6].z
                                                    seta[RETURN].y sprite[temp6].y
                                                    seta[RETURN].x sprite[temp6].x
                                                    seta[RETURN].sectnum sprite[temp6].sectnum
                                                }
                                                geta[RETURN].z temp2
                                                sub temp2 8192
                                                seta[RETURN].z temp2
                                                seta .ang temp5
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else ifactioncount 1
                {
                    for temp6 sprofstat STAT_ACTOR
                    {
                        ifn temp6 THISACTOR
                        {
                            ifand tiledata[sprite[temp6].picnum].gameflags 32 ifg sprite[temp6].extra 0
                            {
                                geta .z temp5
                                sub temp5 8192
                                seta .z temp5
                                canseespr THISACTOR temp6 temp2
                                add temp5 8192
                                seta .z temp5
                                ife temp2 1
                                {
                                    dist temp2 THISACTOR temp6
                                    ifl temp2 1280
                                    {
                                        geta .ang temp5
                                        set face_target temp6
                                        state face_actor
                                        seta .ang face_return
                                        espawn A_LIGHTNINGBALL
                                        ifrnd 127
                                        {
                                            seta[RETURN].z sprite[temp6].z
                                            seta[RETURN].y sprite[temp6].y
                                            seta[RETURN].x sprite[temp6].x
                                            seta[RETURN].sectnum sprite[temp6].sectnum
                                        }
                                        geta[RETURN].z temp2
                                        sub temp2 8192
                                        seta[RETURN].z temp2
                                        seta .ang temp5
                                        geta[temp6].htextra temp2
                                        add temp2 WEAPON0_DMG
                                        seta[temp6].htextra temp2
                                        setav[temp6].enemy_shocked 2
                                        setav[temp6].enemy_init 1
                                    }
                                }
                            }
                        }
                    }
                    for itervar range num_flag32
                    {
                        set temp6 gameflag32[itervar]
                        ifn temp6 THISACTOR
                        {
                            ifg sprite[temp6].extra 0
                            {
                                geta .z temp5
                                sub temp5 8192
                                seta .z temp5
                                canseespr THISACTOR temp6 temp2
                                add temp5 8192
                                seta .z temp5
                                ife temp2 1
                                {
                                    dist temp2 THISACTOR temp6
                                    ifl temp2 1280
                                    {
                                        geta[temp6].htextra temp2
                                        add temp2 WEAPON0_DMG
                                        seta[temp6].htextra temp2
                                        setav[temp6].enemy_shocked 2
                                        setav[temp6].enemy_init 1
                                        changespritestat temp6 STAT_ACTOR
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        break
    }
    cstat 257
    ife enemy_init 0
    {
        getp .i att_target
        state angle_to_target
        ldist temp THISACTOR player.i
        set temp2 att_return
        div temp2 36
        ife temp2 0
            set temp2 1
        set temp3 GREATER_CONE
        div temp3 temp2
        set temp4 0
        ife cansee_return 1
            set temp4 1
        else ifn hitwall -1
        {
            set surface_type wall[hitwall].picnum
            state get_surface_type
            set temp5 0
            ifand wall[hitwall].cstat 16
                set temp5 1
            ifand wall[hitwall].cstat 32
                set temp5 1
            ife temp5 1 // if this wall has a maskwall
            {
                // this trick lets us determine if we're in between the ceiling and floor
                // and should be in the masked area
                getw[hitwall].nextsector temp5
                ifn temp5 -1
                {
                    ifl hitz sector[temp5].floorz ifg sprite.z sector[temp5].ceilingz
                    {
                        getw[hitwall].nextwall temp5
                        getw[temp5].overpicnum surface_type // get the masked texture if so
                        state get_surface_type
                    }
                }
            }
            ife surface_type SURFACE_GLASS ifl wall[hitwall].shade 7 ifn wall[hitwall].blend 130
            {
                ifand wall[hitwall].cstat 128
                {
                    ifand wall[hitwall].cstat 16
                    {
                        state enemy_hitscan_glass
                        ife e_glass_hitscan_return 1
                            set temp4 1
                    }
                    ifand wall[hitwall].cstat 32
                    {
                        state enemy_hitscan_glass
                        ife e_glass_hitscan_return 1
                            set temp4 1
                    }

                }
            }
        }
        ife temp4 1
        {
            ifl temp temp3
                set enemy_init 1
            else ifl sprite.extra GREATER_HEALTH
                set enemy_init 1
            else ifl att_return 448
                set enemy_init 1
            else
            {
                state enemy_do_move
                break
            }
        }
        else
        {
            state enemy_do_move
            break
        }
    }

    set enemy_faceplayerslow 1
    ife enemy_faceplayerslow 1 ife enemy_strafe 0 ife enemy_shoot 0
        state e_fp

    ifpdistl GREATER_SLOW
    {
        ifpdistl GREATER_STOP
        {
            ifrnd 32 ife enemy_stop 0 ife enemy_shoot 0 ife se_hitag 0
                set enemy_stop 1
            ifmove AM_ENEMY_SEARCH
                move AM_ENEMY_SEARCH_STOP
        }
        else
        {
            ifrnd 32 ife enemy_start 0 ife enemy_shoot 0
            {
                set enemy_start 1
            }
        }
    }
    else ifrnd 111 ife enemy_start 0 ife enemy_shoot 0
        set enemy_start 1

    ifrnd 64 ife enemy_strafe 0 ife enemy_shoot 0 ife se_hitag 0
    {
        set enemy_strafe 1
        rand strafe_dir 1
        ife need_spot_sound 1 ifrnd 16
        {
            state spawn_sound_emitter
            rand temp 1
            rand temp 2
            ife temp 2
                set temp 4
            add temp S_GREATER_ASCEND
            ifn temp e_greater_lastsnd ife sound_enemy_buffer[temp] 0
            {
                ifpdistl ENEMY_SOUND_DIST
                    soundoncevar temp
                set e_greater_lastsnd temp
            }
            set need_spot_sound 30
        }
    }

    getp .i att_target
    state angle_to_target

    ifg need_spot_sound 1
        sub need_spot_sound 1
    else ifl need_spot_sound 1
        add need_spot_sound 1

    rand temp6 255
    ifle enemy_annoyance NEUTRAL
        set temp5 GREATER_ATTK_FREQ
    else ifle enemy_annoyance ANNOYED
    {
        set temp5 GREATER_ATTK_FREQ
        shiftr temp5 4
        add temp5 GREATER_ATTK_FREQ
    }
    else ifle enemy_annoyance ANGRY
    {
        set temp5 GREATER_ATTK_FREQ
        shiftr temp5 3
        add temp5 GREATER_ATTK_FREQ
    }
    else ifle enemy_annoyance PISSED
    {
        set temp5 GREATER_ATTK_FREQ
        shiftr temp5 2
        add temp5 GREATER_ATTK_FREQ
    }
    else
    {
        set temp5 GREATER_ATTK_FREQ
        shiftr temp5 1
        add temp5 GREATER_ATTK_FREQ
    }

    getu .player_skill temp4
    mul temp5 temp4
    shiftr temp5 1
    
    set temp4 0
    ife cansee_return_o 1
        set temp4 1
    else ife cansee_return 1
        set temp4 1

    ife temp4 1 ife need_spot_sound 0
    {
        set temp S_GREATER_FLESHBAG
            ifrnd 127
                add temp 3
        ifn temp e_greater_lastsnd ife sound_enemy_buffer[temp] 0
        {
            ifpdistl ENEMY_SOUND_DIST
                soundoncevar temp
            set e_greater_lastsnd temp
        }
        set need_spot_sound 30
        set was_lost_sound 0
    }

    ife need_spot_sound -30
    {
        ife enemy_strafe 0
        {
            ifrnd 96
                state e_fp
            set enemy_strafe 1
            rand strafe_dir 1
        }
    }

    ife se_hitag 0
    {
        ifn temp4 1
        {
            ifrnd 96 ife enemy_strafe 0
            {
                ifrnd 96
                    state e_fp
                set enemy_strafe 1
                rand strafe_dir 1
            }
        }
        else ife cansee_return 1
        {
            ife enemy_shoot 0 // shoot or strafe
            {
                ifl att_return 128
                {
                    set temp 0
                    ifle temp6 temp5
                    {
                        ife shot_delay 0
                        {
                            set temp2 GREATER_ATTK
                            ifn sprite.htactorstayput -1
                            {
                                mul temp2 3
                                shiftr temp2 1
                            }
                            ifl userdef.vm_distance temp2
                            {   ifrnd 48
                                {
                                    set enemy_shoot 1
                                    set temp 1
                                }
                                else ifrnd 96
                                {
                                    state e_fp
                                    set enemy_strafe 1
                                    rand strafe_dir 1
                                }
                            }
                        }
                    }
                    ife temp 0
                    {
                        ifrnd 96
                        {
                            ife enemy_strafe 0
                            {
                                ifpdistl GREATER_STRF
                                {
                                    ifrnd 96
                                        state e_fp
                                    set enemy_strafe 1
                                    rand strafe_dir 1
                                }
                            }
                        }
                        else ifrnd 96
                        {
                            ife enemy_start 0
                            {
                                ifpdistl 4096
                                    nullop
                                else
                                    set enemy_start 1
                            }
                        }
                    }
                }
                else // else maybe dodge
                {
                    ifrnd 96
                    {
                        ife enemy_strafe 0
                        {
                            ifrnd 96
                                state e_fp
                            set enemy_strafe 1
                            rand strafe_dir 1
                        }
                    }
                    else ifrnd GREATER_DODG_FREQ
                    {
                        ife enemy_strafe 0
                        {
                            ifpdistl GREATER_DODG
                            {
                                ifp pfacing
                                {
                                    ifrnd 96
                                        state e_fp
                                    set enemy_strafe 1
                                    rand strafe_dir 1
                                }
                            }
                        }
                    }
                    else ifrnd 96
                    {
                        ife enemy_start 0
                        {
                            ifpdistl 4096
                                nullop
                            else
                                set enemy_start 1
                        }
                    }
                }
            }
        }
    }

    ifpdistl 800 ife cansee_return 1
    {
        ife enemy_stop 0 ife se_hitag 0
            set enemy_stop 8
    }
    ifrnd 4
    {   ife enemy_stop 0 ife enemy_shoot 0 ife se_hitag 0
            set enemy_stop 1
    }

    ifn enemy_start 0 ife enemy_stop 0
    {
        set move_v enemy_start
        ifn way_current -1
            shiftl move_v 4
        else
            shiftl move_v 4
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv

        add enemy_start 1
        ifg enemy_start 12
            set enemy_start 12

        set enemy_stop 0
        ifg enemy_strafe 0
            sub enemy_strafe 1
        else
        {
            set enemy_roamang -1
            set enemy_strafe_mod 0
        }
    }

    ifn enemy_strafe 0 ife enemy_stop 0
    {
        ifnotmoving
        {
            ifn enemy_roamang -1
            {
               set enemy_roamang -1
               state e_fp
            }
        }
        geta .ang temp
        ife enemy_roamang -1
        {
            set temp2 temp // save for later
            add temp 512
            ife strafe_dir 1
                add temp 1024
            and temp 2047
        }
        else
            set temp enemy_roamang
        seta .ang temp

        ifl reverse_dir 10
        {
            ife enemy_strafe 1
            {
                ife enemy_roamang -1
                        ifrnd 24
                            set enemy_roamang temp
                ifrnd 127
                    set enemy_strafe_mod 1
            }
        }
        else
            set enemy_roamang -1
        set move_v enemy_strafe
        ifn enemy_roamang -1
            add move_v 6
        else ife enemy_strafe_mod 1
            add move_v 4
        clamp move_v 0 20

        ifn way_current -1
            mul move_v 6
        else
            mul move_v 10
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ife enemy_roamang -1
            seta .ang temp2

        add enemy_strafe 1
        ifg enemy_strafe 8
            set enemy_strafe 8

        set enemy_stop 0
        ifg enemy_start 0 ifg enemy_strafe 3
            sub enemy_start 1

        set enemy_shoot 0
        state e_fp
        ifn enemy_roamang -1
            seta .ang enemy_roamang
    }

    ifn enemy_stop 0
    {
        shiftr enemy_xv 1
        shiftr enemy_yv 1
        add enemy_stop 1
        ifn enemy_start 0
            sub enemy_start 1
        ifn enemy_strafe 0
            sub enemy_strafe 1
        ifg enemy_stop 12
        {
            set enemy_xv 0
            set enemy_yv 0
            set enemy_stop 0
            set enemy_start 0
            set enemy_strafe 0
        }
    }
    ifn enemy_shoot 0
    {
        shiftr enemy_xv 4
        shiftr enemy_yv 4
        add enemy_shoot 1
        ifn enemy_start 0
            sub enemy_start 1
        ifn enemy_stop 0
            sub enemy_stop 1
        ifn enemy_strafe 0
            sub enemy_strafe 1
        ifg enemy_shoot 59
        {
            ifg shot_delay 24
                nullop
            else
            {
                set enemy_xv 0
                set enemy_yv 0
                set enemy_stop 0
                set enemy_shoot 0
                set enemy_start 0
                set enemy_strafe 0
            }
        }
    }

    ifn enemy_shoot 0
    {

        ifn shot_delay 0
        {
            ldist temp player.i THISACTOR
            ifl temp 480
            {
                set temp4 tilesizy[A_GREATER]
                shiftl temp4 2
                mul temp4 sprite.yrepeat
                set temp2 sprite.z
                sub temp2 temp4
                ifle player.posz sprite.z ifge sprite[player.i].z temp2
                {
                    sub temp 440
                    geta .x face_x
                    sub face_x sprite[player.i].x

                    geta .y face_y
                    sub face_y sprite[player.i].y

                    getangle face_return face_x face_y
                    add face_return 1024
                    and face_return 2047
                    
                    set move_v temp
                    sub move_v 64
                    abs move_v
                    cos move_xv face_return
                    sin move_yv face_return
                    mul move_xv move_v
                    mul move_yv move_v
                    shiftr move_xv 4
                    shiftr move_yv 4
                    setp .posxv move_xv
                    setp .posyv move_yv
                }
            }
            state e_fp

            ifp pducking
                ifpdistl 1024
                    ife enemy_dodge 0
                        ifrnd 192
                            set enemy_dodge 30
            ifg shot_delay 59
            {
                ifn enemy_dodge 0
                    action AC_GREATER_CHARGE_CRC
                else
                    action AC_GREATER_CHARGE
            }
            else ifle shot_delay 40
            {
                ifaction AC_GREATER_CHARGE
                    action AC_GREATER_SHOOT
                else ifaction AC_GREATER_CHARGE_CRC
                    action AC_GREATER_SHOOT_CRC
                else ifaction AC_GREATER_IDLE ifg shot_delay 25
                {
                    ifn enemy_dodge 0
                        action AC_GREATER_SHOOT_CRC
                    else
                        action AC_GREATER_SHOOT
                }
            }
            ifle enemy_annoyance NEUTRAL
                nullop
            else ifle enemy_annoyance ANNOYED
            {
                    ifg shot_delay 50
                    {
                        set shot_delay 50
                        set enemy_shoot shot_delay
                    }
            }
            else ifle enemy_annoyance ANGRY
            {
                    ifg shot_delay 45
                    {
                        set shot_delay 45
                        set temp shot_delay
                        sub temp 60
                        inv temp
                        set enemy_shoot temp
                    }
            }
            else ifle enemy_annoyance PISSED
            {
                    ifg shot_delay 40
                    {
                        set shot_delay 40
                        set temp shot_delay
                        sub temp 60
                        inv temp
                        set enemy_shoot temp
                    }
            }
            else
            {
                    ifg shot_delay 35
                    {
                        set shot_delay 35
                        set temp shot_delay
                        sub temp 60
                        inv temp
                        set enemy_shoot temp
                    }
            }
            switch shot_delay
                case 57
                    ifpdistl ENEMY_SOUND_DIST
                        soundonce S_CROSSBOW_CHARGE
                    break
                case 55
                    ifpdistl ENEMY_SOUND_DIST
                        sound S_CROSSBOW_READY
                    break
                case 50
                    ifpdistl ENEMY_SOUND_DIST
                        sound S_CROSSBOW_READY
                    break
                case 45
                    ifpdistl ENEMY_SOUND_DIST
                        sound S_CROSSBOW_READY
                    break
                case 40
                    ifpdistl ENEMY_SOUND_DIST
                        sound S_CROSSBOW_READY
                    break
                case 35
                    ifpdistl ENEMY_SOUND_DIST
                        sound S_CROSSBOW_READY
                    break
                case 30
                    ife cansee_return_a 1
                    {
                        ifrnd 96
                        {
                            set shot_delay 0
                            action AC_GREATER_IDLE
                            stopactorsound THISACTOR S_CROSSBOW_CHARGE
                            set enemy_xv 0
                            set enemy_yv 0
                            set enemy_stop 0
                            set enemy_shoot 0
                            set enemy_start 0
                            set enemy_strafe 0
                        }
                        else ifrnd 127
                        {
                            set shot_delay 31
                            action AC_GREATER_SHOOT
                            set enemy_shoot 31
                        }
                    }
                    break
                case 25
                    ifpdistl 480
                    {
                        set face_target player.i
                        state face_actor
                        geta .ang temp7
                        add face_return 1024
                        and face_return 2047
                        seta .ang face_return
                        seta .xvel 32
                        ssp THISACTOR CLIPMASK0
                        seta .ang temp7
                    }
                    geta .z temp2
                    getu .vm_distance temp3
                    ifl temp3 1600
                    {
                        ifl temp3 1024
                            set temp3 0
                        else
                            shiftr temp3 2
                        sub temp2 temp3
                    }
                    else ife enemy_dodge 0
                        sub temp2 3072
                    ifp pducking add temp2 1024
                    seta .z temp2
                    rand temp2 255
                    getu .player_skill temp
                    ifge temp 3
                        set temp2 0
                    ifle temp2 127
                    {
                        set temp2 player.posxv
                        set temp3 player.posyv
                        
                        shiftr temp2 14
                        ifl userdef.player_skill 4
                        {
                            rand temp temp2
                            add temp2 temp
                        }
                        shiftr temp3 14
                        ifl userdef.player_skill 4
                        {
                            rand temp temp3
                            add temp3 temp
                        }
                        
                        add temp2 player.posx
                        add temp3 player.posy

                        sub temp2 sprite.x
                        sub temp3 sprite.y

                        getangle enemy_lockang temp2 temp3
                        seta .ang enemy_lockang
                    }
                    getu .player_skill temp2
                    sub temp2 1
                    clamp temp2 0 8
                    shiftl temp2 5
                    add temp2 720
                    setprojectile[P_PLASMA_BOLT].vel temp2
                    setprojectile[P_PLASMA_BOLT].velmult 1
                    ifle enemy_annoyance NEUTRAL
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        setthisprojectile[RETURN].extra 2
                        seta[RETURN].extra 2
                        geta[RETURN].ang temp
                        geta[RETURN].zvel temp2

                        add temp 24
                        state greater_plasma_bolt
                        sub temp 12
                        state greater_plasma_bolt

                        sub temp 36
                        state greater_plasma_bolt

                        add temp 12
                        state greater_plasma_bolt
                    }
                    else ifle enemy_annoyance ANNOYED
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        geta[RETURN].ang temp
                        geta[RETURN].zvel temp2
                        seta[RETURN].xrepeat 0
                        seta[RETURN].yrepeat 0
                        seta[RETURN].extra 0
                        seta[RETURN].statnum STAT_ACTOR


                        add temp 24
                        state greater_plasma_bolt

                        sub temp 12
                        state greater_plasma_bolt

                        sub temp 24
                        state greater_plasma_bolt

                        add temp 12
                        state greater_plasma_bolt
                    }
                    else ifle enemy_annoyance ANGRY
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        geta[RETURN].ang temp
                        geta[RETURN].zvel temp2
                        setthisprojectile[RETURN].extra 2
                        seta[RETURN].extra 2

                        add temp 12
                        state greater_plasma_bolt

                        sub temp 24
                        state greater_plasma_bolt
                    }
                    else ifle enemy_annoyance PISSED
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        geta[RETURN].ang temp
                        geta[RETURN].zvel temp2
                        seta[RETURN].xrepeat 0
                        seta[RETURN].yrepeat 0
                        seta[RETURN].extra 0
                        seta[RETURN].statnum STAT_ACTOR

                        add temp 6
                        state greater_plasma_bolt

                        sub temp 12
                        state greater_plasma_bolt
                    }
                    else
                    {
                        seta .shade -127
                        set enemy_skipshade 1
                        eshoot P_PLASMA_BOLT
                        setthisprojectile[RETURN].extra 2
                        seta[RETURN].extra 2
                    }
                    setprojectile[P_PLASMA_BOLT].vel PLASMA_VEL_DEFAULT

                    stopactorsound THISACTOR S_CROSSBOW_CHARGE
                    rand temp2 3
                    add temp2 S_CROSSBOW_FIRE1
                    ifpdistl ENEMY_SOUND_DIST
                    {
                        soundvar temp2
                        sound S_CROSSBOW_LOAD
                    }
                    state spawn_sound_emitter

                    geta .z temp2
                    getu .vm_distance temp3
                    ifl temp3 1600
                    {
                        ifl temp3 1024
                            set temp3 0
                        else
                            shiftr temp3 2
                        add temp2 temp3
                    }
                    else ife enemy_dodge 0
                        add temp2 3072
                    ifp pducking sub temp2 1024
                    seta .z temp2
                    ifle enemy_dodge 90
                        set enemy_dodge 0
                    break
                case 24
                    cstat 257
                    break
                case 10
                    ifaction AC_GREATER_SHOOT
                    {
                        action AC_GREATER_IDLE
                        ifpdistl ENEMY_SOUND_DIST
                            soundonce S_CROSSBOW_RESET
                    }
                    else ifaction AC_GREATER_SHOOT_CRC
                    {
                        action AC_GREATER_IDLE
                        ifpdistl ENEMY_SOUND_DIST
                            soundonce S_CROSSBOW_RESET
                    }
                    break
            endswitch

            ifmove AM_ENEMY_SEARCH
                move AM_ENEMY_SEARCH_STOP
        }
        else
        {
            set enemy_shoot 1
            ifn enemy_dodge 0
                action AC_GREATER_CHARGE_CRC
            else
                action AC_GREATER_CHARGE
            state e_fp

            set shot_delay 60
            ife need_spot_sound 1 ifrnd 32
            {

                set e_lastsnd_temp 0
                whilen e_lastsnd_temp 1
                {
                    rand temp 1
                    add temp S_GREATER_KILL
                    ifn temp e_greater_lastsnd
                        set e_lastsnd_temp 1
                }
                ife sound_enemy_buffer[temp] 0
                {
                    ifpdistl ENEMY_SOUND_DIST
                        soundoncevar temp
                    set e_greater_lastsnd temp
                }
                set need_spot_sound 30
            }
        }
    }
    else ifn enemy_dodge 0
    {
        ifaction AC_GREATER_DODGE
            nullop
        else
            action AC_GREATER_DODGE
        sub enemy_dodge 1
    }
    else ifn enemy_strafe 0
    {
        ifaction AC_GREATER_STRAFE
            nullop
        else
            action AC_GREATER_STRAFE
    }
    else ifn enemy_start 0
    {
        ifaction AC_GREATER_WALK
            nullop
        else
            action AC_GREATER_WALK
    }
    else ifg enemy_stop 2
    {
        ifaction AC_GREATER_IDLE
            nullop
        else
            action AC_GREATER_IDLE
    }

    ifn way_current -1
        set reverse_dir 0
    ifn reverse_dir 0
    {
        inv enemy_xv
        inv enemy_yv
        shiftr enemy_xv 1
        shiftr enemy_yv 1
        sub reverse_dir 1
        ifrnd 96
        {
            ife enemy_shoot 0
            {
                ife enemy_strafe 0
                {
                    state e_fp
                    set enemy_strafe 6
                    rand strafe_dir 1
                    set reverse_dir 0
                }
                else
                {
                    ifl enemy_start 6
                        set enemy_start 8
                    set reverse_dir 0
                }
            }
        }
    }
    set temp7 0
    geta .x temp8
    geta .y temp9
    state enemy_do_move
    sub temp8 sprite.x
    sub temp9 sprite.y
    abs temp8
    abs temp9
    
    ife se_hitag 0
    {
        add temp8 temp9
        ifg temp8 15
            set temp7 1
        ife temp7 0
        {
            ifl counter2 10
                add counter2 1
        }
        else
            ifl counter2 10
                ifg counter2 0
                    sub counter2 1
        ifge counter2 10
        {
            ife sprite.htactorstayput sprite.sectnum
            {
                set enemy_xv 0
                set enemy_yv 0
                set enemy_start 0
                set enemy_strafe 0
                set enemy_dodge 0
                set enemy_roamang -1
                set reverse_dir 0
                ife enemy_stop 0
                    set enemy_stop 10
                ifaction AC_GREATER_WALK
                {
                    action AC_GREATER_IDLE
                    ife counter2 39
                    {
                        rand temp7 2047
                        seta .ang temp7
                    }
                }
                ifaction AC_GREATER_STRAFE
                    action AC_GREATER_IDLE
                ifaction AC_GREATER_DODGE
                    action AC_GREATER_IDLE
            }
            add counter2 1
            ifg counter2 40
                set counter2 0
        }
    }
enda


action AC_TURRET_IDLE 0 1 7 1 1
action AC_TURRET_SPIN 0 1 7 1 1
action AC_TURRET_FIRE 0 3 7 1 1
action AC_TURRET_DEAD 22 1 1 1 1

var ang_orig 0 2
var ang_offset 0 2
var turret_spin 0 2
var turret_state 0 2
var turret_windup 0 2
var turret_interval 0 2

defstate calc_turret_mover_pos
    ifn ps_master_id -1
    {
        sleeptime 300
        ife sprite[ps_master_id].statnum MAXSTATUS
            killit
        geta[ps_master_id].x temp
        add temp pivot_xoff
        seta .x temp
        geta[ps_master_id].y temp
        add temp pivot_yoff
        seta .y temp
        geta[ps_master_id].z temp
        add temp pivot_zoff
        seta .z temp
        seta .ang temp

        set temp sprite.sectnum
        updatesectorz sprite.x sprite.y sprite.z temp
        ifn temp -1
            seta .sectnum temp

        getav[ps_master_id].pivot_angdiff temp3 // previously stored angle change operation result (for speed)
        rotatepoint sprite[ps_master_id].x sprite[ps_master_id].y sprite.x sprite.y temp3 temp4 temp5

        seta .x temp4
        seta .y temp5

        ifactor A_TURRETDEAD
        {
            getav .pivot_ang temp4
            add temp4 temp3
            and temp4 2047
            seta .ang temp4
        }
        else
        {
            getav .pivot_ang temp4
            add temp4 temp3
            and temp4 2047
            set ang_orig temp4 // update ang_orig
            
            set temp5 temp4 // calc difference between new ang_orig and ang_offset
            set temp6 ang_offset
            and temp6 2047
            sub temp5 temp6

            ifg temp5 1023
                sub temp5 2047
            ifl temp5 -1023
                add temp5 2047
            sub temp4 temp5 // apply diff back to ang_orig
            and temp4 2047
            seta .ang temp4 // set final ang and update ang_offset
            set ang_offset temp4
        }
    }
ends

useractor notenemy A_TURRETDEAD 0 AC_BASE
    ifand sprite.cstat 8
        cstat 264
    else
        cstat 256
        
    state calc_turret_mover_pos
enda

eventloadactor A_TURRET
    state enemy_load_init
    geta .owner tp_owner
enda

defstate turret_get_canisters
    ifl enemy_init 3
    {
        add enemy_init 1
        switch sprite.pal
            case PAL_TURRET_MOVER
            case PAL_TURRET_MOVER_ALT
                ifg tp_owner 0
                {
                    strength TURRET_MHEALTH
                    for itervar sprofstat STAT_MASTER_MOVER
                    {
                        ife actorvar[itervar].pivot_hitag tp_owner
                            set ps_master_id itervar
                    }
                    ifn ps_master_id -1
                    {
                        geta .x pivot_xoff
                        sub pivot_xoff sprite[ps_master_id].x
                        geta .y pivot_yoff
                        sub pivot_yoff sprite[ps_master_id].y
                        geta .z pivot_zoff
                        sub pivot_zoff sprite[ps_master_id].z
                        geta .ang pivot_ang
                    }
                    set enemy_init 3
                    set tp_owner 0
                }
                break
            default
                ife enemy_init 3
                {
                    ifg tp_owner 0
                    {
                        for temp sprofstat STAT_ACTOR
                        {
                            ife sprite[temp].picnum A_SHOCKCANISTER
                            {
                                ife tp_owner actorvar[temp].tp_owner
                                {
                                    add turret_match 1
                                    setav[temp].turret_match THISACTOR
                                }
                            }
                        }
                        for temp sprofstat STAT_ZOMBIEACTOR
                        {
                            ife sprite[temp].picnum A_SHOCKCANISTER
                            {
                                ife tp_owner actorvar[temp].tp_owner
                                {
                                    add turret_match 1
                                    setav[temp].turret_match THISACTOR
                                }
                            }
                        }
                        ifl turret_match 0
                            set tp_owner 0
                    }
                }
                break
        endswitch
    } 
    state calc_turret_mover_pos
ends

defstate turret_shock_spin
    ifn enemy_shocked 0
    {
        rand temp 2
        for itervar range temp
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 120 // sparks
            seta[RETURN].pal 6

            rand temp2 512
            ifrnd 127
                inv temp2
            add temp2 sprite.htang
            add temp2 1024
            seta[RETURN].ang temp2


            geta .picnum temp2
            set temp4 tilesizy[temp2]
           // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
           // simplified to sizy*4*yrepeat
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            set temp2 sprite.z
            rand temp3 temp4
            sub temp2 temp3
            seta[RETURN].z temp2

            rand temp2 128
            ifrnd 127
                inv temp2
            add temp2 sprite.x
            seta[RETURN].x temp2
            rand temp2 128
            ifrnd 127
                inv temp2
            add temp2 sprite.y
            seta[RETURN].y temp2
        }
        set temp turret_spin
        and temp 1023
        ife temp 0
        {
            setp .sound_pitch 512
            sound S_MELEE_SWING03
            setp .sound_pitch 0
        }
        ifaction AC_TURRET_SPIN
            nullop
        else
            action AC_TURRET_SPIN
        set temp enemy_shocked
        shiftl temp 6
        add turret_spin temp
        add temp sprite.ang
        and temp 2047
        seta .ang temp
        set temp6 temp
        ifge turret_spin 2047
        {
            sub enemy_shocked 1
            seta .ang ang_offset
            ifn enemy_shocked 0
            {
                set temp enemy_shocked
                shiftl temp 6
                add turret_spin temp
                add temp sprite.ang
                and temp 2047
                seta .ang temp
            }
            set turret_spin 0
        }

    }
    else ifaction AC_TURRET_SPIN
        action AC_TURRET_IDLE
ends

var turret_search

defstate turret_windup_state
    getp .i att_target
    state angle_to_target
    set temp5 att_return
    abs temp5
    add temp5 temp4
    ifge turret_search 0
    {
        ife turret_search 0
            ifpdistl 16384
                soundonce S_TURRET_SEARCH
        add turret_search 1
        mod turret_search 600
    }
    ife cansee_return 1
    {
        ifl temp5 128
        {
            ife counter 1
                set counter 2
            ife turret_state 0
            {
                ifge turret_search 0
                {
                    set turret_search -1
                }
                ifle turret_search -1
                {
                    ife turret_search -1
                    {
                        stopactorsound THISACTOR S_TURRET_SEARCH
                        soundonce S_TURRET_SPOTTED
                    }
                    set turret_search -2
                }
                set turret_state 1
                ifaction AC_TURRET_IDLE
                {
                    ife turret_windup 0
                    {
                        setp .sound_pitch 400
                        sound S_TURRET_PREPGUN
                        setp .sound_pitch 0
                        set turret_windup 120
                    }
                    else
                    {
                        setp .sound_pitch 400
                        soundonce S_TURRET_ROTATE
                        setp .sound_pitch 0
                        sub turret_windup 1
                    }
                }
            }
        }
        else
        {
            ifg counter 1
                sub counter 1
            set turret_state 0
            ifl turret_search 0
            {
                sub turret_search 1
               
                ifl turret_search 90
                    set turret_search 0
            }
        }
    }
    else
    {
        ifl turret_search 0
        {
            sub turret_search 1
           
            ifl turret_search 90
                set turret_search 0
        }
        ifg counter 1
            sub counter 1
        set turret_state 0
    }
    ifg turret_windup 0
    {
        setp .sound_pitch 400
        ifpdistl 12288
            soundonce S_TURRET_ROTATE
        setp .sound_pitch 0
        sub turret_windup 1
        getu .player_skill temp6 // adjust max windup speed based on skill
        sub temp6 2
        clamp temp6 0 6
        shiftl temp6 4
        ifg temp6 0
            sub turret_windup temp6
        clamp turret_windup 0 360
    }
ends

defstate calc_turret_fire_dist
    // special note: for 360 degree turning turrets we keep firing until view is broken
    switch sprite.pal
        case PAL_TURRET_ALT
            set temp2 1
            break
        case PAL_TURRET_MOVER_ALT
        case PAL_TURRET_MOVER
            set temp2 2
            break
    endswitch
    ifpdistl 14436
        nullop
    else ifn temp2 0
    {
        set temp3 userdef.vm_distance
        
        ifpdistl 19456
        {
            ifpdistl 14436
                nullop
            else
                set temp 2
        }
        else ife temp2 2
        {
            ifpdistl 29184
            {
                ifpdistl 14436
                    nullop
                else ifpdistl 19456
                    nullop
                else
                    set temp 2
            }
            else ifspritepal PAL_TURRET_MOVER
                set temp 1
        }
    }
    else
        set temp 1
ends

defstate calc_turret_ang
    set att_noclamp 1
    getp .i att_target
    state angle_to_target
    set temp5 att_return
    abs temp5
    ifl temp5 1024
    {
        ife cansee_return_o 1 ifn att_return 0
        {
            ifg att_return 0
            {
                shiftr att_return 2
                set temp2 0
                switch sprite.pal // alts can turn more quickly
                    case PAL_TURRET_ALT
                    case PAL_TURRET_MOVER_ALT
                        clamp att_return 1 13
                        getu .player_skill temp6  // adjust max turn speed based on skill
                        sub temp6 2
                        clamp temp6 0 6
                        mul temp6 att_return
                        shiftr temp6 2
                        add att_return temp6
                        break
                    default
                        clamp att_return 1 12
                        getu .player_skill temp6 // adjust max turn speed based on skill
                        sub temp6 2
                        clamp temp6 0 6
                        mul temp6 att_return
                        shiftr temp6 2
                        add att_return temp6
                        break
                endswitch
            }
            else
            {
                shiftr att_return 2
                switch sprite.pal // alts can turn more quickly
                    case PAL_TURRET_ALT
                    case PAL_TURRET_MOVER_ALT
                        clamp att_return -13 -1
                        getu .player_skill temp6 // adjust max turn speed based on skill
                        sub temp6 2
                        clamp temp6 0 6
                        mul temp6 att_return
                        shiftr temp6 2
                        add att_return temp6
                        break
                    default
                        clamp att_return -12 -1
                        getu .player_skill temp6 // adjust max turn speed based on skill
                        sub temp6 2
                        clamp temp6 0 6
                        mul temp6 att_return
                        shiftr temp6 2
                        add att_return temp6
                        break
                endswitch
            }
        }
    }
    else
        set att_return 0

    sub ang_offset att_return

    ifspritepal PAL_TURRET_ALT
        set temp4 0
    else ifspritepal PAL_TURRET_MOVER_ALT
        set temp4 0
    else  // limit ang changes on non alts to about 60 degrees from origin
    {
        set temp ang_orig
        sub temp 340

        set temp2 ang_orig
        add temp2 340
        set temp4 0

        ifg ang_offset temp2
        {
            set ang_offset temp2
            set temp4 42
        }
        else ifl ang_offset temp
        {
            set ang_offset temp
            set temp4 42
        }
    }
    set temp ang_offset
    and temp 2047
    seta .ang temp
ends

var turret_accuracy 0 2
defstate turret_shoot
    getu .player_skill temp6 // set perfect shot alignment at intervals based on skill (skipped for easy)
    ifg temp6 1
    {
        sub temp6 6
        inv temp6
        clamp temp6 0 6
        shiftl temp6 2
        ifge turret_accuracy temp6
        {
            setprojectile[P_LOVERBOY].workslike 1179649
            set turret_accuracy 0
        }
        else
            add turret_accuracy 1
    }
    geta .ang temp
    geta .ang temp2
    add temp 512
    seta .ang temp
    set move_v 136
    state move_actor
    geta .x temp3
    geta .y temp4
    sub temp3 move_xv
    sub temp4 move_yv

    seta .x temp3
    seta .y temp4

    seta .ang temp2
    geta .z temp
    add temp 512
    seta .z temp
    eshoot P_LOVERBOY // need to change this to something with a better
    sub temp 512     // trail for this actor
    seta .z temp

    add temp3 move_xv
    add temp4 move_yv
    seta .x temp3
    seta .y temp4
    setp .sound_pitch 320
    sound S_TURRET_MGUN
    setp .sound_pitch 0
    setprojectile[P_LOVERBOY].workslike 1
ends

useractor enemy A_TURRET TURRET_HEALTH AC_TURRET_IDLE
    state turret_get_canisters
    ife counter 0
    {
        geta .ang ang_orig
        set ang_offset ang_orig
        rand turret_search 500
        set counter 1
    }
    state enemy_check_pause
    ife eps_return 1
        break
    ifaction AC_TURRET_DEAD
    {
        action AC_BASE
        geta .ang pivot_ang
        state enemy_die_cleartags
        cactor A_TURRETDEAD
        break
    }
    state turret_shock_spin
    
    geta .owner temp5
    state pup_damage_adjust
    ifg sprite.htextra 0
    {
        ifn temp5 -1 ifn temp5 THISACTOR ifn temp5 player.i
        {
            ife sprite[temp5].picnum A_SHOCKCANISTER_BROKE
                seta .htextra 1
            else ife sprite[temp5].picnum A_SHOCKCANISTER_DMG
                seta .htextra 1
            else ife sprite[temp5].picnum A_SHOCKCANISTER
                seta .htextra 1
        }
    }
    ifg tp_owner 0 ifge enemy_init 3
    {
        ifl turret_match 0
        {
            seta .htextra 1000
            seta .htpicnum P_SHOCKER
        }
    }
    ifhitweapon
    {
        geta .owner temp5
        ifn temp5 -1 ifn temp5 THISACTOR ifn temp5 player.i
        {
            ife sprite[temp5].picnum A_SHOCKCANISTER_BROKE
                seta .htpicnum P_SHOCKER
            else ife sprite[temp5].picnum A_SHOCKCANISTER_DMG
                seta .htpicnum P_SHOCKER
            else ife sprite[temp5].picnum A_SHOCKCANISTER
                seta .htpicnum P_SHOCKER
        }
        rand temp3 1
        add temp3 4
        for itervar range temp3
        {
            espawn A_GENERIC_DEBRIS
            setav[RETURN].debris_type DEBRIS_METAL
            seta[RETURN].pal sprite.pal
            geta .ang temp4
            rand temp4 2047
            seta[RETURN].ang temp4
            geta[RETURN].z temp4
            add temp4 1024
            seta[RETURN].z temp4
        }
        ifwasweapon P_SHOCKER
        {
            ife enemy_shocked 0
                seta .ang ang_offset
            else
                seta .ang temp6
            add enemy_shocked 1
            ifdead
                or p_wantline TALK_GIB
        }
        else
            seta .ang ang_offset
        ifwasweapon EXPLOSION
            ifle sprite.extra 60
                strength 0
        espawn A_SMOKE2
        geta .ang temp
        add temp 1024
        seta[RETURN].ang temp
        geta .z temp
        sub temp 2048
        seta[RETURN].z temp
        seta[RETURN].xvel 5
        ssp RETURN 0
        ifdead
        {
            ifrnd 32
                or p_wantline TALK_KILL
            rand temp3 6
            add temp3 10
            for itervar range temp3
            {
                espawn A_GENERIC_DEBRIS
                setav[RETURN].debris_type DEBRIS_METAL
                seta[RETURN].pal sprite.pal
                geta .ang temp4
                rand temp4 2047
                seta[RETURN].ang temp4
                geta[RETURN].z temp4
                sub temp4 2048
                seta[RETURN].z temp4
            }
            espawn A_EXPLOSION
            seta[RETURN].xrepeat 48
            seta[RETURN].yrepeat 48
            geta[RETURN].z temp
            add temp 4096
            seta[RETURN].z temp
            setav[RETURN].smoke_offset 2048
            action AC_TURRET_DEAD
            state enemy_die_resolve
            break
        }
    }
    set temp 0
    set temp2 0
    state calc_turret_fire_dist // by type
    ifn temp 0
    {
        ife temp 2
            nullop
        else
        {
            action AC_TURRET_IDLE
            set counter 1
            set turret_state 0
        }
        ifn temp 2
            break
    }
    ifn enemy_shocked 0
        break
    getp .i cansee_target
    set cansee_height 9728
    state cansee_actor
    
    state calc_turret_ang
    
    state turret_windup_state
    
    ifg counter 1
    {
        ifl counter 30
        {
            ife turret_state 1
                add counter 1
            ifl counter 10
                ifaction AC_TURRET_FIRE
                    action AC_TURRET_IDLE
        }
        else
        {
            ifaction AC_TURRET_IDLE
            {
                action AC_TURRET_FIRE
                set turret_interval 0
                sub turret_interval 8
                ifl turret_windup 60
                    set turret_windup 60
            }
        }
    }
    else
    {
        ifaction AC_TURRET_FIRE
                action AC_TURRET_IDLE
    }
    ifaction AC_TURRET_FIRE
    {
        ife e_mit_freq 0
        {
            state spawn_sound_emitter
            seta[RETURN].extra SE_DIST_MINIGUN
            add e_mit_freq 1
        }
        else ifge e_mit_freq 30
            set e_mit_freq 0
        add turret_interval 8
        ifg turret_interval turret_windup
            set turret_interval 0
        else
        {
            action AC_TURRET_FIRE
            break
        }
        ifactioncount 3
            resetactioncount
        else ifactioncount 2
            nullop
        else
        {
            state turret_shoot
            state spawn_sound_emitter
        }
    }
    geta .mdflags temp // this allows us to fix a bad shadow mirror from the back (see below)
    or temp 16
    seta .mdflags temp
enda

appendevent EVENT_ANIMATESPRITES
    ifactor A_TURRET
    {
        gettspr .tsprpicnum temp
        ife temp 7260
        {
            gettspr .tsprcstat temp2
            ifand temp2 4
                xor temp2 4
            settspr .tsprcstat temp2
        }
    }
endevent
// 7305 -5
// 7247 -14


eventloadactor A_BRUTE
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda
var brute_skipcircles 0 2
var brute_boss_num
var brute_boss_hp
defstate resize_brute
    geta .xrepeat temp
    mul temp 9
    shiftr temp 3
    seta .xrepeat temp
    geta .yrepeat temp
    mul temp 9
    shiftr temp 3
    seta .yrepeat temp
    set st_do_once 1
ends

appendevent EVENT_SPAWN
    switch sprite.picnum
        case A_BRUTE
            state clear_enemy_vels
            ifspritepal 2
                set brute_skipcircles 1
            else ifspritepal 3
                set brute_skipcircles 1
            sizeat 23 19
            ifn se_hitag 0
            {
                changespritestat THISACTOR STAT_ACTOR
                sleeptime 300
                set enemy_init 1
            }
            cstat 257
            ifspritepal 80
                state resize_brute
            else ifspritepal 87
                state resize_brute
            else
                spritepal PAL_BRUTE
            cactor A_BRUTE_BOTTOM
            espawn A_BRUTE_TOP
            seta[RETURN].pal sprite.pal
            setav[RETURN].tp_owner THISACTOR
            setav .tp_owner RETURN
            set temp4 tilesizy[A_BRUTE_BOTTOM]
            getp .max_actors_killed temp2
            sub temp2 2
            setp .max_actors_killed temp2
           // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
           // simplified to sizy*4*yrepeat
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            set temp2 sprite.z // this sequence is dumb but shifting and adding are the fastest ops to nudge things
            sub temp2 temp4
            shiftr temp4 2
            add temp2 temp4 
            shiftr temp4 2
            add temp2 temp4
            shiftr temp4 2
            add temp2 temp4
            seta[RETURN].z temp2
            break
        case A_BRUTE_TOP
            sizeat 23 19
            geta .hitag se_hitag
            seta .hitag 0
            cstat 257
            ifspritepal 80
                state resize_brute
            else ifspritepal 87
                state resize_brute
            else
                spritepal PAL_BRUTE
            break
        case A_BRUTE_TOP_DEAD
            sizeat 23 19
            cstat 256
            ifspritepal 80
                state resize_brute
            else ifspritepal 87
                state resize_brute
            else
                spritepal PAL_BRUTE
            break
        case A_BRUTE_BOTTOM_DEAD
            sizeat 23 19
            cstat 256
            ifspritepal 80
                state resize_brute
            else ifspritepal 87
                state resize_brute
            else
                spritepal PAL_BRUTE
            break
    endswitch
endevent


action AC_BRUTEBOTTOM_ROLL 0 3 9 1 4
action AC_BRUTEBOTTOM_STUNNED 0 3 9 1 1
action AC_BRUTEBOTTOM_ROLL_FAST 0 3 9 1 1
action AC_BRUTEBOTTOM_ZIGZAG 0 3 9 1 1
action AC_BRUTEBOTTOM_CIRCLE1 0 3 9 1 1
action AC_BRUTEBOTTOM_FIRE1 0 3 9 1 4
action AC_BRUTEBOTTOM_FIRE2 0 3 9 1 1
action AC_BRUTEBOTTOM_FIRE3 0 3 9 1 1

defstate brute_btm_cansee_target
    ife cansee_return 1 ife skip_see 0
    {
        ifand se_lotag 1
        {
            set cansee_return 0
            set enemy_cantsee 2
        }
        else
            set se_hitag 0
    }
    ife cansee_return 1
    {
        set enemy_cantsee 0
        set enemy_target player.i
        set way_current -1
        
    }
    else
    {
        sleeptime 300
        ifl enemy_cantsee 2
        {
            add enemy_cantsee 1
            set enemy_target player.i
            set enemy_idle_count enemy_cantsee
            set way_current -1
        }
        else
        {
            state find_waypoints
            ifn way_current -1
                ife sprite[way_current].extra -1
                    ife sprite[way_current].statnum STAT_WAYPOINT
                        set way_current -1
            ifn way_current -1
            {
                set enemy_cantsee 3
                set enemy_target way_current
                ifaction AC_BRUTEBOTTOM_ROLL_FAST
                    nullop
                else ifactioncount 3
                    action AC_BRUTEBOTTOM_ROLL_FAST
                set face_target enemy_target
                state face_actor
                seta .ang face_return
            }
            else
                set enemy_target player.i
        }
    }
ends

defstate brute_roam_chat_handler
    // init sounds when seen
    ife cansee_return 1
        set enemy_kathy 1
    ifg enemy_kathy 0
    {
        ifg enemy_chatty 0
            sub enemy_chatty 1
        else ife enemy_chatty 0
        {
            ifn enemy_kathy 1 // don't wait if we haven't played any yet
                set enemy_chatty 60
            ifrnd 64
            {
                rand temp 2
                add temp S_BRUTE_LAUGH_1
                ifn temp enemy_kathy
                {
                    set enemy_kathy temp
                    actorsound tp_owner temp

                    set enemy_chatty 120
                }
            }
            else ifrnd 32
            {
                rand temp 5
                add temp S_BRUTE_TAUNT_1
                ifn temp enemy_kathy
                {
                    set enemy_kathy temp
                    actorsound tp_owner temp

                    set enemy_chatty 120
                }
            }
        }
    }
ends

defstate brute_btm_dmg_adjust
    ifn sprite.htextra -1
    {
        ifn sprite.htowner -1
        {
            geta .htowner temp
            ife sprite[temp].picnum A_BRUTE_TOP
                seta .htextra -1
        }
        ifn sprite.htextra -1 ife sprite.htpicnum EXPLOSION
        {
            set temp sprite.htextra
            shiftr temp 1
            ife temp 0
                set temp 1
            seta .htextra temp
        }
        getav[tp_owner].enemy_minigun_dmg temp4
        ifg temp4 enemy_minigun_dmg
            set enemy_minigun_dmg temp4
        ife sprite.htowner player.i ife sprite.htpicnum BULLET
        {
            switch player.curr_weapon
                case WEAPON_LOVERBOY
                    set temp4 sprite.htextra
                    shiftr temp4 2
                    add enemy_minigun_dmg sprite.htextra
                    add enemy_minigun_dmg temp4
                    break
                case WEAPON_SHOTGUN
                    set temp4 sprite.htextra
                    shiftr temp4 2
                    add enemy_minigun_dmg temp4
                    break
            endswitch
        }
        add enemy_minigun_dmg sprite.htextra
    }
    else ifg sprite.extra 0
    {
        set temp5 enemy_minigun_dmg
        shiftr temp5 3
        sub enemy_minigun_dmg temp5
        clamp enemy_minigun_dmg 0 65536
    }
ends

defstate brute_btm_push_player
    ldist temp player.i THISACTOR
    ifl temp 640
    {
        set temp4 tilesizy[A_BRUTE_TOP]
        shiftl temp4 2
        mul temp4 sprite[tp_owner].yrepeat
        set temp2 sprite[tp_owner].z
        sub temp2 temp4
        getp .i temp3
        ifle player.posz sprite.z ifge sprite[temp3].z temp2 // when the player is too close we should shove them away
        {
            sub temp 800
            getp .i temp2
            geta .x face_x
            sub face_x sprite[temp2].x

            geta .y face_y
            sub face_y sprite[temp2].y

            getangle face_return face_x face_y
            add face_return 1024
            and face_return 2047
            
            set move_v temp
            sub move_v 1536
            abs move_v
            cos move_xv face_return
            sin move_yv face_return
            mul move_xv move_v
            mul move_yv move_v
            shiftr move_xv 4
            shiftr move_yv 4
            switch sprite.pal
                case 80
                case 87
                    break
                default
                    shiftr move_xv 1
                    shiftr move_yv 1
                    break
            endswitch
            add move_xv player.posxv
            add move_yv player.posyv
            setp .posxv move_xv
            setp .posyv move_yv
        }
    }
ends

action AC_BRUTEBOTTOM_BASE 0 1 9 1 1
useractor enemy A_BRUTE BRUTE_HEALTH AC_BRUTEBOTTOM_BASE
enda

var bruteshocksound 0 2
var brutelastattack 0 2
var brutetopseeplayer 0 2

useractor notenemy A_BRUTE_BOTTOM_DEAD 0 AC_BASE
    ifand sprite.cstat 4
        cstat 4
    else
        cstat 0
    fall
    set actor_gib 2
    changespritestat THISACTOR STAT_STATIC_GIB
enda

useractor enemy A_BRUTE_BOTTOM BRUTE_HEALTH AC_BRUTEBOTTOM_BASE
    clipdist 64
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
    }
    else ifg enemy_skipshade 0
        sub enemy_skipshade 1
    else
        set enemy_skipshade 0
    ifl st_do_once 2
    {
        ifspritepal 80
            state resize_brute
        else ifspritepal 87
            state resize_brute
        ife st_do_once 1
        {
            set temp BRUTALBOSS_HEALTH
            shiftr temp 1
            seta .extra temp
            set enemy_init_hp temp
            ifg tp_owner -1
            {
                seta[tp_owner].pal sprite.pal
                seta[tp_owner].xrepeat sprite.xrepeat
                seta[tp_owner].yrepeat sprite.yrepeat
                seta[tp_owner].extra sprite.extra
            }
            add brute_boss_num 1
            ife brute_boss_num 1
                set boss_currhp temp
            else
                add boss_currhp temp
            set brute_boss_hp boss_currhp
            set boss_type 2
        }
        set st_do_once 2
    }
    set temp 0
    ifspritepal 87
        set temp 1
    ifspritepal 80
        set temp 1
    ife temp 1
        ifl boss_fillhp 100
        {
            ifl brute_boss_hp BRUTALBOSS_HEALTH
                add boss_fillhp 2
            else
                add boss_fillhp 1
            ifl boss_fillhp 96
                ifand boss_fillhp 4
                    soundonce S_PCBEEP
        }
    fall
    set cansee_target player.i
    set cansee_height 4096
    state cansee_actor
    getav[tp_owner].brutetopseeplayer temp
    ifg temp 0
        set cansee_return 1
    
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break

    state e_wakemeup
    
    state enemy_check_init
    switch sprite.pal
        case 80
        case 87
            set enemy_init_return 0
            set enemy_init 1
            sleeptime 300
            break
    endswitch
    ife enemy_init_return 1
        break
    ife skip_see 1
    {
        set cansee_return 0
        set enemy_cantsee 2
    }
    state brute_btm_cansee_target
       
    state brute_roam_chat_handler
    
    ife enemy_minigun_dmg -30
    {
        action AC_BRUTEBOTTOM_STUNNED
        set enemy_minigun_dmg 0
    }
    state pup_damage_adjust
    state brute_btm_dmg_adjust
    
    ifaction AC_BRUTEBOTTOM_STUNNED
    {
        ifactioncount 5
            nullop
        else
        {
            espawn A_SMOKE2
            rand temp2 8
            add temp2 8
            seta[RETURN].xrepeat temp2
            seta[RETURN].yrepeat temp2
            seta[RETURN].cstat 32768
            rand temp2 2047
            seta[RETURN].ang temp2
            rand temp2 512
            seta[RETURN].xvel temp2
            rand temp2 -1024
            sub temp2 1024
            seta[RETURN].zvel temp2
            ssp RETURN 0
        }
        set move_v sprite.htg_t 2
        clamp move_v 0 10
        shiftl move_v 1
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        set enemy_minigun_dmg 0
        setav[tp_owner].enemy_minigun_dmg 0
        ifactioncount 10
            action AC_BRUTEBOTTOM_ROLL
    }
    geta .htextra temp3
    ifhitweapon
    {
        switch sprite.pal
            case 80
            case 87
                set boss_hpflash 24
                sub boss_currhp temp3
                break
        endswitch
        /* redefinequote 11 %ld
        qsprintf 11 11 enemy_minigun_dmg
        quote 11 */
        ifl sprite.extra sprite[tp_owner].extra
            seta[tp_owner].extra sprite.extra
        else
            seta .extra sprite[tp_owner].extra
        rand temp 2
        add temp 2
        for itervar range temp
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 120 // sparks
            seta[RETURN].pal 6

            rand temp2 512
            ifrnd 127
                inv temp2
            add temp2 sprite.htang
            add temp2 1024
            seta[RETURN].ang temp2


            geta .picnum temp2
            set temp4 tilesizy[temp2]
           // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
           // simplified to sizy*4*yrepeat
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            set temp2 sprite.z
            rand temp3 temp4
            sub temp2 temp3
            seta[RETURN].z temp2

            rand temp2 256
            ifrnd 127
                inv temp2
            add temp2 sprite.x
            seta[RETURN].x temp2
            rand temp2 256
            ifrnd 127
                inv temp2
            add temp2 sprite.y
            seta[RETURN].y temp2
        }
        setp .sound_pitch 640
        sound S_AMB_NEONFLICKR02
        setp .sound_pitch 0
        set bruteshocksound 30
        switch sprite.pal
            case 80
            case 87
                set temp3 50
                break
            default
                set temp3 70
                break
        endswitch
        ifge enemy_minigun_dmg temp3
        {
            action AC_BRUTEBOTTOM_STUNNED
            setav[tp_owner].enemy_minigun_dmg -30
            set enemy_minigun_dmg 0
            setp .sound_pitch 64
            rand temp 1
            add temp S_BRUTE_GRUNT_1
            actorsound tp_owner temp
            setp .sound_pitch 0
        }
        else
        {
            ifrnd 127
            {
                rand temp 1
                add temp S_BRUTE_GRUNT_1
                actorsound tp_owner temp
            }
        }
    }
    ifg bruteshocksound 0
    {
        sub bruteshocksound 1
        ife bruteshocksound 0
        {
            stopactorsound THISACTOR S_AMB_NEONFLICKR02
        }
    }
    ifdead
    {
        switch sprite.pal
            case 80
            case 87
                ifdead
                {
                    sub brute_boss_num 1
                    set temp brute_boss_num
                    mul temp enemy_init_hp
                    ifg boss_currhp temp
                        set boss_currhp temp
                }
                ifle boss_currhp 0
                {
                    set boss_currhp 0
                    set boss_fillhp 0
                    ife VOLUME EP_MAIN
                        ife LEVEL EP_MAIN_ZONE_4_END
                            or cheevo_tracker 16
                }
                break
        endswitch
        espawn A_EXPLOSION
        seta[RETURN].xrepeat 32
        seta[RETURN].yrepeat 32
        state enemy_die_resolve
        stopactorsound THISACTOR S_BRUTE_MOVE
        espawn A_BRUTE_BOTTOM_DEAD
        seta[RETURN].pal sprite.pal
        seta[RETURN].xrepeat sprite.xrepeat
        seta[RETURN].pal sprite.pal
        seta[RETURN].yrepeat sprite.yrepeat
        killit
    }
    else
    {
        switch sprite.pal
            case 80
            case 87
                ifl boss_currhp sprite.extra
                    set boss_currhp sprite.extra
                break
        endswitch
    }
    ifaction AC_BRUTEBOTTOM_BASE
        ife enemy_target player.i
            ifrnd 64
                action AC_BRUTEBOTTOM_ROLL
    ifaction AC_BRUTEBOTTOM_ROLL
    {
        ifpdistl 6144
            ifrnd 64
                action AC_BRUTEBOTTOM_ROLL_FAST
        set move_v sprite.htg_t 2
        clamp move_v 0 10
        shiftl move_v 1
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        set att_target enemy_target
        set att_noclamp 1
        state angle_to_target
        set temp att_return
        shiftr temp 4
        set temp2 temp
        abs temp2

        ife temp 0 ifn att_return 0
        {
            set temp 1
            ifl att_return 0
                inv temp
        }
        geta .ang temp2
        sub temp2 temp
        and temp2 2047
        seta .ang temp2
    }
    ifaction AC_BRUTEBOTTOM_ROLL_FAST
    {
        ifpdistl 6144
            nullop
        else
            ifrnd 64 ife enemy_target player.i
                action AC_BRUTEBOTTOM_ROLL
        set move_v sprite.htg_t 2
        clamp move_v 0 10
        switch sprite.pal
            case 80
            case 87
                  ifrnd 16
                    shiftl move_v 1
                break
        endswitch
        shiftl move_v 4
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ifpdistl 800 ife enemy_target player.i
        {
            set enemy_xv 0
            set enemy_yv 0
        }
        state enemy_do_move
        set att_target enemy_target
        set att_noclamp 1
        state angle_to_target
        set temp att_return
        shiftr temp 3
        set temp2 temp
        abs temp2
        ife temp 0 ifn att_return 0
        {
            set temp 1
            ifl att_return 0
                inv temp
        }
        geta .ang temp2
        sub temp2 temp
        and temp2 2047
        seta .ang temp2
        ifpdistl 5120 ife enemy_target player.i
        {
            ifrnd 32 ife brute_skipcircles 0
            {
                ifpdistl 1024
                {
                    ifrnd 32
                        action AC_BRUTEBOTTOM_CIRCLE1
                }
                else
                    action AC_BRUTEBOTTOM_CIRCLE1
            }
            ifpdistl 4096
                ifrnd 32
                    action AC_BRUTEBOTTOM_ZIGZAG
        }
    }
    ifaction AC_BRUTEBOTTOM_ZIGZAG
    {
        set move_v sprite.htg_t 2
        clamp move_v 0 8
        set att_target enemy_target
        set att_noclamp 1
        state angle_to_target
        set temp att_return
        shiftr temp 4
        set temp2 temp
        abs temp2
        ife temp 0 ifn att_return 0
        {
            set temp 1
            ifl att_return 0
                inv temp
        }
        geta .ang temp2
        sub temp2 temp
        and temp2 2047
        seta .ang temp2
        set se_ang temp2

        shiftl move_v 4
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        set move_v sprite.htg_t 2
        
        
        set temp se_ang
        
        ifge counter 0
        {
            add counter 1
            ifg counter 15
                add temp 16
            else
                sub temp 16
            ife counter 30
                set counter -1
        }
        else
        {
            sub counter 1
            ifg counter -15
                add temp 16
            else
                sub temp 16
            ife counter -30
                set counter 0
        }

        and temp 2047
        seta .ang temp
        set se_ang temp
        ifactioncount 120
            action AC_BRUTEBOTTOM_ROLL_FAST
        else ifactioncount 60
            ifrnd 16
                action AC_BRUTEBOTTOM_ROLL_FAST
    }
    
    ifaction AC_BRUTEBOTTOM_CIRCLE1
    {
        ifpdistl 6144
            nullop
        else
            ifrnd 64
                action AC_BRUTEBOTTOM_ROLL
        set move_v sprite.htg_t 2
        ifle move_v 1
            rand counter 1
        clamp move_v 0 8
        shiftl move_v 4
        switch sprite.pal
            case 80
            case 87
                  ifrnd 16
                    shiftl move_v 1
                break
        endswitch
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        set face_target enemy_target
        state face_actor
        set temp2 face_return

        ife counter 1
            add temp2 256
        else
            sub temp2 256
        ifpdistl 3072
        {
            ife counter 1
                add temp2 128
            else
                sub temp2 128
        }
        and temp2 2047
        seta .ang temp2
        ifpdistl 1024
            ifrnd 32
                action AC_BRUTEBOTTOM_ROLL_FAST
        ifactioncount 150
            action AC_BRUTEBOTTOM_ROLL_FAST
        else ifactioncount 120
            ifrnd 32
                action AC_BRUTEBOTTOM_ROLL_FAST
    }
    ife enemy_target player.i ife cansee_return 1 
    {
        set temp3 0
        ifpdistl 1536
            set temp3 1
        switch sprite.pal
            case 80
            case 87
                ifpdistl 2048
                    set temp3 1
                break
        endswitch
        ife temp3 1
            set temp 16
        else
        {
            set temp brutelastattack
            shiftr temp 5
            clamp temp 0 4
            add temp 4
            switch sprite.pal
                case 80
                case 87
                      sub temp 4
                      clamp temp 1 8
                    break
            endswitch
        }
        rand temp3 255
        ifaction AC_BRUTEBOTTOM_FIRE1
            nullop
        else ifaction AC_BRUTEBOTTOM_FIRE2
            nullop
        else ifaction AC_BRUTEBOTTOM_FIRE3
            nullop
        else ifle temp3 temp
        {
            set brutelastattack 0
            ife brute_skipcircles 0
                rand counter 2
            else
                rand counter 1
            switch counter
                case 0
                    action AC_BRUTEBOTTOM_FIRE1
                    break
                case 1
                    action AC_BRUTEBOTTOM_FIRE2
                    break
                case 2
                    action AC_BRUTEBOTTOM_FIRE3
                    break
            endswitch
            setav[tp_owner].enemy_shoot 1
        }
    }
    ifaction AC_BRUTEBOTTOM_FIRE1
    {
        set move_v sprite.htg_t 2
        clamp move_v 0 8
        shiftl move_v 4
        ifactioncount 16
            nullop
        else
            inv move_v
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ifpdistl 1024
        {
            set enemy_xv 0
            set enemy_yv 0
        }
        state enemy_do_move
        set att_target enemy_target
        set att_noclamp 1
        state angle_to_target
        set temp att_return
        shiftr temp 3
        set temp2 temp
        abs temp2
        ife temp 0 ifn att_return 0
        {
            set temp 1
            ifl att_return 0
                inv temp
        }
        ifle temp2 8
            set temp att_return
        ifl move_v 0
        {
            add temp 256
            inv temp
        }
        else
            sub temp 256
        ifpdistl 1204
        {
            set face_target enemy_target
            state face_actor
            seta .ang face_return
        }
        else 
        {
            geta .ang temp2
            shiftr temp 8
            sub temp2 temp
            and temp2 2047
            seta .ang temp2
        }
        getav[tp_owner].enemy_shoot temp
        ife temp 0
            action AC_BRUTEBOTTOM_ROLL
    }
    ifaction AC_BRUTEBOTTOM_FIRE2
    {
        set move_v sprite.htg_t 2
        clamp move_v 0 8
        shiftl move_v 3
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ifpdistl 1024
        {
            set enemy_xv 0
            set enemy_yv 0
        }
        state enemy_do_move
        set att_target enemy_target
        set att_noclamp 1
        state angle_to_target
        set temp att_return
        shiftr temp 3
        set temp2 temp
        abs temp2
        ife temp 0 ifn att_return 0
        {
            set temp 1
            ifl att_return 0
                inv temp
        }
        ifle temp2 8
            set temp att_return
        else ifpdistl 1204
        {
            set face_target enemy_target
            state face_actor
            seta .ang face_return
        }
        else
        {
            geta .ang temp2
            sub temp2 temp
            and temp2 2047
            seta .ang temp2
        }
        getav[tp_owner].enemy_shoot temp
        ife temp 0
            action AC_BRUTEBOTTOM_ROLL
    }
    ifaction AC_BRUTEBOTTOM_FIRE3
    {
        set move_v sprite.htg_t 2
        ifle move_v 1
            rand counter 1
        clamp move_v 0 8
        shiftl move_v 4
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ifpdistl 800
        {
            set enemy_xv 0
            set enemy_yv 0
        }
        state enemy_do_move
        set face_target enemy_target
        state face_actor
        set temp2 face_return

        ife counter 1
            add temp2 256
        else
            sub temp2 256
        ifpdistl 3072
        {
            ife counter 1
                add temp2 128
            else
                sub temp2 128
        }
        and temp2 2047
        seta .ang temp2
        getav[tp_owner].enemy_shoot temp
        ife temp 0
            action AC_BRUTEBOTTOM_ROLL
    }
    
    set temp enemy_xv
    abs temp
    set temp2 enemy_yv
    abs temp2
    add temp temp2
    ifn temp 0
        ifpdistl 12288
            soundonce S_BRUTE_MOVE

    state brute_btm_push_player
enda

action AC_BRUTETOP_BASE 0 1 8 1 1 1
action AC_BRUTETOP_STUNNED 104 1 8 1 1 1
action AC_BRUTETOP_AIM 16 1 8 1 1 1
action AC_BRUTETOP_SHOOT 16 3 8 1 12 1
action AC_BRUTETOP_SWIPE1_FW 40 4 8 1 12 1
action AC_BRUTETOP_SWIPE1_BW 64 4 8 -1 12 1
action AC_BRUTETOP_SWIPE2_FW 72 4 8 1 12 1
action AC_BRUTETOP_SWIPE2_BW 104 4 8 -1 12 1
action AC_BRUTETOP_SHOCKED 104 2 8 1 1 1

action AC_BRUTETOP_FLY  -6 7 1 1 4
action AC_BRUTETOP_DEAD 0 1 1 1 1
useractor notenemy A_BRUTE_TOP_DEAD CORPSE_HEALTH AC_BRUTETOP_DEAD
    ifl sprite.htg_t 0 10
        seta .htextra -1
    ifge counter3 3
    {
        ife counter3 3
        {
            action AC_BRUTETOP_FLY
            set face_target player.i
            state face_actor
            rand temp 480
            ifrnd 127
                inv temp
            add temp face_return
            and temp 2047
            seta .ang face_return
            set counter3 4
            rand counter 1024
            sub counter 8192
            
            rand counter2 32
            add counter2 256
        }
        cstat 256
        seta .xvel counter2
        ifl sprite.htg_t 2 5
            seta .zvel counter
        shiftr counter 2
        ifg counter2 0
            sub counter2 2
        ssp THISACTOR CLIPMASK0
        seta .xvel 0
        ifl sprite.htg_t 2 5
            seta .zvel 0
    }
    ifaction AC_BRUTETOP_FLY
        ifactioncount 7
        {
            action AC_BRUTETOP_DEAD
            set counter3 0
        }
    state enemy_body_code
enda
useractor enemy A_BRUTE_TOP BRUTE_HEALTH AC_BRUTETOP_BASE
    clipdist 64
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
    }
    else ifg enemy_skipshade 0
        sub enemy_skipshade 1
    else
        set enemy_skipshade 0
    ife st_do_once 0
    {
        ifspritepal 80
            state resize_brute
        else ifspritepal 87
            state resize_brute
        set st_do_once 2
    }
    ifspritepal 80
    {
        ifg boss_hpflash 0
            sub boss_hpflash 1
    }
    else ifspritepal 87
    {
        ifg boss_hpflash 0
            sub boss_hpflash 1
    }
    set cansee_target player.i
    set cansee_height 8192
    state cansee_actor
    
    state enemy_do_target_icon
    ife cansee_return_o 1
        state enemy_checkw1alt
    geta[tp_owner].htdispicnum temp
    set temp4 tilesizy[temp]
    shiftl temp4 2
    mul temp4 sprite[tp_owner].yrepeat
    set temp2 sprite[tp_owner].z
    sub temp2 temp4
    shiftr temp4 2
    add temp2 temp4 
    shiftr temp4 2
    add temp2 temp4
    shiftr temp4 2
    add temp2 temp4
    seta .z temp2
    ifn sprite[tp_owner].statnum STAT_MAXSTATUS
        seta .sectnum sprite[tp_owner].sectnum
    state enemy_check_init
    ife enemy_init_return 1
        break
    ife cansee_return 1
        set brutetopseeplayer 2
    else ifg brutetopseeplayer 0
        sub brutetopseeplayer 1
    ife enemy_minigun_dmg -30
    {
        action AC_BRUTETOP_STUNNED
        set enemy_minigun_dmg 0
    }
    state pup_damage_adjust
    ifn sprite.htextra -1
    {
        ifn sprite.htowner -1
        {
            geta .htowner temp
            ife sprite[temp].picnum A_BRUTE_TOP
                seta .htextra -1
        }
        ifn sprite.htextra -1 ife sprite.htpicnum EXPLOSION
        {
            set temp sprite.htextra
            shiftr temp 1
            ife temp 0
                set temp 1
            seta .htextra temp
        }
        getav[tp_owner].enemy_minigun_dmg temp4
        ifg temp4 enemy_minigun_dmg
            set enemy_minigun_dmg temp4
        ife sprite.htowner player.i ife sprite.htpicnum BULLET
        {
            switch player.curr_weapon
                case WEAPON_LOVERBOY
                    set temp4 sprite.htextra
                    ifn weapon1_alt 0
                    {
                        mul temp4 3
                        shiftr temp4 1
                        seta .htextra temp4
                    }
                    shiftr temp4 2
                    add enemy_minigun_dmg sprite.htextra
                    add enemy_minigun_dmg temp4
                    mul temp4 5
                    seta .htextra temp4
                    break
                case WEAPON_SHOTGUN
                    set temp4 sprite.htextra
                    shiftr temp4 2
                    add enemy_minigun_dmg temp4
                    break
            endswitch
        }
        add enemy_minigun_dmg sprite.htextra
    }
    else ifg sprite.extra 0
    {
        set temp5 enemy_minigun_dmg
        shiftr temp5 3
        clamp temp5 1 65536
        sub enemy_minigun_dmg temp5
        clamp enemy_minigun_dmg 0 65536
    }
    ifaction AC_BRUTETOP_STUNNED
    {
        ifactioncount 5
            nullop
        else
        {
            espawn A_SMOKE2
            rand temp2 8
            add temp2 8
            seta[RETURN].xrepeat temp2
            seta[RETURN].yrepeat temp2
            seta[RETURN].cstat 32768
            rand temp2 2047
            seta[RETURN].ang temp2
            rand temp2 256
            seta[RETURN].xvel temp2
            rand temp2 -4096
            seta[RETURN].zvel temp2
            ssp RETURN 0
        }
        setav[tp_owner].enemy_minigun_dmg 0
        set enemy_minigun_dmg 0
        ifactioncount 10
            action AC_BRUTETOP_BASE
    }
    
    geta .htextra temp3
    ifhitweapon
    {
        ifwasweapon P_SHOCKER
        {
            add enemy_shocked 1
            ifg enemy_shocked 3
                set enemy_shocked 1
            set temp2 temp3
            mul temp2 enemy_shocked
            shiftl temp2 2

            add temp3 temp2
            geta .extra temp4
            sub temp4 temp2
            seta .extra temp4
        }
        else ifwasweapon P_PLASMA_BOLT
            ife enemy_shocked 0
                set enemy_shocked -1
        switch sprite.pal
            case 80
            case 87
                set boss_hpflash 24
                sub boss_currhp temp3
                break
        endswitch
        /* redefinequote 11 %ld
        qsprintf 11 11 enemy_minigun_dmg
        quote 11 */
        ifl sprite.extra sprite[tp_owner].extra
            seta[tp_owner].extra sprite.extra
        else
            seta .extra sprite[tp_owner].extra
        rand temp 2
        add temp 2
        for itervar range temp
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 120
            seta[RETURN].pal 6

            rand temp2 512
            ifrnd 127
                inv temp2
            add temp2 sprite.htang
            add temp2 1024
            seta[RETURN].ang temp2


            geta .picnum temp2
            set temp4 tilesizy[temp2]
           // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
           // simplified to sizy*4*yrepeat
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            set temp2 sprite.z
            rand temp3 temp4
            sub temp2 temp3
            seta[RETURN].z temp2

            rand temp2 256
            ifrnd 127
                inv temp2
            add temp2 sprite.x
            seta[RETURN].x temp2
            rand temp2 256
            ifrnd 127
                inv temp2
            add temp2 sprite.y
            seta[RETURN].y temp2
        }
        setp .sound_pitch 640
        sound S_AMB_NEONFLICKR02
        setp .sound_pitch 0
        set bruteshocksound 30
        ifge enemy_minigun_dmg 70
        {
            action AC_BRUTETOP_STUNNED
            setav[tp_owner].enemy_minigun_dmg -30
            set enemy_minigun_dmg 0
            setp .sound_pitch 64
            rand temp 1
            add temp S_BRUTE_GRUNT_1
            soundvar temp
            setp .sound_pitch 0
        }
        else
        {
            ifrnd 127
            {
                rand temp 1
                add temp S_BRUTE_GRUNT_1
                soundvar temp
            }
        }
    }
    
    ifn enemy_shocked 0
    {
        ifaction AC_BRUTETOP_SHOCKED
        {
            ifand sprite.htg_t 2 1
            {
                seta .shade -127
                set enemy_skipshade 1
                ifn tp_owner -1
                {
                    seta[tp_owner].shade -127
                    setav[tp_owner].enemy_skipshade 2
                }
            }
            stopactorsound THISACTOR S_BRUTE_CHAINSAW
            set temp enemy_shocked
            mul temp 20
            ifl temp 0
            {
                abs temp
                shiftr temp 2
            }
            rand temp7 3
            setp .sound_pitch 640
            soundonce S_AMB_NEONFLICKR02
            setp .sound_pitch 0
            set bruteshocksound 30
            for itervar range temp7
            {
                espawn A_GENERIC_PARTICLE
                seta[RETURN].xrepeat 120
                seta[RETURN].pal 6

                rand temp2 512
                ifrnd 127
                    inv temp2
                add temp2 sprite.htang
                add temp2 1024
                seta[RETURN].ang temp2


                geta .picnum temp2
                set temp4 tilesizy[temp2]
               // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
               // simplified to sizy*4*yrepeat
                shiftl temp4 2
                mul temp4 sprite.yrepeat
                set temp2 sprite.z
                rand temp3 temp4
                sub temp2 temp3
                seta[RETURN].z temp2

                rand temp2 256
                ifrnd 127
                    inv temp2
                add temp2 sprite.x
                seta[RETURN].x temp2
                rand temp2 256
                ifrnd 127
                    inv temp2
                add temp2 sprite.y
                seta[RETURN].y temp2
            }
            ifn tp_owner -1
            {
                geta[tp_owner].ang temp2
                rand temp3 256
                ifrnd 127
                    inv temp3
                add temp2 temp3
                and temp2 2047
                seta[tp_owner].ang temp2
            }
            ifge sprite.htg_t 2 temp
            {
                action AC_BRUTETOP_BASE
                set enemy_shocked 0
            }
            ifdead
                nullop
            else
                break
        }
        else
            action AC_BRUTETOP_SHOCKED
            
    }
    
    ifg bruteshocksound 0
    {
        sub bruteshocksound 1
        ife bruteshocksound 0
            stopactorsound THISACTOR S_AMB_NEONFLICKR02
    }
    ifdead
    {
        stopactorsound THISACTOR S_AMB_NEONFLICKR02
        state enemy_clearw1alt
        espawn A_EXPLOSION
        seta[RETURN].xrepeat 32
        seta[RETURN].yrepeat 32
        sound S_BRUTE_DIE_1
        stopactorsound THISACTOR S_BRUTE_LAUGH_1
        stopactorsound THISACTOR S_BRUTE_LAUGH_2
        stopactorsound THISACTOR S_BRUTE_LAUGH_3
        stopactorsound THISACTOR S_BRUTE_GRUNT_1
        stopactorsound THISACTOR S_BRUTE_GRUNT_2
        stopactorsound THISACTOR S_BRUTE_GRUNT_3
        stopactorsound THISACTOR S_BRUTE_TAUNT_1
        stopactorsound THISACTOR S_BRUTE_TAUNT_2
        stopactorsound THISACTOR S_BRUTE_TAUNT_3
        stopactorsound THISACTOR S_BRUTE_TAUNT_4
        stopactorsound THISACTOR S_BRUTE_TAUNT_5
        stopactorsound THISACTOR S_BRUTE_TAUNT_6
        sound S_GIBSPLODE02
        sound S_GIBSPLODE03
        espawn A_BRUTE_TOP_DEAD
        setav[RETURN].counter3 3
        seta[RETURN].cstat 32768
        seta[RETURN].pal sprite.pal
        seta[RETURN].xrepeat sprite.xrepeat
        seta[RETURN].pal sprite.pal
        seta[RETURN].yrepeat sprite.yrepeat
        killit
    }
    ifn enemy_shoot 0
    {
        set att_target player.i
        set att_noclamp 1
        state angle_to_target
        set temp att_return
        shiftr temp 2
        set temp2 temp
        abs temp2
        ife temp 0 ifn att_return 0
        {
            set temp 1
            ifl att_return 0
                inv temp
        }
        geta .ang temp2
        sub temp2 temp
        and temp2 2047
        seta .ang temp2
        set temp3 0
        rand temp4 255
        
        ifspritepal 80
            shiftl temp4 1
        else ifspritepal 87
            shiftr temp4 1
        ifle temp4 200
        {
            ifpdistl 1536
                set temp3 1
            switch sprite.pal
                case 80
                case 87
                    ifpdistl 2048
                        set temp3 1
                    break
            endswitch
        }
        ife temp3 1
        {
            ifaction AC_BRUTETOP_AIM
                nullop
            else ife enemy_shoot 1
            {
                ifaction AC_BRUTETOP_SWIPE1_FW
                    nullop
                else ifaction AC_BRUTETOP_SWIPE2_FW
                    nullop
                else
                {
                    ifrnd 127
                    {
                        set temp BRUTE_HEALTH
                        shiftl temp 1
                        ifl sprite.extra temp 
                            setp .sound_pitch 256
                        sound S_BRUTE_GRUNT_3
                        setp .sound_pitch 0
                    }
                    sound S_BRUTE_CHAINSAW
                    set enemy_shoot -1
                    ifrnd 127
                        action AC_BRUTETOP_SWIPE1_FW
                    else
                        action AC_BRUTETOP_SWIPE2_FW
                }
            }
            
        }
        ife enemy_shoot 1
        {
            ifaction AC_BRUTETOP_AIM
                nullop
            else
                action AC_BRUTETOP_AIM
            ifactioncount 8
            {
                set enemy_shoot 2
                action AC_BRUTETOP_SHOOT
            }
        }
        else ifg enemy_shoot 0
        {
            add enemy_shoot 1
            ifpdistl 1536
            {
                geta .z temp
                add temp 1024
                seta .z temp
            }
            switch enemy_shoot
                case 14
                case 26
                    ife enemy_shoot 26 ifrnd 64
                    {
                        set temp BRUTE_HEALTH
                        shiftr temp 1
                        ifl sprite.extra temp
                        { 
                            setp .sound_pitch 256
                            sound S_BRUTE_GRUNT_3
                            setp .sound_pitch 0
                        }
                    }
                    seta .shade -127
                    set enemy_skipshade 2
                    ifn tp_owner -1
                    {
                        seta[tp_owner].shade -127
                        setav[tp_owner].enemy_skipshade 2
                    }
                    getprojectile[P_NAPALM_BALL].extra temp3
                    getprojectile[P_NAPALM_BALL].extra_rand temp4
                    set temp temp3
                    shiftr temp 1
                    setprojectile[P_NAPALM_BALL].extra temp
                    set temp temp4
                    shiftr temp 1
                    setprojectile[P_NAPALM_BALL].extra_rand temp
                    shoot P_NAPALM_BALL
                    setp .sound_pitch -256
                    sound S_GRENADE_LAUNCH
                    setp .sound_pitch 0
                    setprojectile[P_NAPALM_BALL].extra temp3
                    setprojectile[P_NAPALM_BALL].extra_rand temp4
                    break
            endswitch
            ifpdistl 1536
            {
                geta .z temp
                sub temp 1024
                seta .z temp
            }
            ifactioncount 6
            {
                action AC_BRUTETOP_BASE
                set enemy_shoot 0
            }
        }
        else ifl enemy_shoot 0
        {
            set temp3 0
            ifpdistl 1536
                set temp3 1
            switch sprite.pal
                case 80
                case 87
                    ifpdistl 2048
                        set temp3 1
                    break
            endswitch
            sub enemy_shoot 1
            switch enemy_shoot
                case -14
                case -26
                    set att_target player.i
                    state angle_to_target
                    ifle att_return 128 ife temp3 1
                        addphealth -10
                    break
            endswitch
            ifactioncount 3
            {
                ifaction AC_BRUTETOP_SWIPE1_FW
                {
                    action AC_BRUTETOP_SWIPE1_BW
                    sound S_BRUTE_CHAINSAW2
                }
                else ifaction AC_BRUTETOP_SWIPE2_FW
                {
                    action AC_BRUTETOP_SWIPE2_BW
                    sound S_BRUTE_CHAINSAW2
                }
                else ifactioncount 4
                {
                    action AC_BRUTETOP_BASE
                    set enemy_shoot 0
                }
            }
        }
        
        
        
    }
    else
    {
        geta[tp_owner].ang temp
        seta .ang temp
    }
    seta .x sprite[tp_owner].x
    seta .y sprite[tp_owner].y
    
    set face_target player.i
    state face_actor
    geta .ang temp
    seta .ang face_return
    set move_v 16
    state move_actor
    add move_xv sprite[tp_owner].x
    add move_yv sprite[tp_owner].y
    seta .x move_xv
    seta .y move_yv
    seta .htbposx move_xv
    seta .htbposy move_yv
    seta .ang temp
    geta .mdflags temp
    or temp 16
    seta .mdflags temp
    geta[tp_owner].mdflags temp
    or temp 16
    seta[tp_owner].mdflags temp
enda

appendevent EVENT_ANIMATESPRITES
    ifactor A_BRUTE_BOTTOM
    {
        gettspr .tsprpicnum temp
        set temp4 tilesizy[temp]
       // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
       // simplified to sizy*4*yrepeat
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        geta .z temp
        sub temp temp4
        shiftr temp4 2
        add temp temp4 
        shiftr temp4 2
        add temp temp4
        shiftr temp4 2
        add temp temp4
        ifn tp_owner -1
        {
            seta[tp_owner].z temp
            gettspr .tsprx temp
            seta[tp_owner].x temp
            gettspr .tspry temp
            seta[tp_owner].y temp
            
            set face_target player.i
            state face_actor
            geta .ang temp
            seta .ang face_return
            set move_v 16
            state move_actor
            add move_xv sprite[tp_owner].x
            add move_yv sprite[tp_owner].y
            seta[tp_owner].x move_xv
            seta[tp_owner].y move_yv
            seta[tp_owner].htbposx move_xv
            seta[tp_owner].htbposy move_yv
            seta .ang temp
            gettspr .tsprsectnum temp
            seta[tp_owner].sectnum temp
        }
    }
    else ifactor A_BRUTE_TOP
    {
        geta[tp_owner].htdispicnum temp
        set temp4 tilesizy[temp]
       // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
       // simplified to sizy*4*yrepeat
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        geta[tp_owner].z temp
       sub temp temp4
        shiftr temp4 2
        add temp temp4 
        shiftr temp4 2
        add temp temp4
        shiftr temp4 2
        add temp temp4
        seta .z temp
        seta .x sprite[tp_owner].x
        seta .y sprite[tp_owner].y
        
        set face_target player.i
        state face_actor
        geta .ang temp
        seta .ang face_return
        set move_v 16
        state move_actor
        add move_xv sprite[tp_owner].x
        add move_yv sprite[tp_owner].y
        seta .x move_xv
        seta .y move_yv
        seta .htbposx move_xv
        seta .htbposy move_yv
        seta .ang temp
        seta .sectnum sprite[tp_owner].sectnum
    }
endevent

eventloadactor A_DRONE
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda

appendevent EVENT_SPAWN
    switch sprite.picnum
        case A_DRONE
            ifspritepal 9 // legacy
                changespritestat THISACTOR STAT_ZOMBIEACTOR

            state clear_enemy_vels
            state enemy_spawn_checkhitag
            sizeat 23 19
            cstat 257
            clipdist 128
            spritepal PAL_DRONE
            break
    endswitch
endevent

action AC_DRONE_IDLE 0 1 5 1 1
action AC_DRONE_FORWARD 15 2 5 1 1
action AC_DRONE_REVERSE 35 2 5 1 1
action AC_DRONE_LEFT 55 1 8 1 1 1
action AC_DRONE_RIGHT 87 1 8 1 1 1
action AC_DRONE_SPIN 87 1 8 1 1 1
action AC_DRONE_SWOOP 15 2 5 1 1
action AC_DRONE_SPIN_DIE 87 1 8 1 1 1
var drone_obstruction 0 2
var drone_modheight 0 2
var drone_domod 0 2
var drone_changetile 0 2

defstate drone_basic
        geta .sectnum temp9
        ifand sector[temp9].floorstat 1024
        {
            ifand sector[temp9].floorstat 512
                nullop
            else
            {
                gets[temp9].floorbunch temp
                ifg temp -1
                    set temp9 temp
            }
        }
        geta .z temp
        getflorzofslope sprite.sectnum sprite.x sprite.y temp
        
        set temp6 temp
        seta .htfloorz temp
        set e_move_gtfo_temp 0
        ifn sprite.sectnum -1
            set e_move_gtfo_temp e_gtfo[sprite.sectnum]
        ifand e_move_gtfo_temp 4
        {
            iffloordistl 4
            {
                sub temp 1024
                seta .z temp
                add temp 1024
            }
            sub temp 8192
        }
        else ifand sector.floorstat 1024
        {
            ifand sector.floorstat 512
            {
                iffloordistl 4
                {
                    sub temp 1024
                    seta .z temp
                    add temp 1024
                }
                sub temp 8192
            }
            else iffloordistl 4
            {
                ifn enemy_target -1
                    ifg sprite[enemy_target].z sprite.z
                    {
                        fall
                        movesprite THISACTOR 0 0 2048 CLIPMASK0 temp3
                        set enemy_stepcounter 0
                    }
                add temp 1536
            }
        }
        else
        {
            iffloordistl 4
            {
                sub temp 1024
                seta .z temp
                add temp 1024
            }
            sub temp 8192
        }
        set temp2 cansee_return
        ife temp2 1
        {
            ldist temp3 enemy_target THISACTOR
            sub temp3 8192
            shiftl temp3 1
            clamp temp3 0 16384
            sub temp temp3
            ife enemy_target player.i
            {
                ifl player.posz temp
                    set temp player.posz
            }
            else
            {
                ifl sprite[enemy_target].z temp
                    set temp sprite[enemy_target].z
            }
        }
        geta .sectnum temp9
        ifand sector[temp9].ceilingstat 1024
        {
            ifand sector[temp9].ceilingstat 512
                nullop
            else
            {
                gets[temp9].ceilingbunch temp4
                ifg temp4 -1
                    set temp9 temp4
            }
        }
        getceilzofslope sprite.sectnum sprite.x sprite.y temp3
        set temp4 temp3
        add temp4 5120
        ifand sector.ceilingstat 1024
        {
            ifand sector.ceilingstat 512
            {
                ifl sprite.z temp4
                    seta .z temp4
                add temp3 8192
            }
            else
            {
                set temp5 temp3
                sub temp5 sprite.z
                abs temp5
                ifl temp5 4096
                {
                    ifg temp3 temp
                    {
                        set enemy_stepcounter 0
                        movesprite THISACTOR 0 0 -5120 CLIPMASK0 temp5
                        fall
                        set temp3 temp
                    }
                }
                sub temp3 8192
            }
        }
        else
        {
            ifl sprite.z temp4
                seta .z temp4
            add temp3 8192
        }

        ifge temp3 temp6
        {

            ifand sector.ceilingstat 1024
            {
                ifand sector.ceilingstat 512
                {
                    set temp3 temp6
                    sub temp3 2048
                }
                else
                    sub temp3 1536
            }
            else
            {
                set temp3 temp6
                sub temp3 2048
            }
        }
        ifl temp temp3
            set temp temp3
        ife sprite[enemy_target].picnum LOCATORS
            set temp sprite[enemy_target].z
        ifn drone_domod 0
            set temp drone_modheight
        ife enemy_stepcounter 0
        {
            ifn sprite.z temp
            {
                geta .z temp2
                sub temp2 temp
                set temp3 temp2
                abs temp2
                shiftr temp2 4
                clamp temp2 1 128
                inv temp2
                
                ifl temp3 0
                    inv temp2

                shiftl temp2 1
                ife sprite[enemy_target].picnum LOCATORS
                    shiftl temp2 2
                set temp3 temp2
                abs temp3
                ifl temp3 8
                    seta .z temp
                else
                    movesprite THISACTOR 0 0 temp2 CLIPMASK0 temp3
            }
            else
                set enemy_stepcounter 1
        }
        else
        {
            add enemy_stepcounter 1
            set temp2 enemy_stepcounter
            ifl temp2 30
                inv temp2
            else
            {
                ifl temp2 60
                    sub temp2 60
                else
                {
                    ifl temp2 90
                        sub temp2 60
                    else
                    {
                        sub temp2 120
                        inv temp2
                    }
                }
            }
            shiftl temp2 3
            movesprite THISACTOR 0 0 temp2 CLIPMASK0 temp3
            ife enemy_stepcounter 120
                set enemy_stepcounter 0
            ifn sprite.z temp
            {
                set temp3 temp2
                abs temp2
                ifl temp3 16
                {
                    ife enemy_target player.i
                        set temp3 player.posz
                    else
                        set temp3 sprite[enemy_target].z
                    ife temp temp3
                    {
                        ifl sprite.z temp
                        {
                            ifl temp2 0
                                set enemy_stepcounter 0
                        }
                        else ifg sprite.z temp
                        {
                            ifg temp2 0
                                set enemy_stepcounter 0
                        }
                    }
                }
            }
        }

        set temp2 cansee_return
        ife enemy_faceplayer 2
            set temp2 1
        ifn way_current -1
            set temp2 1
        ife temp2 1
        {
            set att_target enemy_target
            set att_noclamp 1
            state angle_to_target
            set temp2 temp
            abs temp2
            set temp att_return
            shiftr temp 4
            ife temp 0 ifn att_return 0
            {
                set temp 1
                ifl att_return 0
                    inv temp
            }
            ifl temp2 64
                set temp att_return
            geta .ang temp2
            sub temp2 temp
            and temp2 2047
            seta .ang temp2
            ife enemy_faceplayer 0
                set enemy_faceplayer 1
        }
        else ifn enemy_faceplayer 2
            set enemy_faceplayer 0
        ifg way_ang -1
            seta .ang way_ang
ends

defstate drone_dead
    state dying_blood
    
    rand temp 4
    add temp 8
    for itervar range temp
    {
        espawn A_GENERIC_DEBRIS
        
        setav[RETURN].debris_type DEBRIS_METAL
        
        ifrnd 96
            seta[RETURN].pal 5
            
        rand temp2 192
        
        ifrnd 127
            inv temp2
            
        add temp2 sprite.htang
        add temp2 1024
        and temp2 2047
        
        seta[RETURN].ang temp2
    }

    espawn A_EXPLOSION
    seta[RETURN].xrepeat 16
    seta[RETURN].yrepeat 16
    state skull_gibs
    killit
ends

defstate droneshockpal
    ifspritepal PAL_DRONE
    {
        spritepal 69
        seta .shade -127
        set enemy_skipshade 1
        rand temp 2
        for itervar range temp
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 120 // sparks
            seta[RETURN].pal 6

            rand temp2 512
            ifrnd 127
                inv temp2
            add temp2 sprite.htang
            add temp2 1024
            seta[RETURN].ang temp2


            geta .picnum temp2
            set temp4 tilesizy[temp2]
           // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
           // simplified to sizy*4*yrepeat
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            set temp2 sprite.z
            rand temp3 temp4
            sub temp2 temp3
            seta[RETURN].z temp2

            rand temp2 128
            ifrnd 127
                inv temp2
            add temp2 sprite.x
            seta[RETURN].x temp2
            rand temp2 128
            ifrnd 127
                inv temp2
            add temp2 sprite.y
            seta[RETURN].y temp2
        }
    }
    else
        spritepal PAL_DRONE
ends

spriteshadow A_DRONE
spritenoshade A_DRONE
useractor enemy A_DRONE DRONE_HEALTH AC_DRONE_IDLE
    geta .htcgg temp
    add temp 1
    mod temp 3
    seta .htcgg temp
    clipdist 64
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
    }
    else
        set enemy_skipshade 0

    ifaction AC_DRONE_SPIN_DIE
    {
        ifrnd 32
            spawn A_SMOKE2
        
        ifg sprite.htextra 0
            seta .htextra 1
            
        geta .htang temp2

        add temp2 1024
        and temp2 2047
        seta .ang temp2
        
        ifl sprite.htg_t 2 15
        {
            ifand sprite.htg_t 2 1
            {
                espawn A_EXPLOSION
                seta[RETURN].pal 10
                seta[RETURN].xrepeat 8
                seta[RETURN].yrepeat 8
                setav[RETURN].explosion_nosmoke 1
                ifand sprite.htg_t 2 1
                    setav[RETURN].explosion_silent 1
                else ifand sprite.htg_t 2 2
                    setav[RETURN].explosion_silent 1
            }
            geta .htg_t 2 temp
            sub temp 20
            abs temp
            shiftl temp 7
            add temp sprite.ang
            and temp 2047
            seta .ang temp
        }
        else ifrnd 32
        {
            espawn A_EXPLOSION
            seta[RETURN].xrepeat 8
            seta[RETURN].yrepeat 8
            seta[RETURN].pal 10
            setav[RETURN].explosion_nosmoke 1
            setav[RETURN].explosion_silent 1
        }    
        geta .htg_t 2 temp
        shiftl temp 4

        set move_v temp
        state move_actor
        
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_movedrone
        
        ifge e_dronemove_return 32768
            add counter3 1
            
        set move_v temp
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_movedrone
        ifge e_dronemove_return 32768
            add counter3 1
        
        geta .zvel temp2
        shiftl temp 2
        add temp2 temp
        movesprite THISACTOR 0 0 temp2 CLIPMASK0 temp3
        set temp 0
        
        ifactioncount 120
            set temp 1
        else iffloordistl 4
            set temp 1
        else ifge counter3 5
            set temp 1
        else ifnotmoving
            set temp 1
        else ifhitweapon
            ifdead
                set temp 1
            
        ife temp 1
            state drone_dead
            
        ifn enemy_shocked 0
            state droneshockpal
        else
            spritepal 104
        
        break
    }
    
    ifg enemy_shocked 1
    {   
        set enemy_shoot 30
        
        set temp2 enemy_shocked
        shiftl temp2 4
        clamp temp2 0 1024
        movesprite THISACTOR 0 0 temp2 CLIPMASK0 temp3
        
        set temp2 enemy_shocked
        shiftl temp2 5
        mod temp2 256
        geta .ang temp
        add temp temp2
        and temp 2047
        seta .ang temp
        
        seta .ang ang_offset
        set temp2 enemy_shocked
        shiftl temp2 5
        clamp temp2 1 64
        set move_v temp2
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_movedrone
        seta .ang temp
        
        action AC_DRONE_SPIN
        sub enemy_shocked 1
        
        state droneshockpal
        
        soundonce S_AMB_NEONFLICKR01
        soundonce S_AMB_NEONFLICKR02
        
        break
    }
    else ife enemy_shocked 1
    {
        stopactorsound THISACTOR S_AMB_NEONFLICKR01
        stopactorsound THISACTOR S_AMB_NEONFLICKR02

        sub enemy_shocked 1
        
        ife enemy_shocked 0
            action AC_DRONE_IDLE
    }
    else
        spritepal PAL_DRONE
 
    set cansee_target player.i
    set cansee_height 4096
    getflorzofslope player.cursectnum player.posx player.posy temp2
    geta[player.i].z temp
    ifge temp temp2
    {
        sub temp2 1024
        seta[player.i].z temp2
    }
    state cansee_actor
    seta[player.i].z temp
    
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break

    state e_wakemeup
    ife counter 0
    {
        ifpdistl 12288
        {
            sound S_DRONE_ACTIVE
            set counter 1
        }
    }
    else
    {
        ifpdistl 12288
        {
            ifactorsound THISACTOR S_DRONE_ACTIVE
                nullop
            else
            {
                sound S_DRONE_ACTIVE
                set counter 1
            }
        }
        add counter 1
        ifg counter 27
            set counter 0
    }
    
    ife skip_see 1
    {
        set cansee_return 0
        set enemy_cantsee 90
    }
    ife cansee_return 1 ife skip_see 0
    {
        ifand se_lotag 1
        {
            set cansee_return 0
            set enemy_cantsee 90
        }
        else
            set se_hitag 0
    }
    
    ife cansee_return_o 1
        state enemy_checkw1alt
    state enemy_do_target_icon
    
    state enemy_check_init
    ife enemy_init_return 1
    {
        state drone_basic
        break
    }
    ife cansee_return 1
    {
        set enemy_cantsee 0
        set enemy_target player.i
        set way_current -1
        
    }
    else
    {
        sleeptime 300
        ifl enemy_cantsee 90
        {
            add enemy_cantsee 1
            set enemy_target player.i
            set enemy_idle_count enemy_cantsee
            set way_current -1
        }
        else
        {
            state find_waypoints
            ifn way_current -1
                ife sprite[way_current].extra -1
                    ife sprite[way_current].statnum STAT_WAYPOINT
                        set way_current -1
            ifn way_current -1
            {
                set enemy_target way_current
                ifaction AC_DRONE_FORWARD
                    nullop
                else ifactioncount 8
                    action AC_DRONE_FORWARD
                set face_target enemy_target
                state face_actor
                seta .ang face_return
            }
            else
                set enemy_target player.i
        }
    }
    
    state pup_damage_adjust
    geta .htextra temp2
    set temp8 0
    ifg temp2 -1 ifn sprite.htowner -1
    {
        ife sprite.htowner player.i
        {
            ife player.curr_weapon WEAPON_LOVERBOY
            {
                ife sprite.htpicnum BULLET
                {
                    ifn weapon1_alt 0
                    {
                        shiftl temp2 1
                        set temp temp2
                        shiftr temp 2
                        add temp2 temp
                        seta .htextra temp2
                    }
                }
            }
            set temp8 1
        }
    }
    set temp6 temp2
    ifhitweapon
    {
        geta .zvel temp
        shiftr temp2 1
        add temp temp2
        movesprite THISACTOR 0 0 temp CLIPMASK0 temp3
        cos temp sprite.htang
        sin temp3 sprite.htang
        mul temp temp2
        mul temp3 temp2
        shiftr temp 14
        shiftr temp3 14
        set move_xv temp
        set move_yv temp3
        state enemy_movedrone

        state spawn_blood
        rand temp 3
        add temp 2
        for itervar range temp
        {
            espawn A_GENERIC_DEBRIS
            setav[RETURN].debris_type DEBRIS_METAL
            ifrnd 16
                seta[RETURN].pal 5
            rand temp2 512
            ifrnd 127
                inv temp2
            add temp2 sprite.htang
            add temp2 1024
            seta[RETURN].ang temp2
        }
        
        ifwasweapon P_SHOCKER
        {
            add enemy_shocked 30
            geta .htang ang_offset
        }
        
        ifdead
        {
            stopactorsound THISACTOR S_DRONE_ACTIVE
            state enemy_clearw1alt
            
            set temp2 0
            set temp3 DRONE_HEALTH
            shiftr temp3 1
            
            ifg temp6 temp3
            {
                ifwasweapon EXPLOSION
                {
                    ife temp8 1
                        state crackthesecretofflight
                    ifrnd 127
                        set temp2 1
                }
            }

            state enemy_die_resolve
            
            ife temp2 1
                state drone_dead
            else
            {
                strength 5
                action AC_DRONE_SPIN_DIE
                cos temp sprite.htang
                sin temp3 sprite.htang
                shiftl temp6 1
                mul temp temp6
                mul temp3 temp6
                sound S_ENGINE_OFF
                shiftr temp 14
                shiftr temp3 14
                espawn A_EXPLOSION
                seta[RETURN].xrepeat 8
                seta[RETURN].yrepeat 8
                setav[RETURN].explosion_nosmoke 1
                set enemy_shotgun_xv temp
                set enemy_shotgun_yv temp3
                state enemy_movedrone
                break
            }
        }
    }
    ife enemy_shoot 0
    {
        set att_target enemy_target
        state angle_to_target
        ifl att_return 128
        {
            ifaction AC_DRONE_REVERSE
                nullop
            else ifrnd 8 ife enemy_target player.i ife cansee_return 1
            {
                geta .ang temp9
                set temp8 temp9
                sub temp8 512
                and temp8 2047
                seta .ang temp8
                set move_v 128
                state move_actor
                
                geta .x temp4
                geta .y temp5
                geta .z temp6
                geta .sectnum temp7
                movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp8
                getflorzofslope sprite.sectnum sprite.x sprite.y temp8
                geta .z temp
                set temp2 temp
                add temp 5120
                ifg temp temp8
                {
                    set temp temp8
                    add temp 3072
                }
                set temp8 temp2
                seta .z temp
                geta .xvel temp2
                eshoot P_DANCINGQUEEN
                geta[RETURN].xvel temp3
                add temp3 temp2
                seta[RETURN].xvel temp3
                eshoot P_DANCINGQUEEN
                geta[RETURN].xvel temp3
                add temp3 temp2
                seta[RETURN].xvel temp3
                seta[RETURN].yvel 0
                set enemy_shoot 30
                seta .z temp8
                set enemy_skipshade 1
                seta .shade -127
                seta .x temp4
                seta .y temp5
                seta .z temp6
                seta .sectnum temp7
                seta .ang temp9
            }
        }
    }
    else
        sub enemy_shoot 1
        
    set cansee_target enemy_target
    ifaction AC_DRONE_IDLE
    {
        state drone_basic
        ife enemy_target player.i
        {
            geta[player.i].z temp3
            seta[player.i].z player.posz
            state cansee_actor
            seta[player.i].z temp3
        }
        else
            state cansee_actor
        set temp2 cansee_return
        ife st_do_once 0
        {
            ife temp2 1
                set st_do_once 1
        }
        ife st_do_once 1 ifactioncount 15
        {
            ifrnd 64
            {
                ldist temp enemy_target THISACTOR
                ifl temp 1536
                    nullop
                else
                    action AC_DRONE_FORWARD
            }
            else ifrnd 16
                action AC_DRONE_REVERSE
            else ifrnd 64
                action AC_DRONE_LEFT
            else ifrnd 64
                action AC_DRONE_RIGHT
            else ife temp2 1
            {
                ldist temp enemy_target THISACTOR
                ifl temp 6144 ifg temp 3072
                    ifrnd 64
                        action AC_DRONE_SWOOP
            }
        }
        set temp2 enemy_xv
        abs temp2
        set temp3 enemy_yv
        abs temp3
        add temp2 temp3
        ifn temp2 0
        {
            set move_xv enemy_xv
            set move_yv enemy_yv
            state enemy_movedrone
            mul enemy_xv 9
            div enemy_xv 10
            mul enemy_yv 9
            div enemy_yv 10
        }
    }
    else ifaction AC_DRONE_FORWARD
    {
        state drone_basic
        geta .htg_t 2 move_v
        clamp move_v 0 8
        shiftl move_v 4
        state move_actor
        state enemy_movedrone
        set drone_obstruction e_movetemp5
        ifactioncount 30
        {
            ifrnd 8
            {
                ife enemy_target player.i
                    action AC_DRONE_IDLE
                set enemy_xv move_xv
                set enemy_yv move_yv
            }
            else
            {
                ife enemy_target player.i
                {
                    geta[player.i].z temp3
                    seta[player.i].z player.posz
                    state cansee_actor
                    seta[player.i].z temp3
                }
                else
                    state cansee_actor
                set temp2 cansee_return
                ife temp2 1
                {
                    ldist temp enemy_target THISACTOR
                    ifl temp 6144 ifg temp 3072
                        ifrnd 16 ife enemy_target player.i
                            action AC_DRONE_SWOOP
                }
            }
        }
    }
    else ifaction AC_DRONE_REVERSE
    {
        state drone_basic
        geta .htg_t 2 move_v
        clamp move_v 0 8
        shiftl move_v 4
        state move_actor
        inv move_xv
        inv move_yv
        state enemy_movedrone
        ifactioncount 30
            ifrnd 16
            {
                action AC_DRONE_IDLE
                set enemy_xv move_xv
                set enemy_yv move_yv
            }
    }
    else ifaction AC_DRONE_LEFT
    {
        state drone_basic
        geta .htg_t 2 move_v
        clamp move_v 0 8
        shiftl move_v 4
        geta .ang temp2
        geta .ang temp3
        add temp2 512
        and temp2 2047
        seta .ang temp2
        state move_actor
        seta .ang temp3
        inv move_xv
        inv move_yv
        state enemy_movedrone
        ifactioncount 30
            ifrnd 16
            {
                action AC_DRONE_IDLE
                set enemy_xv move_xv
                set enemy_yv move_yv
            }
    }
    else ifaction AC_DRONE_RIGHT
    {
        state drone_basic
        geta .htg_t 2 move_v
        clamp move_v 0 8
        shiftl move_v 4
        geta .ang temp2
        geta .ang temp3
        add temp2 512
        and temp2 2047
        seta .ang temp2
        state move_actor
        seta .ang temp3
        state enemy_movedrone
        ifactioncount 30
            ifrnd 16
            {
                action AC_DRONE_IDLE
                set enemy_xv move_xv
                set enemy_yv move_yv
            }
    }
    else ifaction AC_DRONE_SWOOP
    {
        state drone_basic
        geta .htg_t 2 move_v
        clamp move_v 0 8
        shiftl move_v 5
        state move_actor
        state enemy_movedrone
        set drone_obstruction e_movetemp5
        geta .htg_t 2 temp2
        
        ifl temp2 15
        {
            shiftl temp2 7
            movesprite THISACTOR 0 0 temp2 CLIPMASK0 temp3
            iffloordistl 4
            {
                set temp2 17
                seta .htg_t 2 temp2
                shiftl temp2 3
                inv temp2
                movesprite THISACTOR 0 0 temp2 CLIPMASK0 temp3
            }
            else
            {
                ldist temp enemy_target THISACTOR
                ifl temp 1536
                {
                    set temp2 45
                    seta .htg_t 2 temp2
                }
            }
        }
        else ife temp2 17
        {
            shiftl temp2 3
            inv temp2
            movesprite THISACTOR 0 0 temp2 CLIPMASK0 temp3
        }

        ifactioncount 45
        {
                action AC_DRONE_IDLE
                shiftr move_xv 2
                shiftr move_yv 2
                set enemy_xv move_xv
                set enemy_yv move_yv
        }
    }
    ifge drone_obstruction 32768
    {
        ifl drone_obstruction 49152
        {
            sub drone_obstruction 32768
            set temp drone_obstruction
            ifn wall[temp].nextsector -1
            {
                ifn wall[temp].nextwall -1
                {
                    getw[temp].nextsector temp
                    ifn temp -1
                    {
                        getflorzofslope temp sprite.x sprite.y temp2
                        ifg sprite.z temp2
                        {
                            sub temp2 1024
                            set drone_modheight temp2
                            set drone_domod 1
                            ife enemy_faceplayer 1
                                set enemy_faceplayer 2
                        }
                        else
                        {
                            getceilzofslope temp sprite.x sprite.y temp2
                            ifl sprite.z temp2
                            {
                                add temp2 6144
                                set drone_modheight temp2
                                set drone_domod 1
                                ife enemy_faceplayer 1
                                    set enemy_faceplayer 2
                            }
                        }
                    }
                }
            }
        }
    }
    set drone_obstruction -1
    ifn drone_domod 0
    {
        add drone_domod 1
        ifg drone_domod 60
        {
            set drone_domod 0
            set drone_modheight 0
            set enemy_faceplayer 0
        }
    }
    ifg counter2 0
       sub counter2 1 
    ifn enemy_skipshade 0
    {
        switch sprite.htg_t 4
            case AC_DRONE_IDLE
                set drone_changetile 5
                break
            case AC_DRONE_FORWARD
            case AC_DRONE_REVERSE
                ifand sprite.htg_t 2 1
                    set drone_changetile 5
                else
                    set drone_changetile 10
                break
            case AC_DRONE_SWOOP
                set drone_changetile 10
                break
            case AC_DRONE_LEFT
            case AC_DRONE_RIGHT
            case AC_DRONE_SPIN
                set drone_changetile 8
                break
            default
                set drone_changetile 0
                break
        endswitch
        geta .mdflags temp
        or temp 16
        seta .mdflags temp
        set counter2 2
    }
    else ife counter2 0
    {
        set drone_changetile 0
        geta .mdflags temp
        ifand temp 16
        {
            xor temp 16
            seta .mdflags temp
        }
    }
enda

appendevent EVENT_ANIMATESPRITES
    ifactor A_DRONE
    {
        ifn drone_changetile 0
        {
            gettspr .tsprpicnum temp
            add temp drone_changetile
            settspr .tsprpicnum temp
        }
    }
endevent

var pede_next -1 2
var pede_prev -1 2
var pede_wave 0 2
var pede_lr 0 2
var pede_tighten 0 2
var pede_rise 0 2
var pede_rise_lunge 0 2
var pede_numparts 0 2
var pede_burst 0 2
var pede_burst_last 0 2
var pede_linestate 0 2
var pede_headstate 0 2
define PEDE_STUNLENGTH 45
defstate spawn_butts
    add st_do_once 4
    espawn A_DIOPEDE_BUTT
    setav[temp].pede_next RETURN
    setav[RETURN].pede_prev temp
    setav[RETURN].st_do_once st_do_once
    setav[RETURN].se_hitag se_hitag
    setav[RETURN].se_lotag se_lotag
    setav[RETURN].se_xvel se_xvel
    setav[RETURN].se_yvel se_yvel
    setav[RETURN].se_zvel se_zvel
    ife sprite.statnum STAT_ACTOR
    {
        changespritestat RETURN STAT_ACTOR
        seta[RETURN].httimetosleep 300
    }
    getp .max_actors_killed temp2
    sub temp2 2
    setp .max_actors_killed temp2
    set temp RETURN
ends
eventloadactor A_DIOPEDE_HEAD
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda
onevent EVENT_SPAWN
    switch sprite.picnum
        case A_DIOPEDE_HEAD
            cstat 257
            sizeat 23 19
            clipdist 5
            add st_do_once 4
            spritepal 0
            state clear_enemy_vels
            ifspawnedby A_NEWRESPAWN
            {
                geta .owner respawntemp
                set se_lotag actorvar[respawntemp].tp_owner
                set se_hitag actorvar[respawntemp].se_extra
                set se_xvel actorvar[respawntemp].se_xvel
                set se_yvel actorvar[respawntemp].se_yvel
                set se_zvel actorvar[respawntemp].se_zvel
            }
            state enemy_spawn_checkhitag
            espawn A_DIOPEDE_BUTT
            setav .pede_next RETURN
            ife sprite.statnum STAT_ACTOR
            {
                changespritestat RETURN STAT_ACTOR
                seta[RETURN].httimetosleep 300
            }
            setav[RETURN].pede_prev THISACTOR
            setav[RETURN].st_do_once st_do_once
            setav[RETURN].se_hitag se_hitag
            setav[RETURN].se_lotag se_lotag
            setav[RETURN].se_xvel se_xvel
            setav[RETURN].se_yvel se_yvel
            setav[RETURN].se_zvel se_zvel
            getp .max_actors_killed temp2
            sub temp2 2
            setp .max_actors_killed temp2
            set temp RETURN
            state spawn_butts
            state spawn_butts
            state spawn_butts
            state spawn_butts
            state spawn_butts
            state spawn_butts
            state spawn_butts
            set st_do_once 0
            break
        case A_DIOPEDE_BUTT
            cstat 256
            sizeat 23 19
            spritepal 0
            spritepal PAL_DIOPEDE
            geta .owner temp3
            ife sprite[temp3].statnum STAT_ACTOR
            {
                changespritestat THISACTOR STAT_ACTOR
                sleeptime 300
            }
            geta .ang temp3
            add temp3 1024
            and temp3 2047
            cos move_xv temp3
            sin move_yv temp3
            mul move_xv 128
            mul move_yv 128

            shiftr move_xv 14
            shiftr move_yv 14
            movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp3
            break
    endswitch
endevent
defstate pede_sin
    ife pede_lr 0
    {
        add pede_wave 8
        ifge pede_wave 128
            set pede_lr 1
    }
    else
    {
        sub pede_wave 8
        ifle pede_wave -128
            set pede_lr 0
    }
    geta .ang temp7
    ife pede_lr 0
        add temp7 16
    else
        sub temp7 16
    and temp7 2047
    seta .ang temp7
ends

defstate diopede_water_adjust
    ifonwater
    {
        iffloordistl 2
        {
            geta .z temp
            getflorzofslope sprite.sectnum sprite.x sprite.y temp2
            add temp2 2560
            ifg temp temp2
                set temp temp2
            seta .z temp
      }
    }

ends

defstate pede_die_shared
    stopactorsound THISACTOR S_AMB_NEONFLICKR01
    stopactorsound THISACTOR S_AMB_NEONFLICKR02
    sound S_SMASH_GLASS
    sound S_BULLET_METAL2
    setp .sound_pitch -64
    sound S_MUTANT_FLESHRIP
    setp .sound_pitch 0
    espawn A_ACIDYSPIT_SPLASH
    seta[RETURN].xrepeat 32
    seta[RETURN].yrepeat 36
    
    espawn A_EXPLOSION
    seta[RETURN].xrepeat 12
    seta[RETURN].yrepeat 14
    setav[RETURN].explosion_silent 1
    setav[RETURN].explosion_nosmoke 1
    setav[RETURN].prop_barrel_type 2
    seta[RETURN].pal 5
    seta[RETURN].cstat 32768
    geta[RETURN].z temp4
    sub temp4 2048
    seta[RETURN].z temp4
    
    espawn A_GENERIC_PARTICLE
    setav[RETURN].particle_force_pal 5
    seta[RETURN].xrepeat 125
    rand temp3 3
    add temp3 6
    for itervar range temp3
    {
        espawn A_GENERIC_DEBRIS
        setav[RETURN].debris_type DEBRIS_METAL
        rand temp4 2047
        seta[RETURN].ang temp4
        geta[RETURN].z temp4
        sub temp4 2048
        seta[RETURN].z temp4
    }

    espawn A_SMOKE2
    seta[RETURN].xrepeat 1
    seta[RETURN].yrepeat 1
    seta[RETURN].pal 5
    setav[RETURN].counter 15
    seta[RETURN].cstat 514
    geta[RETURN].z temp
    add temp 1024
    seta[RETURN].z temp
    seta[RETURN].blend 129
ends

action AC_DIOPEDE_WALK 0 6 5 1 8
action AC_DIOPEDE_REAR 0 1 5 1 4
action AC_DIOPEDE_SPIT 0 1 5 1 4
action AC_DIOPEDE_IDLE 0 1 5 1 8
useractor enemy A_DIOPEDE_HEAD DIOPEDE_HEALTH AC_DIOPEDE_IDLE
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
        geta .shade temp
        sub temp 4
        seta .shade temp
    }
    else
        set enemy_skipshade 0
    // misc setup for cansee nonsense
    set cansee_target player.i
    set cansee_height 8192
    state cansee_actor
    state enemy_spawn_checkhitag
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break
        
    state e_wakemeup
    state enemy_do_target_icon
    
    state enemy_check_init    
    ife enemy_init_return 1
    {
        fall
        state diopede_water_adjust
        break
    }
    ifaction AC_DIOPEDE_IDLE
        action AC_DIOPEDE_WALK
    ife skip_see 1
    {
        set cansee_return 0
        set enemy_cantsee 10
    }
    ife cansee_return 1 ife skip_see 0
    {
        ifand se_lotag 1
        {
            set cansee_return 0
            set enemy_cantsee 10
        }
        else
            set se_hitag 0
    }
    ife cansee_return 1
    {
        set enemy_cantsee 0
        set enemy_target player.i
        set way_current -1
        
    }
    else
    {
        sleeptime 300
        ifl enemy_cantsee 10
        {
            add enemy_cantsee 1
            set enemy_target player.i
            set enemy_idle_count enemy_cantsee
            set way_current -1
        }
        else
        {
            state find_waypoints
            ifn way_current -1
                ife sprite[way_current].extra -1
                    ife sprite[way_current].statnum STAT_WAYPOINT
                        set way_current -1
            ifn way_current -1
            {
                set enemy_target way_current
                set face_target enemy_target
                state face_actor
                seta .ang face_return
            }
            else
                set enemy_target player.i
        }
    }
    
    ife cansee_return_o 1
        state enemy_checkw1alt
    ife enemy_annoyance 0
        spritepal PAL_DIOPEDE
    else
        set enemy_annoyance 0
    ifn sprite.htowner -1
        ife sprite[sprite.htowner].picnum A_DIOPEDE_HEAD
            seta .htextra -1
    ife sprite.htpicnum P_ACIDYSPIT
        seta .htextra -1
    state pup_damage_adjust
    geta .htextra temp2
    
    findnearsprite3d P_SHOCKER 256 temp
    ifn temp -1
    {
        seta .htowner sprite[temp].htowner
        seta .htpicnum sprite[temp].picnum
        seta .htextra sprite[temp].extra
    }
    ifhitweapon
    {
        rand temp 2
        add temp S_BULLET_METAL1
        soundvar temp
        spritepal 72
        ifwasweapon P_SHOCKER
        {
            geta .extra temp
            sub temp temp2
            shiftl temp2 1
            sub temp temp2
            clamp temp 0 DIOPEDE_HEALTH
            seta .extra temp
            set pede_burst_last PEDE_STUNLENGTH
            soundonce S_AMB_NEONFLICKR01
            soundonce S_AMB_NEONFLICKR02
        }
        ifdead
            nullop
        else
            sound S_DIOPEDE_HIT
    }
    set temp pede_next
    set pede_numparts 0
    ife st_do_once -1
        set temp4 4
    whilen temp -1
    {
        setav[temp].patrol_num patrol_num
        ifdead
            setav[temp].pede_burst 1
        ife sprite.statnum STAT_ACTOR
            ife sprite[temp].statnum STAT_ZOMBIEACTOR
                changespritestat temp STAT_ACTOR
        seta[temp].httimetosleep 300
        add pede_numparts 1
        ife st_do_once -1
            setav[temp].st_do_once temp4
        setav[temp].pede_linestate pede_linestate
        ifg pede_burst_last 0
        {
            ifand pede_burst_last 1
                setav[temp].pede_burst_last 1
            ife pede_burst_last PEDE_STUNLENGTH
                ife actorvar[temp].pede_next -1
                    setav[temp].pede_burst_last -1
        }
        getav[temp].pede_next temp
        add temp4 4
    }
    set st_do_once 0
    cstat 257
    ife pede_burst_last 0
        ifg enemy_shocked 0
            sub enemy_shocked 1
    ifdead
    {
        state enemy_clearw1alt
        state pede_die_shared
        state enemy_die_resolve
        sound S_DIOPEDE_DIE
        killit
    }
    clipdist 5
    ifaction AC_DIOPEDE_WALK
    {
        fall
        switch sprite.htg_t 3
            case 2
            case 5
                ife enemy_stepcounter 0
                    set enemy_stepcounter 1
                break
            default
                set enemy_stepcounter 0
                break
        endswitch
        ife enemy_stepcounter 1
        {
            setp .sound_pitch 480
            iffloordistl 1
                state mechsect_footstep
            set enemy_stepcounter 2
            setp .sound_pitch 0
        }
    }
    else 
    {
        set enemy_stepcounter 0
        ifn pede_headstate 0
        {
            fall
            cos move_xv sprite.ang
            sin move_yv sprite.ang

            mul move_xv 128
            mul move_yv 128
            shiftr move_xv 14
            shiftr move_yv 14
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
            iffloordistl 1
                add pede_headstate 1
            mod pede_headstate 10
        }
    }
    state diopede_water_adjust
    stopactorsound THISACTOR S_BBOMB_THROW
    set att_target enemy_target
    set att_noclamp 1
    state angle_to_target
    set temp att_return
    shiftr temp 4
    set temp2 temp
    abs temp2
    ife temp 0 ifn att_return 0
    {
        set temp 1
        ifl att_return 0
            inv temp
    }
    geta .ang temp2
    sub temp2 temp
    ifg pede_burst_last 0
    {
        ifand pede_burst_last 2
            spritepal 69
        else
            spritepal 0
        set temp3 pede_burst_last
        shiftl temp3 2
        add temp2 temp3
        sub pede_burst_last 1
    }
    else
    {
        stopactorsound THISACTOR S_AMB_NEONFLICKR01
        stopactorsound THISACTOR S_AMB_NEONFLICKR02
    }
    and temp2 2047
    seta .ang temp2
    ife enemy_faceplayer 0
        set enemy_faceplayer 1
    state pede_sin
    geta .ang temp3
    cos move_xv temp3
    sin move_yv temp3
    ifl sprite.zvel 0
    {
        set temp2 sprite.zvel
        abs temp2
        shiftr temp2 6
        mul move_xv temp2
        mul move_yv temp2
    }
    else
    {
        shiftl move_xv 6
        shiftl move_yv 6
        set temp pede_numparts
        sub temp 8
        clamp temp -8 -1
        abs temp
        ifg temp 1
        {
            shiftl temp 2
            cos temp2 sprite.ang
            sin temp3 sprite.ang
            mul temp2 temp
            mul temp3 temp
            add move_xv temp2
            add move_yv temp3
        }
    }
    shiftr move_xv 14
    shiftr move_yv 14
    ifaction AC_DIOPEDE_WALK
    {
        ifpdistl 2048
        {
            rand temp2 255
            set temp pede_numparts
            shiftl temp 2
            clamp temp 8 255
            ife pede_burst_last 0
                ifle temp2 temp
                    ife cansee_return 1
                        ife enemy_target player.i
                            iffloordistl 1
                            {
                                action AC_DIOPEDE_REAR
                                set pede_linestate 1
                            }
        }
    }
    else
    {
        ifaction AC_DIOPEDE_REAR
        {
            set temp sprite.htg_t 2
            clamp temp 1 65536
            shiftl temp 1
            div move_xv temp
            div move_yv temp
            set temp2 pede_numparts
            clamp temp2 1 65536
            ifge sprite.htg_t 2 temp2
                action AC_DIOPEDE_SPIT
            sub temp 64
            shiftl temp 4
            movesprite THISACTOR 0 0 temp CLIPMASK0 temp3
        }
        else ifaction AC_DIOPEDE_SPIT
        {
            shiftr move_xv 4
            shiftr move_yv 4
            ifactioncount 2
            {
                set move_xv 0
                set move_yv 0
            }
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
            set move_xv 0
            set move_yv 0
            set temp pede_numparts
            add temp 7
            ifg pede_burst_last 0
                seta .htg_t 2 temp
            ifge sprite.htg_t 2 temp
            {
                action AC_DIOPEDE_WALK
                set st_do_once -1
                set pede_linestate 0
            }
        }
    }
    set enemy_xv move_xv
    set enemy_yv move_yv
    state enemy_do_move
    set temp3 e_move_return
    ifge temp3 32768
    {
        ifl temp3 49152
        {
            sub temp3 32768
            set temp temp3
            ifn wall[temp].nextsector -1
            {
                ifn wall[temp].nextwall -1
                {
                    getw[temp].nextsector temp
                    ifn temp -1
                    {
                        getflorzofslope temp sprite.x sprite.y temp2
                        geta .z temp
                        sub temp 5120
                        iffloordistl 1 ifle temp temp2 ife sprite.zvel 0
                        {
                            seta .zvel -512
                            ssp THISACTOR CLIPMASK0
                            shiftl move_xv 1
                            inv move_xv
                            shiftl move_yv 1
                            inv move_yv
                            set enemy_xv move_xv
                            set enemy_yv move_yv
                            state enemy_do_move
                            set temp3 e_move_return
                            geta .z temp
                            sub temp temp2
                            abs temp
                            div temp 512
                            clamp temp 1 30
                            ife pede_rise 0 ife pede_rise_lunge 0
                                set pede_rise temp
                            ifl pede_numparts 2
                                clamp pede_rise 1 5
                        }
                    }
                }
            }
        }
        else
        {
            sub temp3 49152
            ifn temp3 player.i
            {
                set temp 0
                ifand sprite[temp3].cstat 16
                    set temp 1
                else ifand sprite[temp3].cstat 32
                    set temp 1
                iffloordistl 1 ife sprite.zvel 0 ife temp 1
                {
                    seta .zvel -512
                    ssp THISACTOR CLIPMASK0
                    shiftl move_xv 1
                    inv move_xv
                    shiftl move_yv 1
                    inv move_yv
                    set enemy_xv move_xv
                    set enemy_yv move_yv
                    state enemy_do_move
                    set temp3 e_move_return
                    geta .z temp
                    geta[temp3].z temp2
                    set temp4 tilesizy[sprite[temp3].picnum]
                    shiftl temp4 2
                    mul temp4 sprite.yrepeat
                    sub temp2 temp4
                    sub temp temp2
                    abs temp
                    div temp 512
                    clamp temp 1 30
                    ife pede_rise 0 ife pede_rise_lunge 0
                        set pede_rise temp
                    ifl pede_numparts 2
                                clamp pede_rise 1 5
                }
            }
        }
    }
    ifg pede_rise 0
    {
        seta .zvel -640
        ssp THISACTOR CLIPMASK0
        sub pede_rise 1
    }
    ifn pede_next -1
    {
        set att_target pede_next
        set att_noclamp 1
        state angle_to_target
        set temp att_return
        abs temp
        ifl temp 512
        {
            geta .ang temp3
            add temp3 att_return
            and temp3 2047
            seta .ang temp3
            ifl temp 256
            {
                shiftr att_return 4
                ife att_return 0
                {
                    set temp3 sprite.ang
                    add temp3 1024
                }
                else
                    sub temp3 att_return
                and temp3 2047
                cos move_xv temp3
                sin move_yv temp3

                shiftl move_xv 4
                shiftl move_yv 4
                shiftr move_xv 14
                shiftr move_yv 14
                add move_xv sprite.x
                add move_yv sprite.y
                seta[pede_next].x move_xv
                seta[pede_next].y move_yv
                set temp2 sprite.sectnum
                updatesector sprite[pede_next].x sprite[pede_next].y temp2
                ifn temp2 -1
                    seta[pede_next].sectnum temp2
            }
        }
    }
    ifaction AC_DIOPEDE_SPIT
    {
        ifand sprite.htg_t 2 1
        {
            sound S_STEP_WATER_JUMP3
            geta .x temp4
            geta .y temp5
            geta .sectnum temp6
            geta .ang temp3
            cos move_xv temp3
            sin move_yv temp3

            shiftl move_xv 7
            shiftl move_yv 7
            shiftr move_xv 14
            shiftr move_yv 14
            add move_xv sprite.x
            add move_yv sprite.y
            seta .x move_xv
            seta .y move_yv
            
            geta .ang temp3
            sub temp3 512
            and temp3 2047
            cos move_xv temp3
            sin move_yv temp3

            shiftl move_xv 7
            shiftl move_yv 7
            shiftr move_xv 14
            shiftr move_yv 14
            add move_xv sprite.x
            add move_yv sprite.y
            seta .x move_xv
            seta .y move_yv
            set temp2 sprite.sectnum
            
            updatesector sprite.x sprite.y temp2
            ifn temp2 -1
                seta .sectnum temp2
            eshoot P_ACIDYSPIT
            ife shot_delay 0
            {
                setav[RETURN].se_extra 1
                set shot_delay 1
            }
            else
                set shot_delay 0
            seta .x temp4
            seta .y temp5
            seta .sectnum temp6
        }
        else
            sound S_STEP_WATER_RUN3
    }
    else
        setvar shot_delay 0
    clipdist 80
enda

useractor enemy A_DIOPEDE_BUTT 10 AC_DIOPEDE_IDLE
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
        geta .shade temp
        sub temp 4
        seta .shade temp
    }
    else
        set enemy_skipshade 0
    ife pede_linestate 1
    {
        ifaction AC_DIOPEDE_WALK
            action AC_DIOPEDE_REAR
    }
    else ifaction AC_DIOPEDE_REAR
        action AC_DIOPEDE_WALK
    ifn pede_prev -1
    {
        ife actorvar[pede_prev].enemy_init 1
        {
            ifaction AC_DIOPEDE_IDLE
                action AC_DIOPEDE_WALK
            set enemy_init 1
        }
    }
    ifg st_do_once 0
    {
        ifaction AC_DIOPEDE_IDLE
            nullop
        else
        {
            resetactioncount
            sub st_do_once 1
            ife st_do_once 0
                action AC_DIOPEDE_WALK
        }
    }
    ifn pede_burst_last 0
    {
        spritepal 69
        ife pede_burst_last -1
            set pede_burst 1
        set pede_burst_last 0
    }
    else
        spritepal 0
    ifaction AC_DIOPEDE_WALK
    {
        switch sprite.htg_t 3
            case 2
            case 5
                ife enemy_stepcounter 0
                    set enemy_stepcounter 1
                break
            default
                set enemy_stepcounter 0
                break
        endswitch
        ife enemy_stepcounter 1
        {
            setp .sound_pitch 480
            iffloordistl 1
                state mechsect_footstep
            set enemy_stepcounter 2
            setp .sound_pitch 0
        }
    }
    else
        set enemy_stepcounter 0
    ifn pede_burst 0
    {
        ifn pede_next -1
            setav[pede_next].pede_burst 1
        add pede_burst 1
        ife pede_burst 5
        {
            state pede_die_shared
            killit
        }
        break
    }
    ifn sprite.htowner -1
        ife sprite[sprite.htowner].picnum A_DIOPEDE_HEAD
            seta .htextra -1
    ife sprite.htpicnum P_ACIDYSPIT
        seta .htextra -1
    state pup_damage_adjust
    state enemy_do_target_icon
    ifcansee
        state enemy_checkw1alt
    getflorzofslope sprite.sectnum sprite.x sprite.y temp
    getceilzofslope sprite.sectnum sprite.x sprite.y temp2
    sub temp2 temp
    abs temp2
    ifand sector.floorstat 1024
    {
        ifand sector.floorstat 512
            nullop
        else ifl temp2 3072
            set temp2 3072
    }
    ifand sector.ceilingstat 1024
    {
        ifand sector.ceilingstat 512
            nullop
        else ifl temp2 3072
            set temp2 3072
    }
    ifl temp2 3072
        ifl sprite.htextra 1
            seta .htextra 1
    ifhitweapon
    {
        ifn pede_next -1
        {
            seta[pede_next].picnum A_DIOPEDE_HEAD
            seta[pede_next].cstat 256
            seta[pede_next].clipdist 16
            seta[pede_next].extra 90
            seta[pede_next].pal 72
            setav[pede_next].enemy_annoyance 1
            getp .max_actors_killed temp2
            add temp2 1
            setp .max_actors_killed temp2
            add p_killed 1
            rand temp 256
            ifrnd 127
                inv temp
            add temp sprite[pede_next].ang
            add temp sprite.htang
            and temp 2047
            seta[pede_next].ang temp
            setav[pede_next].pede_prev -1
            set temp pede_next

            set temp4 0
            whilen temp -1
            {
                geta[temp].ang temp3
                getav[temp].pede_next temp
                ifn temp -1
                {
                    add temp3 1024
                    and temp3 2047
                    cos move_xv temp3
                    sin move_yv temp3
                    shiftl move_xv 7
                    shiftl move_yv 7
                    shiftr move_xv 14
                    shiftr move_yv 14
                    seta[temp].cstat 256
                    ife temp4 0
                    {
                        
                        add move_xv sprite.x
                        add move_yv sprite.y
                        seta[temp].x move_xv
                        seta[temp].y move_yv
                        updatesector sprite[temp].x sprite[temp].y temp2
                        ifn temp2 -1
                            seta[temp].sectnum temp2
                        set temp4 1
                    }
                    else
                        movesprite temp move_xv move_yv 0 CLIPMASK0 temp3
                }
            }
        }
        ifn pede_prev -1
        {
            setav[pede_prev].pede_next -1
            set temp pede_prev
            whilen temp -1
            {
                getav[temp].pede_prev temp2
                ife temp2 -1
                    setav[temp].pede_headstate 1
                set temp temp2
            }
        }
        sound S_SMASH_GLASS
        sound S_BULLET_METAL2
        spawn A_ACIDYSPIT_SPLASH
        espawn A_GENERIC_PARTICLE
        setav[RETURN].particle_force_pal 5
        seta[RETURN].xrepeat 125
        rand temp3 3
        add temp3 6
        for itervar range temp3
        {
            espawn A_GENERIC_DEBRIS
            setav[RETURN].debris_type DEBRIS_METAL
            geta .ang temp4
            rand temp4 2047
            seta[RETURN].ang temp4
            geta[RETURN].z temp4
            sub temp4 2048
            seta[RETURN].z temp4
        }
        state enemy_clearw1alt
        killit
    }
    stopactorsound THISACTOR S_BBOMB_THROW
    geta .htflags temp
    or temp 2048
    seta .htflags temp
    fall
    state diopede_water_adjust
    geta[pede_prev].z temp
    set temp2 temp
    sub temp 1536
    add temp2 1536
    ifg sprite.z temp2
    {
        geta .z temp3
        sub temp3 sprite[pede_prev].z
        abs temp3
        set pede_tighten temp3
        seta .z temp2
    }
    else ifl sprite.z temp
    {
        geta .z temp3
        sub temp3 sprite[pede_prev].z
        abs temp3
        set pede_tighten temp3
        seta .z temp
    }
    set face_target pede_prev
    state face_actor
    seta .ang face_return
    geta .ang temp3
    add temp3 1024
    and temp3 2047
    cos move_xv temp3
    sin move_yv temp3
    seta .x sprite[pede_prev].x
    seta .y sprite[pede_prev].y
    seta .sectnum sprite[pede_prev].sectnum
    ifn pede_tighten 0
    {
        set temp pede_tighten
        shiftr temp 9
        clamp temp 1 512
        set temp2 128
        div temp2 temp
        set pede_tighten 0
        mul move_xv temp2
        mul move_yv temp2
    }
    else
    {
        shiftl move_xv 7
        shiftl move_yv 7
    }
    shiftr move_xv 14
    shiftr move_yv 14
    add move_xv sprite[pede_prev].x
    add move_yv sprite[pede_prev].y
    seta .x move_xv
    seta .y move_yv
    set temp2 sprite.sectnum
    updatesector sprite.x sprite.y temp2
    ifn temp2 -1
        seta .sectnum temp2
   
enda

eventloadactor A_DEACON
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda

var deacon_v 0 2
var deacon_a -1 2
var deacon_ac 0 2
var deacon_z 0 2
var deacon_modzv 0 2
var deacon_die_count 0 2
var deacon_die_delay 0 2
var deacon_die_last 0 2
action AC_DEACON_BASE 0 1 5 1 1
action AC_DEACON_FW 5 1 5 1 1
action AC_DEACON_BW 10 1 5 1 1
action AC_DEACON_R 15 1 5 1 1
action AC_DEACON_L 20 1 5 1 1
action AC_DEACON_SHOOT 25 4 5 1 8
action AC_DEACON_SHOCKED 45 2 5 1 1
action AC_DEACON_DYING 58 5 1 1 1
spritenoshade A_DEACON
spritenoshade A_DEACON_DEAD
useractor notenemy A_DEACON_DEAD CORPSE_HEALTH
    ife st_do_once 0
    {
        spritepal PAL_DEACON
        set st_do_once 1
    }
    state enemy_body_code
enda
useractor enemy A_DEACON DEACON_HEALTH AC_DEACON_BASE
    ife st_do_once 0
    {
        spritepal PAL_DEACON
        set st_do_once 1
    }
    geta .htcgg temp
    add temp 1
    mod temp 3
    seta .htcgg temp
    clipdist 64 // like the archangel give this enough space to clear some doors and such
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
        geta .shade temp
        sub temp 6
        seta .shade temp
    }
    else
        set enemy_skipshade 0
    ifdead nullop
    else
    {
        set temp counter
        mod temp 8
        ife temp 0
        {
            espawn A_SMOKE2
            seta[RETURN].xrepeat 1
            seta[RETURN].yrepeat 1
            seta[RETURN].pal 8
            setav[RETURN].counter 15
            seta[RETURN].cstat 514
            geta[RETURN].z temp
            set temp4 tilesizy[sprite.picnum]
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            shiftr temp4 1
            sub temp temp4
            add temp 1024
            seta[RETURN].z temp
            
            set face_target player.i
            state face_actor
            seta[RETURN].ang face_return
            seta[RETURN].xvel -32
            ssp RETURN 0
            geta .ang temp
            add temp 1024
            rand temp2 8
            ifrnd 127
                rand temp2 -8
            else
                rand temp2 8
            add temp temp2
            and temp 2047
            seta[RETURN].ang temp
            set temp sprite.xvel
            abs temp
            clamp temp 16 65536
            add temp 48
            seta[RETURN].xvel temp
            seta[RETURN].zvel -4096
            ssp RETURN 0
        }
    }
    ifaction AC_DEACON_DYING
    {
        fall
        move AM_ENEMY_SEARCH_STOP
        cstat 0
        seta .ang deacon_a
        ifg deacon_v 0
        {
            set move_v deacon_v
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
            set temp deacon_v
            shiftr temp 3
            clamp temp 2 65536
            sub deacon_v temp
            clamp deacon_v 0 512
            ifle deacon_v 8
                set deacon_v 0
        }
        ifg sprite.htextra 50
        {
            state generic_gibs
            espawn A_EXPLOSION
            seta[RETURN].xrepeat 16
            seta[RETURN].yrepeat 16
            killit
        }

        iffloordistl 1
            set temp 5
        else iffloordistl 5
            set temp 4
        else iffloordistl 9
            set temp 3
        else iffloordistl 13
            set temp 2
        else iffloordistl 17
            set temp 1
        else
            set temp 0
        ifg temp deacon_die_last
        {
                add deacon_die_delay 1
                ifge deacon_die_delay 2
                {
                    set deacon_die_delay 0
                    add deacon_die_last 1
                    clamp deacon_die_last 0 5
                }
                else
                    set temp deacon_die_last
        }
        clamp temp 0 5
        ife temp 5
            shiftr deacon_v 1
        add deacon_die_count 1
        ifg deacon_die_count 150
        {
            set temp2 deacon_die_count
            sub temp2 150
            add deacon_die_last deacon_die_count
            clamp deacon_die_last 0 5
            set deacon_v 0
        }
        seta .htg_t 2 deacon_die_last
        seta .htg_t 3 deacon_die_last
        ife deacon_die_last 5
        {
            set enemy_xv 0
            set enemy_yv 0
            strength CORPSE_HEALTH
            action AC_ENEMY_BODY
            state enemy_die_cleartags
            cactor A_DEACON_DEAD
        }
        stopactorsound THISACTOR S_DEACON_HOVER
        break
    }
    ife counter 0
    {
        sound S_DEACON_HOVER
        set counter 31
    }
    else
        sub counter 1
    // misc setup for cansee nonsense
    set cansee_target player.i
    set cansee_height 6144
    ifp pducking
        add cansee_height 4096
    geta .clipdist temp
    seta .clipdist 32
    state cansee_actor
    seta .clipdist temp

    state enemy_lotag_checkclear
    ifg se_hitag 0 // enforce cantsee when lotag and/or enemy_ife is set
    {
        set temp 0
        ifand se_lotag 1
            set temp 1
        else ife enemy_ife 1
            set temp 1
        ife temp 1
        {
            set cansee_return 0
            set cansee_return_o 0
            set enemy_cantsee 10
        }
    }
    state enemy_check_pause
    ife eps_return 1
        break

    state e_wakemeup
    ife skip_see 1
    {
        set cansee_return 0
        set enemy_cantsee 10
    }
    ife cansee_return 1 ife skip_see 0
    {
        ifand se_lotag 1
        {
            set cansee_return 0
            set enemy_cantsee 10
        }
        else
            set se_hitag 0
    }
    ife cansee_return_o 1
        state enemy_checkw1alt
    state enemy_do_target_icon
    state enemy_check_init
    ife enemy_init_return 1
        break
        
    ifg need_spot_sound 1
    {
        sub need_spot_sound 1
        ife need_spot_sound 1
        {
            ifrnd 32
            {
                switch sprite.htg_t 4
                    case AC_DEACON_SHOOT
                    case AC_DEACON_SHOCKED
                    case AC_DEACON_DYING
                        break
                    default
                        rand temp 1
                        add temp S_DEACON_ROAM1
                        sound temp
                        break
                endswitch
            }
            set need_spot_sound 90
        }
    }

    ife cansee_return 1
    {
        set enemy_cantsee 0
        set enemy_target player.i
        set way_current -1
        ife need_spot_sound 0
        {
            set need_spot_sound 90
            rand temp 1
            add temp S_DEACON_RECOG1
            sound temp
        }
    }
    else
    {
        sleeptime 300
        ifl enemy_cantsee 10
        {
            add enemy_cantsee 1
            set enemy_target player.i
            set enemy_idle_count enemy_cantsee
            set way_current -1
        }
        else
        {
            ifn way_current -1
                ife sprite[way_current].extra -1
                    ife sprite[way_current].statnum STAT_WAYPOINT
                        set way_current -1
            ifn way_current -1
            {
                set enemy_target way_current
                set face_target enemy_target
                state face_actor
                seta .ang face_return
            }
            else
                set enemy_target player.i
        }
    }
    
    
    geta .htextra temp2
    ifg temp2 -1 ifn sprite.htowner -1
    {
        ife sprite.htowner player.i
        {
            ife player.curr_weapon WEAPON_LOVERBOY
            {
                ife sprite.htpicnum BULLET
                {
                    ifn weapon1_alt 0
                    {
                        shiftl temp2 1
                        set temp temp2
                        shiftr temp 2
                        add temp2 temp
                        seta .htextra temp2
                    }
                }
            }
        }
    }
    ldist temp6 enemy_target THISACTOR
    iffloordistl 16
        movesprite THISACTOR 0 0 -4096 CLIPMASK0 temp7
    // determine z heights
    geta .sectnum temp9
    ifand sector.floorstat 1024
    {
        ifand sector.floorstat 512
            nullop
        else
        {
            gets .floorbunch temp
            ifg temp -1
                set temp9 temp
        }
    }
    getflorzofslope sprite.sectnum sprite.x sprite.y temp2
    set e_move_gtfo_temp 0
    ifn sprite.sectnum -1
        set e_move_gtfo_temp e_gtfo[sprite.sectnum]
    ifand e_move_gtfo_temp 4 ifg sprite.z temp2
        seta .z temp2
    else ifand sector.floorstat 1024
    {
        ifand sector.floorstat 512
            ifg sprite.z temp2
                seta .z temp2
    }
    else ifg sprite.z temp2
        seta .z temp2
    sub temp2 6144

    ife enemy_target player.i
    {
        getp .posz temp
        add temp 4096
    }
    else ifn enemy_target -1
        geta[enemy_target].z temp

    set temp3 temp
    ifl temp2 temp
    {
        ifand e_move_gtfo_temp 4
            set temp temp2
        else ifand sector.floorstat 1024
        {
            ifand sector.floorstat 512
                set temp temp2
        }
        else
            set temp temp2
    }
    set temp3 temp
    set temp5 temp6
    sub temp5 6144
    inv temp5
    shiftr temp5 3
    
    add temp temp5

    getflorzofslope sprite.sectnum sprite.x sprite.y temp2
    set temp4 temp2
    sub temp4 4096
    ifand e_move_gtfo_temp 4
        nullop
    else ifand sector.floorstat 1024
    {
        ifand sector.floorstat 512
            nullop
        else
        {
             ifand sector.floorstat 512
                nullop
            else
            {
                ifg sprite.z temp4 ifg temp9 -1
                {
                    ifl deacon_z 0
                        nullop
                    else
                        fall
                }
            }
        }
    }
    sub temp3 6144
    clamp temp temp3 temp2
    
    
    set temp9 -1
    ifand sector.ceilingstat 1024
    {
        ifand sector.ceilingstat 512
            nullop
        else
            gets .ceilingbunch temp9
    }
    ife temp9 -1
    {
        getceilzofslope sprite.sectnum sprite.x sprite.y temp2
        ifand sector.ceilingstat 1024
        {
            ifand sector.ceilingstat 512
            {
                set temp4 tilesizy[sprite.picnum]
                shiftl temp4 2
                mul temp4 sprite.yrepeat
                add temp2 temp4
                ifl sprite.z temp2
                    seta .z temp2
                ifl temp temp2
                    set temp temp2
                set temp2 sprite.z
            }
        }
        else
        {
            set temp4 tilesizy[sprite.picnum]
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            add temp2 temp4
            ifl sprite.z temp2
                seta .z temp2
            ifl temp temp2
                set temp temp2
            set temp2 sprite.z
        }
    }
    
    ifn enemy_shoot 0
        shiftr deacon_z 2
    else ifl sprite.z temp
    {
        ifl deacon_z -32
            shiftr deacon_z 2
        else
            add deacon_z 32
    }
    else ifg sprite.z temp
    {
        ifg deacon_z 32
            shiftr deacon_z 2
        else
            sub deacon_z 32
    }
    else
        shiftr deacon_z 2

    ifrnd 64 ifl sprite.z player.posz ife cansee_return 1 ife enemy_target player.i
    {
        set temp sprite.z
        sub temp player.posz
        abs temp
        ifg temp 20480
            add deacon_z 256
    }
    clamp deacon_z -1024 1024

    movesprite THISACTOR 0 0 deacon_z CLIPMASK0 temp7
    ifg enemy_minigun_dmg 0
    {
        set temp enemy_minigun_dmg
        shiftr temp 3
        clamp temp 1 65536
        sub enemy_minigun_dmg temp
    }
    state pup_damage_adjust
    set temp8 0
    ifn sprite.htowner -1
    {
        geta .htowner temp
        switch sprite[temp].picnum
            case A_DEACON
                seta .htextra -1
                break
        endswitch
        
        ifg sprite.htextra 0
        {
            ife sprite.htowner player.i
            {
                set temp8 1
                ife sprite.htpicnum BULLET
                {
                    switch player.curr_weapon
                        case WEAPON_MINIGUN
                            set temp4 sprite.htextra
                            shiftr temp4 1
                            add enemy_minigun_dmg temp4
                            break
                    endswitch
                }
                else ife sprite.htpicnum P_SMG2
                {
                    geta .htextra temp4
                    ifg p_pup_damage_time 0
                        clamp temp4 1 60
                    else
                        clamp temp4 1 30
                    seta .htextra temp4
                }
            }
        }
    }
    geta .htextra temp4
    ifhitweapon
    {
        ifrnd 127
        {
            rand temp 1
            add temp S_DEACON_PAIN1
            sound temp
        }
        ifwasweapon P_SHOCKER
        {
            add enemy_shocked 1
            ifg enemy_shocked 3
                set enemy_shocked 1
            set temp2 temp4
            mul temp2 enemy_shocked

            geta .extra temp3
            sub temp3 temp2
            seta .extra temp3
            ife se_ang 0
            {
                rand se_ang 1
                add se_ang 1
            }
        }
        ifn enemy_shocked 0
            action AC_DEACON_SHOCKED
        set temp6 temp4
        shiftl temp4 6
        set deacon_modzv temp4
        shiftr deacon_v 1
        ifdead
        {
            ifwasweapon EXPLOSION
                ife temp8 1
                    state crackthesecretofflight
            state enemy_die_resolve
            ifg temp6 70
            {
                state generic_gibs
                espawn A_EXPLOSION
                seta[RETURN].xrepeat 16
                seta[RETURN].yrepeat 16
                killit
            }
            else ifg enemy_minigun_dmg 35
            {
                state generic_gibs
                espawn A_EXPLOSION
                seta[RETURN].xrepeat 16
                seta[RETURN].yrepeat 16
                killit
            }
            state dying_blood
            action AC_DEACON_DYING
            rand temp 1
            add temp S_DEACON_DEATH1
            sound temp
            cstat 256
            seta .htextra -1
            set deacon_a sprite.htang
            set deacon_v temp6
            clamp deacon_v 0 512
            state enemy_clearw1alt
            break
        }
    }
    ifaction AC_DEACON_SHOCKED
    {
        ife sprite.htg_t 2 1
            state enemy_do_move
        set temp enemy_shocked
        shiftl temp 4
        add temp 1
        ifand sprite.htg_t 2 2
        {
            seta .shade 0
            seta .shade -127
            set enemy_skipshade 1
        }
        ifge sprite.htg_t 2 temp
        {
            action AC_DEACON_BASE
            set se_ang 0
        }
        else
        {
            set temp 24
            mul temp enemy_shocked
            add temp 32
            ife se_ang 1
                inv temp
            geta .ang temp2
            add temp2 temp
            and temp2 2047
            set move_v 32
            seta .ang temp2
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
            movesprite THISACTOR 0 0 256 CLIPMASK0 temp7
        }
        break
    }
    clamp deacon_modzv -16384 16384
    ifn deacon_modzv 0
    {
        movesprite THISACTOR 0 0 deacon_modzv CLIPMASK0 temp7
        ifg deacon_modzv 0
        {
            shiftr deacon_modzv 1
            set deacon_modzv -2
        }
        else
        {
            shiftl deacon_modzv 1
            ifl deacon_modzv -1024
                set deacon_modzv 0
        }
    }
    // seed initial forward velocity
    ife enemy_target player.i
    {
        ifl temp6 2048
        {
            ifrnd 16
                sub deacon_v 4
            else ifrnd 16
                add deacon_v 4
            clamp deacon_v -8 8
        }
        else
        {
            ifrnd 32
                add deacon_v 4
            else ifrnd 32
                sub deacon_v 2
        }
    }
    else
        add deacon_v 4
    clamp deacon_v -32 32
    geta .ang temp7
    state e_fp
    ifn way_current -1
        set enemy_target way_current
    
    // vary flight angle when moving close to player
    ifl temp6 2048 ife enemy_target player.i
    {
        set att_target enemy_target
        state angle_to_target
        ifl att_return 256
        {
            rand temp4 128
            add temp4 256
            ifrnd 127
                inv temp4
            add temp4 sprite.ang
            and temp4 2047
            seta .ang temp4
        }
    }
    set move_v deacon_v
    state move_actor
    
    // seed additional angle/turning adjustments to lower predictability
    ifrnd 16 ife enemy_target player.i
    {
        ife deacon_ac 0
        {
            getangle temp4 enemy_xv enemy_yv
            geta .ang att_return
            sub att_return temp4

            ifg att_return 1023
                sub att_return 2047
            ifl att_return -1023
                add att_return 2047
            shiftr att_return 2
            set temp2 att_return
            abs temp2
            ifg temp2 128
                shiftr att_return 1
            set deacon_a att_return
            set deacon_ac 4
        }
    }
    ifn deacon_ac 0
    {
        ifg deacon_ac 0
        {
            sub deacon_ac 1
            ifle deacon_ac 0
                set deacon_ac -1
        }
        else
        {
            shiftr deacon_a 2
            sub deacon_ac 1
            ifle deacon_ac -15
                set deacon_ac 0
        }
        sub temp7 deacon_a
        and temp7 2047
    }
    seta .ang temp7

    // turn slowly (consistently) toward target
    set att_target enemy_target
    set att_noclamp 1
    state angle_to_target
    set temp att_return
    shiftr temp 4
    set temp2 temp
    abs temp2
    ife temp 0 ifn att_return 0
    {
        ifl temp2 4
            set temp att_return
        else
        {
            set temp 1
            ifl att_return 0
                inv temp
        }
    }
    geta .ang temp2
    sub temp2 temp
    and temp2 2047
    seta .ang temp2
    
    set temp2 move_xv
    set temp3 move_yv
    // move back from player if too close
    ife enemy_target player.i
    {
        ifl temp6 1024
        {
            set face_target enemy_target
            state face_actor
            add face_return 1024
            and face_return 2047
            geta .ang temp4
            seta .ang face_return
            set move_v 16
            state move_actor
            seta .ang temp4
            ifand temp4 6
            {
                add enemy_xv temp2
                add enemy_yv temp3
            }
        }
    }
    add enemy_xv move_xv
    add enemy_yv move_yv
    
    // jitter left and right movement to create strafing patterns
    ife enemy_target player.i
    {
        ifrnd 64
            add enemy_xv 4
        else ifrnd 64
            add enemy_xv -4
        ifrnd 64
            add enemy_yv 4
        else ifrnd 64
            add enemy_yv -4
    }
    clamp enemy_xv -64 64
    clamp enemy_yv -64 64
    ifg enemy_shoot 0 ifl enemy_shoot 30
    {
        shiftr deacon_v 3
        shiftr enemy_xv 2
        shiftr enemy_yv 2
    }
    geta .ang temp7

    state enemy_do_move
    set drone_obstruction e_move_return // save to prevent later clobber
    seta .ang temp7
    getangle temp4 enemy_xv enemy_yv
    geta .ang att_return
    sub att_return temp4

    ifg att_return 1023
        sub att_return 2047
    ifl att_return -1023
        add att_return 2047
    set temp2 att_return
    abs temp2
    
    
    ifrnd 8
        ife enemy_shoot 0
            ife cansee_return 1
                ife enemy_target player.i
                {
                    set enemy_shoot 1
                    set face_target enemy_target
                    state face_actor
                    seta .ang face_return
                }
    ifg enemy_shoot 0
    {
        ifl enemy_shoot 30
        {
            ifaction AC_DEACON_SHOOT
                nullop
            else
            {
                rand temp 1
                add temp S_DEACON_ATTACK1
                sound temp
                action AC_DEACON_SHOOT
            }
            ldist temp enemy_target THISACTOR
            ifl temp 1536
            {
                set face_target enemy_target
                state face_actor
                seta .ang face_return
            }
            geta .x temp
            geta .y temp2
            geta .sectnum temp3
            geta .z temp4
            sub temp4 1024
            seta .z temp4
            set move_v 10
            state move_actor
            movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp7
            switch sprite.htg_t 2
                case 2
                case 4
                case 6
                case 8
                case 10
                case 12
                    ife enemy_shoot 1
                    {
                        ifand sprite.htg_t 2 2
                        {
                            sound S_DEACON_MISSILE
                            eshoot P_MINIMISSILE
                            setav[RETURN].minimissile_t enemy_target
                        }
                        else
                        {
                            geta .ang temp5
                            set temp6 temp5
                            sub temp5 512
                            and temp5 2047
                            seta .ang temp5
                            set move_v 512
                            state move_actor
                            movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp7
                            seta .ang temp6
                            sound S_DEACON_MISSILE2
                            eshoot P_MINIMISSILE
                            setav[RETURN].minimissile_t enemy_target
                        }
                        set enemy_shoot 2
                    }
                    break
                default
                    set enemy_shoot 1
                    break
            endswitch
            seta .x temp
            seta .y temp2
            seta .sectnum temp3
            geta .z temp4
            add temp4 1024
            seta .z temp4
            ifactioncount 13
            {
                action AC_DEACON_BASE
                set enemy_shoot 120
            }
            break
        }
        else
        {
            sub enemy_shoot 1
            ife enemy_shoot 30
                set enemy_shoot 0
        }
    }
    // use previously captured angle of movement to determine displayed action
    ifge temp2 320
        action AC_DEACON_BW
    else
    {
        ife enemy_target player.i
            set temp3 120
        else
            set temp3 180
        ifge temp2 temp3
        {
            ifg att_return 0
                action AC_DEACON_L
             else
                action AC_DEACON_R
        }
        else
        {
            set temp2 enemy_xv
            set temp3 enemy_yv
            abs temp2
            abs temp3
            add temp2 temp3
            ifg temp2 48
                action AC_DEACON_FW
            else
                action AC_DEACON_BASE
        }
    }
    
    getflorzofslope sprite.sectnum sprite.x sprite.y temp2
    ifle sprite.z temp2
    {
        geta .x pivot_xoff
        geta .y pivot_yoff
        geta .z pivot_zoff
        geta .sectnum cam_xoff
        geta .htfloorz cam_yoff
        geta .zvel cam_zoff
    }
    else ifl sprite.htg_t 0 10
    {
        geta .x pivot_xoff
        geta .y pivot_yoff
        geta .z pivot_zoff
        geta .sectnum cam_xoff
        geta .htfloorz cam_yoff
        geta .zvel cam_zoff
    }

    ifg sprite.extra 0 // move up and down when alive and bumping into ceiling or floors of the next sector
    {
        ifgapzl 32
            nullop
        else
        {
            set temp4 tilesizy[sprite.picnum]
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            set temp3 sprite.z
            sub temp3 temp4
            ifge drone_obstruction 32768
            {
                ifl drone_obstruction 49152
                {
                    sub drone_obstruction 32768
                    set temp drone_obstruction
                    ifn wall[temp].nextsector -1
                    {
                        ifn wall[temp].nextwall -1
                        {
                            getw[temp].nextsector temp
                            ifn temp -1
                            {
                                getflorzofslope temp sprite.x sprite.y temp2
                                ifg temp3 temp2
                                {
                                    getceilzofslope temp sprite.x sprite.y temp3
                                    sub temp3 temp2
                                    abs temp3
                                    ifceilingdistl 4
                                        nullop
                                    else ifg temp3 4096
                                        movesprite THISACTOR 0 0 -1024 CLIPMASK0 temp7
                                }
                                else
                                {
                                    getceilzofslope temp sprite.x sprite.y temp2
                                    ifl temp3 temp2
                                    {
                                        getflorzofslope temp sprite.x sprite.y temp3
                                        sub temp3 temp2
                                        abs temp3
                                        iffloordistl 4
                                            nullop
                                        else ifg temp3 4096
                                            movesprite THISACTOR 0 0 1024 CLIPMASK0 temp7
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        set drone_obstruction -1
        getflorzofslope sprite.sectnum sprite.x sprite.y temp2
        ifg sprite.z temp2
        {
            seta .x pivot_xoff
            seta .y pivot_yoff
            seta .z pivot_zoff
            seta .sectnum cam_xoff
            seta .htfloorz cam_yoff
            seta .zvel cam_zoff
            movesprite THISACTOR 0 0 -4096 CLIPMASK0 temp7
        }
    }
enda

action AC_ARCHANGEL_BASE 0 1 5 1 1
action AC_ARCHANGEL_WALK 25 4 5 1 16
action AC_ARCHANGEL_SHOOT 50 4 5 1 8
action AC_ARCHANGEL_TPORT 75 4 5 1 8
action AC_ARCHANGEL_HIT 100 1 5 1 1
action AC_ARCHANGEL_DIE 115 12 1 1 4

appendevent EVENT_SPAWN
    switch sprite.picnum
        case A_ARCHANGEL
            sizeat 26 23
            cstat 257
            state clear_enemy_vels
            ifspritepal 7
                set counter2 1
            spritepal 0
            state enemy_spawn_checkhitag
            break
        case A_ARCHANGEL_DEAD
            sizeat 26 23
            cstat 0
            break
    endswitch
endevent
spriteshadow A_ARCHANGEL
spritenoshade A_ARCHANGEL

eventloadactor A_ARCHANGEL
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda
var arch_tsprcstat 0 2
var arch_savez 0 2
var arch_tport_freq 0 2

appendevent EVENT_ANIMATESPRITES
    ifactor A_ARCHANGEL
    {
        ifn sprite.pal 77
            ifn tspr.tsprpal 77
                gettspr .tsprcstat arch_tsprcstat
       
       ife tspr.tsprpal 77
       {
            settspr .tsprcstat 2
            ifand sprite.cstat 2
            {
               settspr .tsprblend 255
               settspr .tsprz arch_savez
            }
            else
                settspr .tsprblend 0
        }
    }
endevent
useractor notenemy A_ARCHANGEL_DEAD 0 AC_BASE
    ifand sprite.cstat 4
        cstat 4
    else
        cstat 0
    fall
    set actor_gib 2
    changespritestat THISACTOR STAT_STATIC_GIB
enda
useractor enemy A_ARCHANGEL ARCHANGEL_HEALTH AC_ARCHANGEL_BASE
    ifspritepal 7
        set counter2 1
    ifaction AC_ARCHANGEL_TPORT
        nullop
    else iffloordistl 1
        geta .z arch_savez
    clipdist 64
    ife enemy_skipshade 1
    {
        set enemy_skipshade 2
        set counter3 10
    }
    else
    {
        set enemy_skipshade 2
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
    }
    geta .shade temp
    clamp temp -127 15
    ifg counter3 0
    {
        sub counter3 1
        sub temp counter3
    }
    ifrnd 96
        rand counter3 10
    clamp temp -127 10
    seta .shade temp
    spritepal 0
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break
        
    ifg arch_tport_freq 0
        sub arch_tport_freq 1
    set cansee_target player.i
    set cansee_height 8192
    state cansee_actor

    ifg se_hitag 0
    {
        set temp 0
        ifand se_lotag 1
            set temp 1
        else ife enemy_ife 1
            set temp 1
        ife temp 1
        {
            set cansee_return 0
            set cansee_return_o 0
            set enemy_cantsee 10
        }
    }
    
    set reverse_dir 0
    state e_wakemeup
    ife skip_see 1
    {
        set cansee_return 0
        set enemy_cantsee 5
    }
    ife cansee_return 1 ife skip_see 0
    {
        ifand se_lotag 1
        {
            set cansee_return 0
            set enemy_cantsee 5
        }
        else
            set se_hitag 0
    }
    state enemy_do_target_icon
    ife cansee_return_o 1
        state enemy_checkw1alt
    state enemy_check_init
    ife enemy_init_return 1
    {
        fall
        break
    }
    ifg need_spot_sound 1
    {
        sub need_spot_sound 1
        ife need_spot_sound 1
        {
            ifrnd 32
                ifaction AC_ARCHANGEL_WALK
                {
                    rand temp 1
                    add temp S_SKINJOB_ROAM1
                    sound temp
                }
            set need_spot_sound 90
        }
    }
    ife cansee_return 1
    {
        set enemy_cantsee 0
        set enemy_target player.i
        set way_current -1
        ife need_spot_sound 0
        {
            set need_spot_sound 90
            rand temp 1
            add temp S_SKINJOB_RECOG1
            sound temp
        }
    }
    else
    {
        sleeptime 300
        ifl enemy_cantsee 5
        {
            add enemy_cantsee 1
            set enemy_target player.i
            set enemy_idle_count enemy_cantsee
            set way_current -1
        }
        else
        {
            state e_fp
            ifn way_current -1
                ife sprite[way_current].extra -1
                    ife sprite[way_current].statnum STAT_WAYPOINT
                        set way_current -1
            ifn way_current -1
                set enemy_target way_current
            else
                set enemy_target player.i
            ifl enemy_cantsee 30
                add enemy_cantsee 1
        }
    }
    
    fall
    
    ldist temp6 enemy_target THISACTOR
    add enemy_strafe 1
    ifg enemy_strafe 120
        inv enemy_strafe
    ifaction AC_ARCHANGEL_WALK ife enemy_target player.i
    {
        set temp temp6
        shiftr temp 5
        clamp temp 0 480
        ifle temp 16
            set temp 0
        set face_target enemy_target
        state face_actor
        ifl enemy_strafe 0
            inv temp
        
        
        add face_return temp
        and face_return 2047
        seta .ang face_return
    }
    set att_target enemy_target
    set att_noclamp 1
    state angle_to_target
    set temp att_return
    ifaction AC_ARCHANGEL_SHOOT
    {
        ifl sprite.htg_t 2 3
        {
            ifl sprite.htg_t 2 2
                nullop
            else
                shiftr temp 3
        }
        else
        {
            set temp 0
            set att_return 0
        }
    }
    else
        shiftr temp 4
    set temp2 temp
    abs temp2
    ifl temp2 4
        set temp att_return
    ife temp 0 ifn att_return 0
    {
        set temp 1
        ifl att_return 0
            inv temp
    }
    geta .ang temp2
    sub temp2 temp
    and temp2 2047
    seta .ang temp2
    
    ifg enemy_shoot 0
        sub enemy_shoot 1
    ifg enemy_dodge 0
        sub enemy_dodge 1
    ifg enemy_minigun_dmg 0
    {
        set temp enemy_minigun_dmg
        shiftr temp 4
        ife temp 0
            set temp 1
        sub enemy_minigun_dmg temp
        clamp enemy_minigun_dmg 0 65536
    }
  /*  qputs 11 %ld
        qsprintf 11 11 enemy_minigun_dmg
        quote 11 */
    state pup_damage_adjust
    geta .htextra temp
    ife sprite.htowner THISACTOR // no self damage
    {
        set temp -1
        seta .htextra temp
    }
    ifg temp 0
    {
        ife sprite.htowner player.i
        {
            ife sprite.htpicnum BULLET
            {
                switch player.curr_weapon
                    case WEAPON_LOVERBOY
                        set temp4 sprite.htextra
                        shiftr temp4 2
                        add enemy_minigun_dmg sprite.htextra
                        add enemy_minigun_dmg temp4
                        break
                    case WEAPON_SHOTGUN
                        set temp4 sprite.htextra
                        shiftr temp4 1
                        add enemy_minigun_dmg temp4
                        shiftr temp4 2
                        add enemy_minigun_dmg temp4
                        break
                    case WEAPON_MINIGUN
                        set temp4 sprite.htextra
                        shiftr temp4 1
                        add enemy_minigun_dmg temp4
                        shiftr temp 1
                        break
                endswitch
            }
            else
            {
                ife sprite.htpicnum A_EXPLOSION
                    nullop
                else ife sprite.htpicnum P_BOWLINGBOMB
                    nullop
                else ife sprite.htpicnum P_SMG2
                {
                    set temp4 sprite.htextra
                    shiftr temp4 3
                    add enemy_minigun_dmg temp4
                }
                else
                    shiftr temp 1
                set temp4 sprite.htextra
                shiftr temp4 1
                add enemy_minigun_dmg temp4
            }
        }
        else ife sprite.htowner THISACTOR
            set temp -1
        shiftr temp 1
        add enemy_minigun_dmg temp
        ife temp 0
            set temp 1
        seta .htextra temp
    }
    geta .htextra temp
    ifhitweapon
    {
        
        ifaction AC_ARCHANGEL_DIE
            nullop
        else ifwasweapon P_SHOCKER
        {
            add enemy_shocked 1
            ifg enemy_shocked 3
                set enemy_shocked 1

            mul temp enemy_shocked

            geta .extra temp3
            sub temp3 temp
            seta .extra temp3
            rand temp 3
            add temp 3
            for itervar range temp
            {
                espawn A_GENERIC_PARTICLE
                seta[RETURN].xrepeat 120
                seta[RETURN].pal 6

                rand temp2 512
                ifrnd 127
                    inv temp2
                add temp2 sprite.htang
                add temp2 1024
                seta[RETURN].ang temp2


                geta .picnum temp2
                set temp4 tilesizy[temp2]
                shiftl temp4 2
                mul temp4 sprite.yrepeat
                set temp2 sprite.z
                rand temp3 temp4
                sub temp2 temp3
                seta[RETURN].z temp2

                rand temp2 128
                ifrnd 127
                    inv temp2
                add temp2 sprite.x
                seta[RETURN].x temp2
                rand temp2 128
                ifrnd 127
                    inv temp2
                add temp2 sprite.y
                seta[RETURN].y temp2
                spritepal 63
                set enemy_skipshade 1
                seta .shade 0
                ifaction AC_ARCHANGEL_TPORT
                {
                    rand temp 1
                    add temp S_SKINJOB_PAIN1
                    sound temp
                    action AC_ARCHANGEL_HIT
                    cstat 257
                }
            }
        }
        geta .z temp
        sub temp 8192
        seta .z temp
        state dying_blood
        add temp 8192
        seta .z temp
        ifpdistl 10240
        {
            rand temp 2
            add temp S_BULLET_FLESH1
            soundvar temp
            sound S_GIBDROP01
            sound S_GIBSPLODE02_Q
        }
        ifge enemy_minigun_dmg 70
        {
            ifaction AC_ARCHANGEL_DIE
                nullop
            else
            {
                rand temp 1
                add temp S_SKINJOB_PAIN1
                sound temp
                action AC_ARCHANGEL_HIT
            }
            set enemy_minigun_dmg 0
        }
        ife counter2 1 // big explosion type
        {
            ifaction AC_ARCHANGEL_DIE
                strength ARCHANGEL_DIE_HEALTH
        }
        ifdead
        {
            state enemy_clearw1alt
            move AM_ENEMY_SEARCH_STOP
            ifaction AC_ARCHANGEL_DIE
            {
                for temp range 10
                {
                    state dying_blood
                    espawn A_SMOKE2
                    seta[RETURN].xrepeat 2
                    seta[RETURN].yrepeat 2
                    seta[RETURN].pal 7
                    rand temp2 2047
                    seta[RETURN].ang temp2
                    rand temp2 1024
                    seta[RETURN].xvel temp2
                    rand temp2 -8192
                    seta[RETURN].zvel temp2
                    ssp RETURN 0
                }
                espawn A_NAPALM_FLAME
                seta[RETURN].xvel 10
                ssp RETURN 0
                seta[RETURN].pal 6
                sound S_GIBSPLODE02
                sound S_GIBSPLODE03
                sound S_IMPACT_HEADSHOT
                state generic_gibs
                strength 0
                state enemy_die_resolve
                spawn A_ARCHANGEL_DEAD
                killit
            }
            else
            {
                sound S_SKINJOB_DIE1
                action AC_ARCHANGEL_DIE
                strength ARCHANGEL_DIE_HEALTH
                cstat 257
            }
            set counter 0
            set enemy_minigun_dmg 0
        }
    }
    ifaction AC_ARCHANGEL_HIT
    {
        cstat 257
        ifg arch_tport_freq 0
            shiftr arch_tport_freq 1
        ifactioncount 15
        {
            ifrnd 64 ife arch_tport_freq 0
            {
                ifrnd 32
                {
                    rand temp 1
                    add temp S_SKINJOB_TPORT1
                    sound temp
                }
                action AC_ARCHANGEL_TPORT
                set counter 0
            }
            else
                action AC_ARCHANGEL_BASE
        }
        else
        {
            set move_v sprite.htg_t 2
            shiftl move_v 2
            sub move_v 15
            clamp move_v -15 0
            inv move_v
            shiftl move_v 5
            geta .ang temp6
            seta .ang sprite.htang
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
            seta .ang temp6
        }
    }
    ifaction AC_ARCHANGEL_DIE
    {
        ifrnd 64
            state dying_blood
        geta .htg_t 2 temp
        clamp temp 0 12
        ifl counter 55
        {
            ifg temp 3
            {
                mod temp 4
                add temp 4
                ifand temp 2
                {
                    set enemy_skipshade 2
                    seta .shade -20
                }
            }
            else
                clamp temp 0 4
        }
        else ife counter 55
        {
            set temp 4
            add counter 1
        }
        else
        {
            ifge counter 60
            {
                add counter 1
                set temp counter
                sub temp 60
                shiftr temp 2
                add temp 8
                seta .htg_t 3 temp
            }
        }
        ifge temp 8
        {
            ifg temp 8
                spritepal 61
            seta .shade -20
        }
        seta .htg_t 2 temp
        ifge temp 4 ifle counter 60
        {
            seta .htg_t 3 temp
            add counter 1
            set temp counter 
            shiftl temp 1
            add temp 256
            setp .sound_pitch temp
            sound S_HEART_BEEP
            setp .sound_pitch 0
            ife counter 60
            {
                hitradius 3072 32 40 50 60
                espawn A_EXPLOSION
                seta[RETURN].pal 6
                seta[RETURN].xrepeat 48
                seta[RETURN].yrepeat 32
                seta[RETURN].cstat 130
                setav[RETURN].smoke_offset -2048
                
                ife counter2 1
                {
                    for itervar range 5
                    {
                        espawn A_EXPLOSION
                        seta[RETURN].pal 6
                        seta[RETURN].xrepeat 32
                        seta[RETURN].yrepeat 32
                        seta[RETURN].cstat 130
                        rand temp 2047
                        seta[RETURN].ang 130
                        rand temp 512
                        shiftl temp 1
                        set temp8 itervar
                        shiftl temp8 6
                        add temp temp8
                        seta[RETURN].xvel temp
                        rand temp -3072
                        shiftl temp 1
                        set temp8 itervar
                        shiftl temp8 11
                        sub temp temp8
                        seta[RETURN].zvel temp
                        ssp RETURN 0
                        setav[RETURN].explosion_nosmoke 1
                    }
                }
                
                // setav[RETURN].explosion_nosmoke 1
                // setav[RETURN].explosion_silent 1
                rand temp 3
                add temp 5
                set temp8 temp
                for itervar range temp8
                {
                    espawn A_NAPALM_FLAME
                    rand temp2 2047
                    seta[RETURN].ang temp2
                    rand temp2 256
                    add temp2 256
                    seta[RETURN].xvel temp2
                    rand temp2 512
                    add temp2 1536
                    set temp3 temp
                    shiftl temp3 3
                    add temp2 temp3
                    inv temp2
                    seta[RETURN].zvel temp2
                    geta[RETURN].z temp2
                    set temp3 temp
                    shiftl temp3 8
                    sub temp2 temp3
                    seta[RETURN].z temp2
                    ssp RETURN 0
                    sub temp 1
                    seta[RETURN].pal 6
                }
                
                rand temp 3
                add temp 5
                set temp8 temp
                for itervar range temp8
                {
                    espawn A_NAPALM_FLAME
                    rand temp2 2047
                    seta[RETURN].ang temp2
                    rand temp2 256
                    add temp2 256
                    seta[RETURN].xvel temp2
                    rand temp2 512
                    add temp2 256
                    inv temp2
                    seta[RETURN].zvel temp2
                    ssp RETURN 0
                    sub temp 1
                    seta[RETURN].pal 6
                }
                strength 0
                state enemy_die_resolve
            }
        }
        ifactioncount 12
        {
            spawn A_ARCHANGEL_DEAD
            killit
        }
    }
    ifaction AC_ARCHANGEL_BASE
    {
        ifrnd 64
            action AC_ARCHANGEL_WALK
        else ifrnd 8 iffloordistl 1 ife enemy_dodge 0 ifle arch_tport_freq 30
        {
            ifrnd 32
            {
                rand temp 1
                add temp S_SKINJOB_TPORT1
                sound temp
            }
            action AC_ARCHANGEL_TPORT
        }
        set counter 0
    }
    ifaction AC_ARCHANGEL_WALK
    {
        geta .htg_t 2 temp
        set temp2 sprite.htpicnum
        set temp3 temp2
        mod temp 4
        ifle arch_tport_freq 30
        {
            ifand sprite.cstat 514
            {
                geta .cstat temp4
                xor temp4 514
                seta .cstat temp4
                seta .blend 0
                spritepal 0
            }
        }
        else ifand sprite.cstat 514
        {
            seta .blend 255
            spritepal 77
        }
        ife temp 0
        {
            ifge counter 12
                inv counter
        }
        else
            sub temp2 1
        iffloordistl 1
            nullop
        else
            set enemy_stepcounter 1
        switch temp
            case 1
            case 3
                ifpdistl 8192 ife enemy_stepcounter 0
                {
                    gets .floorpicnum surface_type
                    setp .sound_pitch -64
                    state player_footstep
                    setp .sound_pitch -690
                    sound S_STEP_METAL_WALK1
                    setp .sound_pitch 0
                    set enemy_stepcounter 1
                }
                break
            default
                set enemy_stepcounter 0
                break
        endswitch
        ifge counter 12
            inv counter
        add counter 1
        set temp2 counter
        abs temp2
        shiftr temp2 1
        set temp 34
        add temp temp2

//        ifn enemy_target player.i
        shiftl temp 1
        set move_v temp
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        geta .ang temp7
        state enemy_do_move
        // movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp
        ifn e_move_return 0
        {
            inv enemy_strafe
            ifl enemy_strafe 0
                set enemy_strafe -120
            else
                set enemy_strafe 0
            ife enemy_target player.i
                seta .ang temp7
        }
        ifand counter 4
        {
            geta .ang temp
            rand temp2 16
            ifrnd 127
                inv temp2
            add temp temp2
            and temp 2047
            seta .ang temp
        }
        ifrnd 4 iffloordistl 1 ife enemy_dodge 0 ife arch_tport_freq 0
        {
            ifand sprite.cstat 514
            {
                geta .cstat temp4
                xor temp4 514
                seta .cstat temp4
                seta .blend 0
                spritepal 0
            }
            ifrnd 32
            {
                rand temp 1
                add temp S_SKINJOB_TPORT1
                sound temp
            }
            action AC_ARCHANGEL_TPORT
            set counter 0
        }
        ife enemy_target player.i
            ife cansee_return 1
            {
                set temp counter
                abs temp
                rand temp2 255
                ifg arch_tport_freq 0
                    shiftr temp2 1
                ifl temp2 8
                    ifl temp 6
                        ife enemy_shoot 0
                        {
                            set counter 0
                            rand temp 1
                            add temp S_SKINJOB_ATTACK1
                            sound temp
                            action AC_ARCHANGEL_SHOOT
                            ifand sprite.cstat 514
                            {
                                geta .cstat temp4
                                xor temp4 514
                                seta .cstat temp4
                                seta .blend 0
                                spritepal 0
                            }
                        }
            }
    }
    
    ifaction AC_ARCHANGEL_TPORT
    {
        set arch_tport_freq 150
        ife counter 0
        {
            geta .ang temp
            rand temp2 128
            add temp2 128
            ifrnd 127
                inv temp2
            add temp temp2
            and temp 2047
            seta .ang temp
            add counter 1
            ifpdistl 8192
                sound S_CROSSBOW_SLAM2

        }
        geta .htg_t 2 temp
        clamp temp 0 4
        seta .htg_t 2 temp
        ife temp 4
        {
            ifg counter 10
            {
                set enemy_skipshade 2
                set temp3 counter
                shiftl temp3 1
                seta .shade temp3
            }
            cstator 514
            geta .mdflags temp3
            or temp3 16
            seta .mdflags temp3
            seta .htg_t 3 temp
            add counter 1
            set move_v 512
            add move_v counter
            state move_actor
            seta .zvel 0
            ssp THISACTOR CLIPMASK0
            set enemy_xv move_xv
            set enemy_yv move_yv
            geta .ang temp7
            state enemy_do_move
            seta .ang temp7
            movesprite THISACTOR 0 0 -256 CLIPMASK0 temp
            seta .ang temp7
            set temp arch_savez
            sub temp 4096
            sub temp sprite[player.i].z
            abs temp
            ifl temp 8192
            {
                ifl sprite[player.i].z arch_savez
                {
                    shiftr temp 2
                    clamp temp 256 1536
                    movesprite THISACTOR 0 0 -temp CLIPMASK0 temp
                    seta .ang temp7
                }
            }
            ifand counter 1
            {
                espawn FRAMEEFFECT1
                seta[RETURN].blend 129
                seta[RETURN].shade 40
                seta[RETURN].cstat arch_tsprcstat
                geta[RETURN].htflags temp
                or temp 4
                seta[RETURN].htflags temp
            }
            seta .blend 129
            ifge counter 15
            {
                cstat 257
                seta .blend 129
                set counter 0
                ifrnd 16
                {
                    set enemy_dodge 60
                    set temp 0
                    ife enemy_shoot 0
                        ife enemy_target player.i
                            ife cansee_return 1
                                set temp 1
                    ife temp 1
                        action AC_ARCHANGEL_SHOOT
                    else
                        action AC_ARCHANGEL_WALK
                }
                else
                {
                    action AC_ARCHANGEL_WALK
                    set enemy_dodge 30
                }
                ifaction AC_ARCHANGEL_WALK
                    cstator 514
            }
        }
        else
        {
            seta .zvel 0
            ssp THISACTOR CLIPMASK0
            movesprite THISACTOR 0 0 -2048 CLIPMASK0 temp
        }
        getceilzofslope sprite.sectnum sprite.x sprite.y temp
        set temp4 tilesizy[sprite.picnum]
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        add temp temp4
        ifl sprite.z temp
            seta .z temp
    }
    else
    {
        geta .mdflags temp3
        ifand temp3 16
            xor temp3 16
        seta .mdflags temp3
    }
    ifaction AC_ARCHANGEL_SHOOT
    {
        set enemy_shoot 30
        add counter 1
        ifl counter 5
            action AC_ARCHANGEL_SHOOT
        else ife counter 5
        {
            ifpdistl 12288
            {
                setp .sound_pitch -768
                randvar temp 1
                add temp S_CROSSBOW_FIRE2
                soundvar temp
                setp .sound_pitch 0
            }
            geta .x temp
            geta .y temp2
            geta .sectnum temp3
            geta .z temp4
            geta .htfloorz e_movetemp
            geta .zvel e_movetemp2
            set temp5 temp4
            iffloordistl 1
                sub temp5 256
            else
                add temp5 3072
            sub temp5 3072
            seta .z temp5
            set move_v 10
            state move_actor
            movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp7

            geta .ang temp5
            set temp6 temp5
            sub temp5 512
            and temp5 2047
            seta .ang temp5
            set move_v 256
            state move_actor
            movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp7
            seta .ang temp6
            eshoot P_FLAMINGSKULL
            setav[RETURN].minimissile_t player.i
            geta[RETURN].z temp5
            add temp5 3072
            seta[RETURN].z temp5
            seta .x temp
            seta .y temp2
            seta .sectnum temp3
            seta .z temp4
            seta .htfloorz e_movetemp
            seta .zvel e_movetemp2
        }
        else ifg counter 20
        {
            set counter 0
            action AC_ARCHANGEL_BASE
        }
        geta .htg_t 2 temp
        clamp temp 0 4
        seta .htg_t 2 temp
        ife temp 4
            seta .htg_t 3 temp
    }
enda


appendevent EVENT_SPAWN
    switch sprite.picnum
        case A_WENTEKO
            ife sector.lotag 1
                set enemy_thisisahack 1
            sizeat 26 23
            cstat 257
            spritepal PAL_WENTEKO
            state clear_enemy_vels
            state enemy_spawn_checkhitag
            break
        case A_WENTEKO_DEAD1:
        case A_WENTEKO_DEAD2:
            sizeat 26 23
            spritepal PAL_WENTEKO
            cstat 256
            break
    endswitch
endevent

action AC_WENTEKO_STAND 0 1 5 1 1
action AC_WENTEKO_WALK 10 6 5 1 12
action AC_WENTEKO_RUN 10 6 5 1 4
action AC_WENTEKO_CHARGE 10 6 5 1 2
action AC_WENTEKO_SWIPE 45 5 5 1 8
action AC_WENTEKO_LEAP_START 155 1 5 1 1
action AC_WENTEKO_LEAP 155 4 5 1 1
action AC_WENTEKO_LEAP_SWIPE 170 3 5 1 12
action AC_WENTEKO_LEAP_END 10 6 5 1 12
action AC_WENTEKO_SWIPE_DOUBLE 75 7 5 1 12
action AC_WENTEKO_HIT 115 1 5 1 1
action AC_WENTEKO_SHOCKED 115 2 5 1 1
action AC_WENTEKO_HIT2 130 1 1 1 1
action AC_WENTEKO_DYING 142 7 1 1 12
action AC_WENTEKO_DYING2 130 7 1 1 12

var last_htextra 0 2

useractor notenemy A_WENTEKO_DEAD1 CORPSE_HEALTH
    state enemy_body_code
enda
useractor notenemy A_WENTEKO_DEAD2 CORPSE_HEALTH
    state enemy_body_code
enda

eventloadactor A_WENTEKO
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda

useractor enemy A_WENTEKO WENTEKO_HEALTH AC_WENTEKO_STAND
    /* qputs 11 %ld %ld %ld
    qsprintf 11 11 sprite.extra last_htextra enemy_minigun_dmg
    quote 11 */

    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
        geta .shade temp
        sub temp 4
        seta .shade temp
    }
    else
        set enemy_skipshade 0
    // misc setup for cansee nonsense
    set cansee_target player.i
    set cansee_height 8192
    getceilzofslope sprite.sectnum sprite.x sprite.y temp
    geta .z temp2
    sub temp2 cansee_height
    ifl temp2 temp
        set cansee_height 4096
    state cansee_actor
    
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break

    state e_wakemeup
    ife skip_see 1
    {
        set cansee_return 0
        set enemy_cantsee 5
    }
    ife cansee_return 1 ife skip_see 0
    {
        ifand se_lotag 1
        {
            set cansee_return 0
            set enemy_cantsee 5
        }
        else
            set se_hitag 0
    }
    state enemy_do_target_icon
    ife cansee_return_o 1
        state enemy_checkw1alt
    state enemy_check_init
    ife enemy_init_return 1
    {
        fall
        break
    }
    
    ife cansee_return 1
    {
        set enemy_cantsee 0
        set enemy_target player.i
        set way_current -1
    }
    else
    {
        sleeptime 300
        ifl enemy_cantsee 5
        {
            add enemy_cantsee 1
            set enemy_target player.i
            set enemy_idle_count enemy_cantsee
            set way_current -1
        }
        else
        {
            state e_fp
            ifn way_current -1
                ife sprite[way_current].extra -1
                    ife sprite[way_current].statnum STAT_WAYPOINT
                        set way_current -1
            ifn way_current -1
                set enemy_target way_current
            else
                set enemy_target player.i
            ifl enemy_cantsee 30
                add enemy_cantsee 1
            else
            {
                ifaction AC_WENTEKO_WALK
                {
                    ifrnd 32
                        action AC_WENTEKO_RUN
                }
                else ifaction AC_WENTEKO_RUN
                    ifrnd 3
                        action AC_WENTEKO_CHARGE
            }
        }
        
    }
    
    ifg enemy_stop 0
    {
        sub enemy_stop 1
        ifn enemy_stop 0
         ifge userdef.player_skill 4
            sub enemy_stop 1
    }
    fall
    ife enemy_thisisahack 1
    {
        ifn sector.lotag 1
            set enemy_thisisahack 0
        seta .htbposz sprite.z
    }
    set temp8 0
    switch sprite.htg_t 4
        case AC_WENTEKO_DYING
        case AC_WENTEKO_DYING2
            seta .ang sprite.htang
            set move_v sprite.htextra
            clamp move_v -24 24
            set temp 8
            sub temp sprite.htg_t 2
            add temp 1
            shiftl move_v temp
            shiftr move_v 1
            inv move_v
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            state enemy_do_move
            
            ifactioncount 7
            {
                state enemy_die_resolve
                action AC_ENEMY_BODY
                seta .htextra -1
                cstat 256
                strength CORPSE_HEALTH
                state enemy_die_cleartags
                ifaction AC_WENTEKO_DYING2
                    cactor A_WENTEKO_DEAD2
                else
                    cactor A_WENTEKO_DEAD1
            }
            set temp8 1
            break
    endswitch
    ife temp8 1
        break
    state pup_damage_adjust
    geta .htextra temp
    ifg temp 0
    {
        ife sprite.htpicnum EXPLOSION
            nullop
        else
            div temp 3
        ife sprite.htpicnum P_SMG2
        {
            shiftr temp 1
            ifg p_pup_damage_time 0
                clamp temp 1 14
            else
                clamp temp 1 7
        }
        clamp temp 1 65536
        
        ife sprite.htpicnum BULLET ife sprite.htowner player.i
        {
            ife player.curr_weapon WEAPON_LOVERBOY ifn weapon1_alt 0
            {
                shiftl temp 1
                seta .htextra temp
            }
        }
        seta .htextra temp
        set last_htextra temp
        shiftr temp 2
        ife sprite.htpicnum P_SMG2
            shiftr temp 1
        clamp temp 1 65536
        add enemy_minigun_dmg temp
    }
  
    geta .htextra temp
    ifhitweapon
    {
        ifaction AC_ARCHANGEL_TPORT
            nullop
        else ifand sprite.cstat 514
        {
            geta .cstat temp4
            xor temp4 514
            seta .cstat temp4
            seta .blend 0
            spritepal 0
        }
        set temp2 WENTEKO_HEALTH
        shiftr temp2 4
        clamp temp2 1 65536
        ifdead
        {
            state enemy_clearw1alt
            cstat 0
            state dying_blood
            stopactorsound THISACTOR S_WENTEKO_BREATHE_1
            stopactorsound THISACTOR S_WENTEKO_BREATHE_2
            sound S_WENTEKO_DIE_1
            ifrnd 127
                action AC_WENTEKO_DYING2
            else
                action AC_WENTEKO_DYING
            break
        }
        else
        {
            ifwasweapon P_SHOCKER
            {
                stopactorsound THISACTOR S_WENTEKO_BREATHE_1
                stopactorsound THISACTOR S_WENTEKO_BREATHE_2
                rand temp3 1
                add temp3 S_WENTEKO_HIT_1
                sound temp3
                add enemy_shocked 1
                ifg enemy_shocked 3
                    set enemy_shocked 1
                shiftl temp 1
                mul temp enemy_shocked

                geta .extra temp3
                sub temp3 temp
                seta .extra temp3
                action AC_WENTEKO_SHOCKED
            }
            else ifg enemy_minigun_dmg temp2
            {
                stopactorsound THISACTOR S_WENTEKO_BREATHE_1
                stopactorsound THISACTOR S_WENTEKO_BREATHE_2
                rand temp3 1
                add temp3 S_WENTEKO_HIT_1
                sound temp3
                ifrnd 64
                    action AC_WENTEKO_HIT2
                else
                    action AC_WENTEKO_HIT
                set enemy_minigun_dmg 0
            }
        }
    }
    ifdead
    {
        set temp 0
        ifaction AC_WENTEKO_DYING2
            set temp 1
        else ifaction AC_WENTEKO_DYING
            set temp 1
        ife temp 0
        {
            spritepal PAL_WENTEKO
            stopactorsound THISACTOR S_WENTEKO_BREATHE_1
            stopactorsound THISACTOR S_WENTEKO_BREATHE_2
            sound S_WENTEKO_DIE_1
            ifrnd 127
                action AC_WENTEKO_DYING2
            else
                action AC_WENTEKO_DYING
            break
        }
    }
    set temp 0
    switch sprite.htg_t 4
        case AC_WENTEKO_HIT
        case AC_WENTEKO_HIT2
            ifactioncount 7
            {
                action AC_WENTEKO_STAND
                set enemy_stop 3
            }
            set temp 1
            break
        case AC_WENTEKO_SHOCKED
            set temp2 enemy_shocked
            mul temp2 7
            set enemy_stop 3
            ifmove AM_ENEMY_SEARCH
                move AM_ENEMY_SEARCH_STOP
            ifge sprite.htg_t 2 temp2
            {
                spritepal PAL_WENTEKO
                action AC_WENTEKO_STAND
            }
            else
            {
                ifl sprite.htg_t 2 3
                {
                    set temp4 5
                    mul temp4 enemy_shocked
                    geta .ang temp3
                    seta .ang sprite.htang
                    set move_v temp4
                    state move_actor
                    set enemy_xv move_xv
                    set enemy_yv move_yv
                    state enemy_do_move
                    seta .ang temp3
                }
                ifand sprite.htg_t 2 1
                {
                    spritepal 0
                    seta .shade -127
                    set enemy_skipshade 1
                }
                else
                    spritepal PAL_WENTEKO
            }
            set temp 1
            break
        default
            spritepal PAL_WENTEKO
            break
    endswitch
    ife temp 1
        break
    ifaction AC_WENTEKO_STAND
    {
        state e_fp
        ifactioncount 7
            ifrnd 32
                action AC_WENTEKO_WALK
        ifg enemy_stop 0
        {
            set move_v enemy_stop
            state move_actor
            set enemy_xv move_xv
            set enemy_yv move_yv
            // movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp
            ife enemy_stop 1
                action AC_WENTEKO_WALK
        }
        else
        {
            set enemy_xv 0
            set enemy_yv 0
            // movesprite THISACTOR 0 0 0 CLIPMASK0 temp
        }
        state enemy_do_move
    }
    ifaction AC_WENTEKO_WALK
    {
        ifg enemy_stop 0
        {
            ifpdistl 12288
                soundonce S_WENTEKO_BREATHE_2
            set att_target enemy_target
            set att_noclamp 1
            state angle_to_target
            set temp att_return
            abs temp
            ifl temp 4
            {
                set temp 0
                set att_return 0
            }
            else
                set temp att_return
            shiftr temp 1
            ife temp 0
            {
                ifn att_return 0
                {
                    set temp 1
                    ifl att_return 0
                        inv temp
                }
                else
                    set enemy_stop 0
            }
            geta .ang temp2
            sub temp2 temp
            and temp2 2047
            seta .ang temp2
        }
        else ife enemy_target player.i
            state e_fp
        ife enemy_stop 0
        {
            ifpdistl 12288
                soundonce S_WENTEKO_BREATHE_1
        }
        ifactioncount 6
        {
            ifpdistl 4096 ife cansee_return 1
                action AC_WENTEKO_RUN
            else ife cansee_return 1 ifrnd 32
                action AC_WENTEKO_RUN
        }
        ifactioncount 3 ifpdistl 10240 ife cansee_return 1 ife enemy_target player.i ifrnd 32
                action AC_WENTEKO_CHARGE

        set move_v 20
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        add enemy_stepcounter2 1
        clamp enemy_stepcounter2 0 8
        ifn enemy_stepcounter sprite.htg_t 3
        {
            set enemy_stepcounter sprite.htg_t 3
            ifpdistl 8192 ifg enemy_stepcounter2 4
            {
                set enemy_stepcounter2 0
                ifand enemy_stepcounter 1
                {
                    setp .sound_pitch -640
                    sound S_STEP_METAL_WALK1
                    setp .sound_pitch 0
                }
                else
                {
                    setp .sound_pitch -320
                    gets .floorpicnum surface_type
                    state player_footstep
                    setp .sound_pitch 0
                }
            }
        }
        // movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp
    }
    ifaction AC_WENTEKO_RUN
    {
        ifpdistl 8192
            soundonce S_WENTEKO_BREATHE_1
        ife enemy_target player.i
            state e_fp
        set move_v 180
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        // movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp
        ifactioncount 6
        {
            ife cansee_return 1 ife enemy_target player.i 
            {
                ifpdistl 10240
                {
                    ifrnd 24
                    {
                        action AC_WENTEKO_CHARGE
                        sound S_WENTEKO_BREATHE_2
                    }
                }
                else ifrnd 3
                    action AC_WENTEKO_WALK
            }
            else ifrnd 3
                action AC_WENTEKO_WALK
        }
        add enemy_stepcounter2 1
        clamp enemy_stepcounter2 0 8
        ifn enemy_stepcounter sprite.htg_t 3
        {
            set enemy_stepcounter sprite.htg_t 3
            ifpdistl 8192 ifg enemy_stepcounter2 4
            {
                set enemy_stepcounter2 0
                ifand enemy_stepcounter 1
                {
                    setp .sound_pitch -640
                    sound S_STEP_METAL_WALK1
                    setp .sound_pitch 0
                }
                else
                {
                    setp .sound_pitch -320
                    gets .floorpicnum surface_type
                    state player_footstep
                    setp .sound_pitch 0
                }
            }
        }
    }
    
    ifaction AC_WENTEKO_CHARGE
    {
        add enemy_stepcounter2 1
        clamp enemy_stepcounter2 0 8
        ifn enemy_stepcounter sprite.htg_t 3
        {
            set enemy_stepcounter sprite.htg_t 3
            ifpdistl 8192 ifg enemy_stepcounter2 2
            {
                set enemy_stepcounter2 0
                ifand enemy_stepcounter 1
                {
                    setp .sound_pitch -640
                    sound S_STEP_METAL_WALK1
                    setp .sound_pitch 0
                }
                else
                {
                    setp .sound_pitch -320
                    gets .floorpicnum surface_type
                    state player_footstep
                    setp .sound_pitch 0
                }
            }
        }
        ife enemy_target player.i
            state e_fp
        set move_v 200
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        // movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp
        ifactioncount 6
            action AC_WENTEKO_LEAP_START
    }
    else ife enemy_forcejump 1
    {
        switch sprite.htg_t 4
            case AC_WENTEKO_WALK
            case AC_WENTEKO_RUN
                action AC_WENTEKO_LEAP_START
                break
            case AC_WENTEKO_LEAP_START
            case AC_WENTEKO_LEAP
            case AC_WENTEKO_LEAP_SWIPE
                break
            default
                set enemy_forcejump 0
                break
        endswitch
    }    
    ifaction AC_WENTEKO_LEAP_START
    {
        ife enemy_target player.i
            state e_fp
        set move_v 20
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        ifonwater ifp phigher
        {
            ifactioncount 3
            {
                iffloordistl 1
                {
                    getflorzofslope sprite.sectnum sprite.x sprite.y temp
                    seta .z temp
                }
            }
        }
        movesprite THISACTOR 0 0 -2048 CLIPMASK0 temp
        set enemy_start 0
        ifactioncount 3
        {
            action AC_WENTEKO_LEAP
            sound S_WENTEKO_JUMP_1
            stopactorsound THISACTOR S_WENTEKO_BREATHE_2
        }
    }
    ifaction AC_WENTEKO_LEAP
    {
        ife enemy_start 0
        {
            ifpdistl 8192 iffloordistl 1
            {
                setp .sound_pitch -480
                sound S_STEP_METAL_RUN3
                gets .floorpicnum surface_type
                setp .sound_pitch -320
                set p_steptype 2
                state player_footstep
                setp .sound_pitch 0
            }
            ldist enemy_start enemy_target THISACTOR
            shiftr enemy_start 3
            clamp enemy_start 320 640
        }
        geta .htg_t 2 temp
        clamp temp 0 3
        seta .htg_t 3 temp
        set move_v enemy_start
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        ifonwater ifp phigher
        {
            iffloordistl 1
            {
                getflorzofslope sprite.sectnum sprite.x sprite.y temp
                seta .z temp
            }
        }
        movesprite THISACTOR 0 0 -3072 CLIPMASK0 temp
        ldist temp enemy_target THISACTOR
        ifactioncount 10
            action AC_WENTEKO_LEAP_SWIPE
        else ifl temp 1280
            action AC_WENTEKO_LEAP_SWIPE
        ifaction AC_WENTEKO_LEAP_SWIPE
        {
            stopactorsound THISACTOR S_WENTEKO_BREATHE_2
            ifpdistl 8192
            {
                setp .sound_pitch -128
                sound S_WENTEKO_SWIPE_1
                setp .sound_pitch 0
            }
        }
    }
    ifaction AC_WENTEKO_LEAP_SWIPE
    {
        geta .htg_t 2 temp
        clamp temp 0 2
        seta .htg_t 3 temp
        set enemy_start 0
        set move_v sprite.htg_t 2
        sub move_v 7
        inv move_v
        ifg move_v 3
            shiftl move_v 6
        else
            shiftl move_v 4

        state move_actor
        set temp sprite.htg_t 2
        sub temp 7
        ifg temp -3
            shiftr temp 1
        shiftl temp 9
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        ifonwater ifp phigher
        {
            iffloordistl 1
            {
                getflorzofslope sprite.sectnum sprite.x sprite.y temp
                seta .z temp
            }
        }
        movesprite THISACTOR 0 0 temp CLIPMASK0 temp
        
        ife enemy_forcejump 0
            add enemy_shoot 1
        ife enemy_shoot 4
        {
                ifpdistl 8192
                    soundonce S_WENTEKO_BREATHE_1
                set att_target player.i
                state angle_to_target

                ldist temp player.i THISACTOR
                set temp2 temp
                sub temp2 640
                ifl temp2 0
                {
                    inv temp2
                    shiftr temp2 3
                    clamp temp2 1 65536
                    div att_return temp2
                }
                ifle att_return 128 ifl temp 1536  ife enemy_target player.i ife cansee_return 1
                {
                    set temp4 tilesizy[A_WENTEKO]
                    shiftl temp4 2
                    mul temp4 sprite.yrepeat
                    set temp2 sprite.z
                    sub temp2 temp4
                    set temp5 sprite.z
                    add temp5 temp4
                    ifle player.posz temp5 ifge sprite[player.i].z temp2
                    {
                        setp .sound_pitch -512
                        rand temp4 1
                        add temp4 S_MELEE_THUD01
                        sound temp4
                        setp .sound_pitch 0
                        set temp3 0
                        addphealth -20
                        ifrnd 32
                        {
                            addphealth -5
                            set temp3 64
                        }
                        sub temp 1240
                        getp .i temp2
                        geta .x face_x
                        sub face_x sprite[temp2].x

                        geta .y face_y
                        sub face_y sprite[temp2].y

                        getangle face_return face_x face_y
                        add face_return 1024
                        and face_return 2047
                        
                        set move_v temp
                        sub move_v 4096
                        sub move_v temp3
                        abs move_v
                        cos move_xv face_return
                        sin move_yv face_return
                        mul move_xv move_v
                        mul move_yv move_v
                        shiftr move_xv 4
                        shiftr move_yv 4
                        setp .posxv move_xv
                        setp .posyv move_yv
                    }
                }
        }
        ifactioncount 4
        {
            action AC_WENTEKO_LEAP_END
            set enemy_shoot 0
        }
    }
    ifaction AC_WENTEKO_LEAP_END
    {
        set enemy_start 0
        set move_v sprite.htg_t 2
        sub move_v 7
        inv move_v
        shiftl move_v 3

        state move_actor
        set temp sprite.htg_t 2
        sub temp 7
        ifg temp -3
            shiftr temp 1
        shiftl temp 6
        set enemy_xv move_xv
        set enemy_yv move_yv
        state enemy_do_move
        movesprite THISACTOR 0 0 temp CLIPMASK0 temp
        ifactioncount 4
        {
            set att_target enemy_target
            set att_noclamp 1
            state angle_to_target
            set temp att_return
            shiftr temp 3
            ife temp 0 ifn att_return 0
            {
                ifl att_return 0
                    set temp att_return
            }
            geta .ang temp2
            sub temp2 temp
            and temp2 2047
            seta .ang temp2
        }
        ifactioncount 7
        {
            action AC_WENTEKO_WALK
            set enemy_stop 7
        }
        add enemy_stepcounter2 1
        clamp enemy_stepcounter2 0 8
        ifn enemy_stepcounter sprite.htg_t 3
        {
            set enemy_stepcounter sprite.htg_t 3 ifg enemy_stepcounter2 2
            ifpdistl 8192
            {
                ifand enemy_stepcounter 1
                {
                    setp .sound_pitch -640
                    sound S_STEP_METAL_WALK1
                    setp .sound_pitch 0
                }
                else
                {
                    gets .floorpicnum surface_type
                    setp .sound_pitch -320
                    state player_footstep
                    setp .sound_pitch 0
                }
            }
        }
    }
    
    ifpdistl 1280 ife enemy_target player.i ife cansee_return 1
    {
        state e_fp
        rand temp 255
        ifpdistl 1024
            shiftr temp 1
        ifle temp 32
        {
            ifaction AC_WENTEKO_SWIPE
                nullop
            else ifaction AC_WENTEKO_LEAP_SWIPE
                nullop
            else ifaction AC_WENTEKO_LEAP_END
                nullop
            else ifaction AC_WENTEKO_SWIPE_DOUBLE
                nullop
            else
            {
                ifrnd 127
                    action AC_WENTEKO_SWIPE_DOUBLE
                else
                    action AC_WENTEKO_SWIPE
                state e_fp
            }
        }
    }
    ifaction AC_WENTEKO_SWIPE
    {
        ife enemy_shoot 4 ifpdistl 8192
        {
            rand temp 2
            add temp S_WENTEKO_SWIPE_1
            sound temp
        }
        add enemy_shoot 1
        ife enemy_shoot 7 ife enemy_target player.i ife cansee_return 1
        {
            set att_target player.i
            state angle_to_target
            ifle att_return 128 ifpdistl 1536
            {
                setp .sound_pitch -512
                rand temp4 1
                add temp4 S_MELEE_THUD01
                sound temp4
                setp .sound_pitch 0
                set temp3 0
                addphealth -15
                ifrnd 32
                {
                    addphealth -3
                    set temp3 64
                }
                ldist temp player.i THISACTOR
                ifl temp 1280
                {
                    set temp4 tilesizy[A_WENTEKO]
                    shiftl temp4 2
                    mul temp4 sprite.yrepeat
                    set temp2 sprite.z
                    sub temp2 temp4
                    ifle player.posz sprite.z ifge sprite[player.i].z temp2
                    {
                        sub temp 1240
                        getp .i temp2
                        geta .x face_x
                        sub face_x sprite[temp2].x

                        geta .y face_y
                        sub face_y sprite[temp2].y

                        getangle face_return face_x face_y
                        add face_return 1024
                        and face_return 2047
                        
                        set move_v temp
                        sub move_v 128
                        sub move_v temp3
                        abs move_v
                        cos move_xv face_return
                        sin move_yv face_return
                        mul move_xv move_v
                        mul move_yv move_v
                        shiftr move_xv 4
                        shiftr move_yv 4
                        setp .posxv move_xv
                        setp .posyv move_yv
                    }
                }
            }
        }
        ifactioncount 5
        {
            action AC_WENTEKO_STAND
            set enemy_stop 3
            set enemy_shoot 0
        }
        set enemy_xv 0
        set enemy_yv 0
        state enemy_do_move
        // movesprite THISACTOR 0 0 0 CLIPMASK0 temp
    }
    else ifaction AC_WENTEKO_SWIPE_DOUBLE
    {
        ife enemy_shoot 4
        {
            rand temp 2
            add temp S_WENTEKO_SWIPE_1
            sound temp
        }
        else ife enemy_shoot 11
        {
            rand temp 2
            add temp S_WENTEKO_SWIPE_1
            sound temp
        }
        add enemy_shoot 1
        switch enemy_shoot
            case 7
            case 14
                set att_target player.i
                state angle_to_target
                ifle att_return 128 ifpdistl 1536 ife enemy_target player.i ife cansee_return 1
                {
                    set temp3 0
                    addphealth -15
                    rand temp4 1
                    ifrnd 32
                    {
                        addphealth -3
                        set temp3 64
                        set temp4 2
                    }
                    add temp4 S_MELEE_THUD01
                    setp .sound_pitch -512
                    sound temp4
                    setp .sound_pitch 0
                    ldist temp player.i THISACTOR
                    ifl temp 1280
                    {
                        set temp4 tilesizy[A_WENTEKO]
                        shiftl temp4 2
                        mul temp4 sprite.yrepeat
                        set temp2 sprite.z
                        sub temp2 temp4
                        ifle player.posz sprite.z ifge sprite[player.i].z temp2
                        {
                            sub temp 1240
                            getp .i temp2
                            geta .x face_x
                            sub face_x sprite[temp2].x

                            geta .y face_y
                            sub face_y sprite[temp2].y

                            getangle face_return face_x face_y
                            add face_return 1024
                            and face_return 2047
                            
                            set move_v temp
                            sub move_v 192
                            sub move_v temp3
                            abs move_v
                            cos move_xv face_return
                            sin move_yv face_return
                            mul move_xv move_v
                            mul move_yv move_v
                            shiftr move_xv 4
                            shiftr move_yv 4
                            setp .posxv move_xv
                            setp .posyv move_yv
                        }
                    }
                }
                break
        endswitch
        ifactioncount 7
        {
            action AC_WENTEKO_STAND
            set enemy_stop 3
            set enemy_shoot 0
        }
        set enemy_xv 0
        set enemy_yv 0
        state enemy_do_move
        // movesprite THISACTOR 0 0 0 CLIPMASK0 temp
    }

    getceilzofslope sprite.sectnum sprite.x sprite.y temp
    set temp4 tilesizy[A_WENTEKO]
    shiftl temp4 2
    mul temp4 sprite.yrepeat
    set temp2 sprite.z
    sub temp2 temp4
    ifg temp temp2
    {
        add temp temp4
        seta .z temp
        getflorzofslope sprite.sectnum sprite.x sprite.y temp2
        ifl temp2 temp
            seta .z temp2
    }
    ldist temp player.i THISACTOR
    ifl temp 640 ife enemy_target player.i ife cansee_return 1
    {
        set temp4 tilesizy[A_WENTEKO]
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        set temp2 sprite.z
        sub temp2 temp4
        set temp5 sprite.z
        switch sprite.htg_t 4
            case AC_WENTEKO_LEAP
            case AC_WENTEKO_LEAP_SWIPE
                add temp5 temp4
                break
        endswitch
        ifle player.posz temp5 ifge sprite[player.i].z temp2
        {
            sub temp 600
            getp .i temp2
            geta .x face_x
            sub face_x sprite[temp2].x

            geta .y face_y
            sub face_y sprite[temp2].y

            getangle face_return face_x face_y
            add face_return 1024
            and face_return 2047
            
            set move_v temp
            sub move_v 128
            switch sprite.htg_t 4
                case AC_WENTEKO_LEAP
                case AC_WENTEKO_LEAP_SWIPE
                    sub move_v 1280
                    break
            endswitch
            abs move_v
            cos move_xv face_return
            sin move_yv face_return
            mul move_xv move_v
            mul move_yv move_v
            shiftr move_xv 4
            shiftr move_yv 4
            setp .posxv move_xv
            setp .posyv move_yv
        }
    }
enda


state meat_drop_aim
    ldist temp THISACTOR player.i
    set temp2 sprite[player.i].z
    sub temp2 sprite.z
    ifg temp2 -8192
        add temp2 8192 // aim at the player feet
    set temp3 temp2
    scalevar enemy_horiz temp2 projectile[P_GRENADE].vel temp

    // compensate for the drop
    sub temp 256 // player clipdist
    set temp2 temp
    shiftl temp2 1
    add temp2 projectile[P_GIB_MEAT].vel
    set temp3 temp2
    scalevar temp2 temp2 temp2 projectile[P_GIB_MEAT].vel
    sub temp2 temp3
    scalevar temp2 temp2 projectile[P_GIB_MEAT].drop temp
    shiftr temp2 2
    add enemy_horiz temp2
    ifl enemy_horiz -2048
        set enemy_shoot 2
    geta .z temp
    sub temp sprite[player.i].z
    abs temp
    ifg temp 12288
        clamp enemy_horiz -4096 8192 // prevent overflow
    else
        clamp enemy_horiz -2048 8192 // prevent overflow
ends


spriteshadow A_NUKEMUTANT
spriteshadow A_NUKEMUTANT_RISE
spriteshadow A_NUKEMUTANT_DEAD
spriteshadow A_NUKEMUTANT_GIBBED
spriteshadow A_NUKEMUTANT_GDF
spriteshadow A_NUKEMUTANT_GDF_RISE
spriteshadow A_NUKEMUTANT_GDF_DEAD
spriteshadow A_NUKEMUTANT_GDF_GIBBED

var mutant_help 0 2

defstate mutant_helps
    ife mutant_help 0
    {
        ife cansee_return 1
        {
            ifrnd 13
            {
                ifactor A_NUKEMUTANT
                    sound S_ZOMBIE_HELP
                else ifactor A_NUKEMUTANT_GDF
                    sound S_ZOMBIE_GDF_HELP
            }
            set mutant_help 1
        }
    }
    else ifg mutant_help 0
    {
        add mutant_help 1
        ifrnd 3
        {
            set mutant_help -1
            ifactor A_NUKEMUTANT
                sound S_ZOMBIE_HELP
            else ifactor A_NUKEMUTANT_GDF
                sound S_ZOMBIE_GDF_HELP
        }
        else ifg mutant_help 60
            set mutant_help -1
    }
ends

defstate nukemutant_smg_adjust
    geta .htextra temp4
    ife sprite.htpicnum P_SMG2 ife sprite.htowner player.i ifg temp4 0
    {
        ifg p_pup_damage_time 0
                clamp temp4 0 24
            else
                clamp temp4 0 12
        seta .htextra temp4
    }
ends

defstate nukemutant_damage_scale
    ifg enemy_minigun_dmg 0
    {
        set temp2 enemy_minigun_dmg
        shiftr temp2 2
        sub enemy_minigun_dmg temp2
        clamp enemy_minigun_dmg 0 65536
    }
    geta .htextra temp2
    ifg temp2 0
    {
        add enemy_minigun_dmg temp2
        ifwasweapon P_SMG2
        {
            set temp3 temp2
            shiftr temp3 1
            add enemy_minigun_dmg temp3
        }
        else ife sprite.htpicnum BULLET ife sprite.htowner player.i
        {
            ife player.curr_weapon WEAPON_SHOTGUN
            {
                set temp3 temp2
                shiftr temp3 1
                sub enemy_minigun_dmg temp3
                shiftr temp3 2
                sub enemy_minigun_dmg temp3
                ifactor A_NUKEMUTANT
                {
                    set temp3 temp2
                    shiftr temp3 3
                    sub enemy_minigun_dmg temp3
                    shiftr temp3 3
                    sub enemy_minigun_dmg temp3
                }
                else
                {
                    shiftr temp3 1
                    sub enemy_minigun_dmg temp3
                }
            }
            else ife player.curr_weapon WEAPON_LOVERBOY
            {
                ifn weapon1_alt 0
                {
                     add enemy_minigun_dmg 2
                     add temp2 2
                     ifactor A_NUKEMUTANT_GDF
                     {
                        set temp3 temp2
                        shiftr temp3 3
                        add temp2 temp3
                     }
                     seta .htextra temp2
                }
            }
            else ifactor A_NUKEMUTANT // because it dies too fast to gib otherwise
            {
                ife player.curr_weapon WEAPON_MINIGUN
                {
                    set temp3 temp2
                    shiftr temp3 1
                    add enemy_minigun_dmg temp3
                }
            }
        }
    }
ends

eventloadactor A_NUKEMUTANT
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda
eventloadactor A_NUKEMUTANT_RISE
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda
eventloadactor A_NUKEMUTANT_GDF
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda
eventloadactor A_NUKEMUTANT_GDF_RISE
    state enemy_load_init
    ifn se_hitag 0
        sleeptime 300 // make sure to wake up enemy so they can patrol even if the player is far away
enda

defstate zombie_spawn_shared
    ife sector.lotag 1
        set enemy_thisisahack 1
    sizeat 22 20
    state clear_enemy_vels
    state enemy_spawn_checkhitag
ends

appendevent EVENT_SPAWN
    switch sprite.picnum
        case A_NUKEMUTANT_RISE
        case A_NUKEMUTANT_GDF_RISE
            cstat 32768
            state zombie_spawn_shared
            break
            
        case A_NUKEMUTANT
        case A_NUKEMUTANT_GDF
            cstat 1
        case A_NUKEMUTANT_DEAD
        case A_NUKEMUTANT_DEADHEAD
        case A_NUKEMUTANT_GDF_DEAD
        case A_NUKEMUTANT_GDF_GIBBED
            cstator 256
            state zombie_spawn_shared
            break
    endswitch
    
    switch sprite.picnum
        case A_NUKEMUTANT
        case A_NUKEMUTANT_RISE
        case A_NUKEMUTANT_DEAD
        case A_NUKEMUTANT_DEADHEAD
            seta .pal 152
            break

        case A_NUKEMUTANT_GDF
        case A_NUKEMUTANT_GDF_RISE
        case A_NUKEMUTANT_GDF_DEAD
        case A_NUKEMUTANT_GDF_GIBBED
            seta .pal 35
            break
    endswitch    
endevent

action AC_MUTANT_IDLE   0 1 5 1 1
action AC_MUTANT_WALK   0 4 5 1 16
action AC_MUTANT_SWIPE  25 5 5 1 8
action AC_MUTANT_THROW  55 5 5 1 8
action AC_MUTANT_HIT    102 1 1 1 1
action AC_MUTANT_SHOCKED -15 2 5 1 1
action AC_MUTANT_DYING  102 6 1 1 8
action AC_MUTANT_GIBBED  109 9 1 1 8
action AC_MUTANT_HEADACHE 92 7 1 1 8
action AC_MUTANT_DEADHEAD -9 1 1 1 1
useractor notenemy A_NUKEMUTANT_DEAD CORPSE_HEALTH
    ife enemy_headache 1
        action AC_MUTANT_DEADHEAD
    state enemy_body_code
enda

useractor notenemy A_NUKEMUTANT_GIBBED 0 AC_BASE
    ifand sprite.cstat 4
        cstat 4
    else
        cstat 0
    fall
    set actor_gib 2
    changespritestat THISACTOR STAT_STATIC_GIB
enda



useractor notenemy A_NUKEMUTANT_DEADHEAD CORPSE_HEALTH
    set enemy_headache 1
    action AC_MUTANT_DEADHEAD
    state enemy_die_cleartags
    cactor A_NUKEMUTANT_DEAD
enda

defstate nukemutant_cansee
    set cansee_target player.i
    set cansee_height 8192
    getceilzofslope sprite.sectnum sprite.x sprite.y temp
    geta .z temp2
    sub temp2 cansee_height
    ifl temp2 temp
        set cansee_height 4096
    state cansee_actor
ends

action AC_MUTANT_RISE  0 7 1 1 16
useractor enemy A_NUKEMUTANT_RISE 50 AC_MUTANT_RISE
    fall
    clipdist 32
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
        geta .shade temp
        sub temp 4
        seta .shade temp
    }
    else
        set enemy_skipshade 0
    ife enemy_thisisahack 1
    {
        ifn sector.lotag 1
            set enemy_thisisahack 0
        seta .htbposz sprite.z
    }
    state nukemutant_cansee
    state enemy_check_init
    ife enemy_init_return 1
    {
        ifl counter 3
        {
            seta .htg_t 2 0
            seta .htg_t 3 0
            action AC_MUTANT_RISE
            break
        }
    }
    ifl counter 3
    {
        add counter 1
        seta .htg_t 2 0
        seta .htg_t 3 0
        action AC_MUTANT_RISE
    }
    else
    {
        set face_target player.i
        state face_actor
        seta .ang face_return
        cstat 257
        clipdist 32
        ifg sprite .htextra 0
            ifactioncount 4
            {
                action AC_MUTANT_IDLE
                cactor A_NUKEMUTANT
            }
        ifactioncount 7
        {
            action AC_MUTANT_IDLE
            cactor A_NUKEMUTANT
        }
    }
enda

useractor enemy A_NUKEMUTANT 60 AC_MUTANT_IDLE
    clipdist 32
    cstat 257
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
        geta .shade temp
        sub temp 4
        seta .shade temp
    }
    else
        set enemy_skipshade 0

    state nukemutant_cansee
    
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break

    state e_wakemeup
    ife skip_see 1
    {
        set cansee_return 0
        set enemy_cantsee 5
    }
    ife cansee_return 1 ife skip_see 0
    {
        ifand se_lotag 1
        {
            set cansee_return 0
            set enemy_cantsee 5
        }
        else
            set se_hitag 0
    }
    ife cansee_return 1
    {
        set enemy_cantsee 0
        set enemy_target player.i
        set way_current -1
    }
    state mutant_helps
    
    state enemy_do_target_icon
    ife cansee_return_o 1
        state enemy_checkw1alt
    fall
    ife enemy_thisisahack 1
    {
        ifn sector.lotag 1
            set enemy_thisisahack 0
        seta .htbposz sprite.z
    }
    state enemy_check_init
    ife enemy_init_return 1
        break
    ife need_spot_sound 0
    {
        ifrnd 16
        {
            rand temp4 1
            add temp4 S_ZOMBIE_RECOG1
            ifrnd 64
                soundvar temp4
            set need_spot_sound 1
        }
        else ifrnd 96
        {
             rand temp4 1
             add temp4 S_ZOMBIE_RECOG1_Q
             soundvar temp4
             set need_spot_sound 1
        }
    }
    else
    {
        ifg need_spot_sound 1
            sub need_spot_sound 1
        ifg sprite.extra 0
        {
            ifle sprite.htextra 0
            {
                ifrnd 64 ifpdistl ENEMY_SOUND_DIST ife need_spot_sound 1
                {
                    rand temp4 2
                    add temp4 S_ZOMBIE_ROAM1
                    soundvar temp4
                    set need_spot_sound 90
                }
            }
        }
    }
    state smg_flamechance
    ifaction AC_MUTANT_DYING
    {
        stopactorsound THISACTOR S_AMB_NEONFLICKR01
        stopactorsound THISACTOR S_AMB_NEONFLICKR02
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        cstat 0
        set enemy_xv 0
        set enemy_yv 0
        state enemy_do_move
        state dying_blood
        ife enemy_gibbed 1
            cstat 32768
        ifactioncount 6
        {
            state enemy_die_resolve
            ife enemy_gibbed 1
            {
                cstat 0
                action AC_BASE
                state enemy_die_cleartags
                cactor A_NUKEMUTANT_GIBBED
            }
            else
            {
                strength CORPSE_HEALTH
                action AC_ENEMY_BODY
                cstat 256
                state enemy_die_cleartags
                cactor A_NUKEMUTANT_DEAD
            }
        }
        break
    }
    ifaction AC_MUTANT_GIBBED
    {
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        cstat 0
        set enemy_xv 0
        set enemy_yv 0
        state enemy_do_move
        state dying_blood
        ifactioncount 9
        {
            state enemy_die_resolve
            cstat 0
            action AC_BASE
            state enemy_die_cleartags
            cactor A_NUKEMUTANT_GIBBED
        }
        break
    }
    ifaction AC_MUTANT_HEADACHE
    {
        stopactorsound THISACTOR S_AMB_NEONFLICKR01
        stopactorsound THISACTOR S_AMB_NEONFLICKR02
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        cstat 0
        set enemy_xv 0
        set enemy_yv 0
        state enemy_do_move
        state dying_blood
        ifactioncount 7
        {
            state enemy_die_resolve
            strength CORPSE_HEALTH
            action AC_MUTANT_DEADHEAD
            cstat 256
            state enemy_die_cleartags
            cactor A_NUKEMUTANT_DEAD
        }
        break
    }
    state pup_damage_adjust
    state nukemutant_smg_adjust
    
    state nukemutant_damage_scale
    ifhitweapon
    {
        ifwasweapon P_SHOCKER
        {
            add enemy_shocked 1
            ifg enemy_shocked 3
                set enemy_shocked 1
            set temp4 temp2
            mul temp4 enemy_shocked

            geta .extra temp3
            sub temp3 temp4
            seta .extra temp3
        }
        geta .ang temp
        seta .ang sprite.htang
        set move_v temp2
        shiftl move_v 3
        state move_actor
        seta .ang temp
        add enemy_shotgun_xv move_xv
        add enemy_shotgun_yv move_yv
        clamp enemy_shotgun_xv -256 256
        clamp enemy_shotgun_yv -256 256
        ifn enemy_shocked 0
            action AC_MUTANT_SHOCKED
        else
            action AC_MUTANT_HIT

        ifdead
        {
            stopsound S_ZOMBIE_RECOG1
            stopsound S_ZOMBIE_RECOG2
            stopsound S_ZOMBIE_RECOG1_Q
            stopsound S_ZOMBIE_RECOG2_Q
            state enemy_clearw1alt
            cstat 0
            shiftl enemy_shotgun_xv 1
            shiftl enemy_shotgun_yv 1
            state dying_blood
            action AC_MUTANT_DYING
            ifge enemy_minigun_dmg 50
            {
                set temp4 0
                ife enemy_headsound 1
                    rand temp4 3
                
                ife temp4 0
                {
                    set enemy_gibbed 1
                    state skull_gibs
                    ifrnd 96
                        or p_wantline TALK_GIB
                    action AC_MUTANT_GIBBED
                    rand temp4 3
                    add temp4 2
                    for itervar range temp4
                        state spawn_shard
                }
                else
                {
                    ifrnd 48
                        state skull_gibs
                    soundonce S_IMPACT_HEADSHOT
                    or p_wantline TALK_KILL
                    state crackhead
                    set enemy_headache 1
                    ifrnd 96
                        state skull_gibs
                    action AC_MUTANT_HEADACHE
                }
            }
            else
            {
                rand temp4 1
                add temp4 S_ZOMBIE_DEAD1
                soundvar temp4
                set need_spot_sound 90
            }
            break
        }
        else
        {
            ifg enemy_smg_flame 4
            {
                rand temp4 1
                add temp4 S_ZOMBIE_RECOG1
            }
            else
            {
                rand temp4 2
                add temp4 S_ZOMBIE_HIT1
            }
                
            soundvar temp4
            set need_spot_sound 90
        }
        set enemy_headsound 0
    }
    ifaction AC_MUTANT_HIT
    {
        ifactioncount 2
            action AC_MUTANT_IDLE
        break
    }
    else ifaction AC_MUTANT_SHOCKED
    {
        ifand sprite.htg_t 2 1
        {
            seta .shade -127
            set enemy_skipshade 1
        }
        ife ms_flashpal 0
            ifn sprite.pal 0
                geta .pal ms_flashpal
        ifn ms_flashpal 0
        {
            ifand sprite.htg_t 2 1
                spritepal 0
            else
                seta .pal ms_flashpal
        }
        soundonce S_AMB_NEONFLICKR01
        soundonce S_AMB_NEONFLICKR02
        ifn enemy_shocked 0
        {
            switch enemy_shocked
            {
                case 1
                    ifactioncount 10
                    {
                        action AC_MUTANT_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
                case 2
                    ifactioncount 20
                    {
                        action AC_MUTANT_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
                case 3
                    ifactioncount 30
                    {
                        action AC_MUTANT_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
            }
            endswitch
            set enemy_shocked 0
        }
        else
        {
            ifactioncount 7
                action AC_MUTANT_IDLE
        }

        break
    }
    else
    {
        ifn ms_flashpal 0
            ife sprite.pal 0
                seta .pal ms_flashpal
    }
    ifrnd 64
        ifaction AC_MUTANT_IDLE
            action AC_MUTANT_WALK
    
    ifrnd 8
        nullop
    else
        state e_fps
    set temp5 0
    getp .i temp6
    ldist temp THISACTOR temp6
    ifl temp 448
    {
        set temp4 tilesizy[sprite.picnum]
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        set temp2 sprite.z
        sub temp2 temp4
        sub temp2 1024
        ifge sprite[temp6].z temp2
        {
            set temp sprite.z
            add temp 256
            ifle sprite[temp6].z temp
            {
                set temp5 1
            }
        }
    }
    set temp userdef.player_skill
    clamp temp 1 4
    shiftl temp 11
    clamp temp 5120 8192
    ife temp5 1 ife cansee_return 1
    {
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        ifaction AC_MUTANT_WALK
            action AC_MUTANT_IDLE
        ifaction AC_MUTANT_IDLE
        {
            set face_target enemy_target
            set face_target enemy_target
            state face_actor
            seta .ang face_return
        }
        ifrnd 64
            ifaction AC_MUTANT_IDLE
            {
                action AC_MUTANT_SWIPE
                rand temp4 2
                add temp4 S_ZOMBIE_SWING1
                soundvar temp4
                rand temp4 1
                add temp4 S_MELEE_SWING02
                soundvar temp4
            }
    }
    else ifl userdef.vm_distance temp
    {
        ifpdistl 2048
            nullop
        else
            ifrnd 6 ife cansee_return 1
            {
                ifaction AC_MUTANT_WALK
                {
                    action AC_MUTANT_THROW
                    rand temp4 2
                    add temp4 S_ZOMBIE_THROW1
                    soundvar temp4
                    sound S_MUTANT_FLESHRIP
                }
            }
    }
    
    ifaction AC_MUTANT_THROW
    {
        set need_spot_sound 90
        ifl sprite.htg_t 2 2
        {
            set face_target enemy_target
            set face_target enemy_target
            state face_actor
            seta .ang face_return
        }
        ife enemy_shoot 0
        {
            ife sprite.htg_t 3 3
            {
                set enemy_shoot 1
                sound S_BBOMB_THROW_ALT
                state meat_drop_aim
                geta .ang temp4
                geta .x temp5
                geta .y temp6
                geta .z temp7
                geta .sectnum temp8
                geta .ang temp
                sub temp 512
                and temp 2047
                seta .ang temp
                set move_v 256
                state move_actor
                movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp
                seta .ang temp4
                ezshoot enemy_horiz P_GIB_MEAT
                rand temp 5
                add temp 5
                seta[RETURN].extra temp
                seta[RETURN].shade 0
                setthisprojectile[RETURN].bsound S_GIBDROP01
                setthisprojectile[RETURN].isound S_GIBDROP02
                seta[RETURN].blend 255
                seta[RETURN].shade -12
                seta[RETURN].pal 63
                ife enemy_shoot 2
                {
                    geta[RETURN].xvel temp
                    add temp 16
                    seta[RETURN].xvel temp
                }
                
                seta .x temp5
                seta .y temp6
                seta .z temp7
                seta .sectnum temp8
            }
        }
        ifactioncount 5
        {
            action AC_MUTANT_IDLE
            set enemy_shoot 0
        }
    }
    ifaction AC_MUTANT_SWIPE
    {
        set need_spot_sound 90
        set temp5 0
        getp .i temp6
        ldist temp THISACTOR temp6
        ifl temp 448
        {
            set temp4 tilesizy[sprite.picnum]
            shiftl temp4 2
            mul temp4 sprite.yrepeat
            set temp2 sprite.z
            sub temp2 temp4
            sub temp2 1024
            ifge sprite[temp6].z temp2
            {
                set temp sprite.z
                add temp 32
                ifle sprite[temp6].z temp
                    set temp5 1
            }
        }
        ife temp5 1
        {
            ife enemy_shoot 0
            {
                ife cansee_return 1
                {
                    ife sprite.htg_t 3 3
                    {
                        set att_target player.i
                        state angle_to_target
                        ifl att_return 72
                        {
                            ifrnd 8
                                addphealth -12
                            else
                                addphealth -10
                            rand temp4 1
                            add temp4 S_MELEE_THUD01
                            soundvar temp4
                            set enemy_shoot 1
                            
                            ldist temp player.i THISACTOR
                            ifl temp 1280
                            {
                                set temp4 tilesizy[A_NUKEMUTANT]
                                shiftl temp4 2
                                mul temp4 sprite.yrepeat
                                set temp2 sprite.z
                                sub temp2 temp4
                                ifle player.posz sprite.z ifge sprite[player.i].z temp2
                                {
                                    sub temp 1240
                                    getp .i temp2
                                    geta .x face_x
                                    sub face_x sprite[temp2].x

                                    geta .y face_y
                                    sub face_y sprite[temp2].y

                                    getangle face_return face_x face_y
                                    add face_return 1024
                                    and face_return 2047
                                    
                                    set move_v temp
                                    sub move_v 128
                                    sub move_v temp3
                                    abs move_v
                                    clamp move_v 0 512
                                    cos move_xv face_return
                                    sin move_yv face_return
                                    mul move_xv move_v
                                    mul move_yv move_v
                                    shiftr move_xv 4
                                    shiftr move_yv 4
                                    setp .posxv move_xv
                                    setp .posyv move_yv
                                }
                            }
                        }
                    }
                }
            }
        }
        ifactioncount 5
        {
            set enemy_shoot 0
            action AC_MUTANT_IDLE
        }
    }
    ifaction AC_MUTANT_WALK
    {
        geta .htg_t 2 temp
        set temp2 temp
        mod temp2 4
        clamp temp 0 7
        shiftl temp 2
        ifl temp2 2
            shiftr temp 1
        ldist temp3 THISACTOR enemy_target
        ifl temp3 1536
            add temp 12
        add temp 10
        set move_v temp
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ife enemy_target player.i
            ife cansee_return 1
                ifpdistl 512
                {
                    set enemy_xv 0
                    set enemy_yv 0
                    ifrnd 32
                        action AC_MUTANT_SWIPE
                }
        add enemy_stepcounter 1
        ifg enemy_stepcounter 11
        {
            ife enemy_stepcounter 12
                gets .floorpicnum surface_type
            else ife enemy_stepcounter 24
                set surface_type T_SLIME
            iffloordistl 1 ifpdistl 8192 
            {
                ife enemy_stepcounter 12
                {
                    geta .xvel p_xvel
                    ifg p_xvel 96
                        set p_steptype 1
                    setp .sound_pitch 480
                    
                    state player_footstep
                    setp .sound_pitch 0
                }
                else ife enemy_stepcounter 24
                {
                    geta .xvel p_xvel
                    ifg p_xvel 96
                        set p_steptype 1
                    setp .sound_pitch 480
                    
                    state player_footstep
                    setp .sound_pitch 0
                }
            }
            ife enemy_stepcounter 24
                set enemy_stepcounter 0
        }
    }
    else
    {
        set enemy_stepcounter 0
        set enemy_xv 0
        set enemy_yv 0
    }
    state enemy_do_move
enda


action AC_MUTANT_GDF_IDLE       0 1 5 1 1
action AC_MUTANT_GDF_WALK       0 5 5 1 16
action AC_MUTANT_GDF_VOMIT      30 6 5 1 8
action AC_MUTANT_GDF_HIT        81 1 1 1 1
action AC_MUTANT_GDF_SHOCKED    90 2 5 1 1
action AC_MUTANT_GDF_DYING      81 7 1 1 8
action AC_MUTANT_GDF_GIBBED     102 9 1 1 8
action AC_MUTANT_GDF_HEADACHE   111 7 1 1 8
action AC_MUTANT_GDF_DEADHEAD   30 1 1 1 1

useractor notenemy A_NUKEMUTANT_GDF_GIBBED 0 AC_BASE
    ifand sprite.cstat 4
        cstat 4
    else
        cstat 0
    fall
    set actor_gib 2
    changespritestat THISACTOR STAT_STATIC_GIB
enda

useractor notenemy A_NUKEMUTANT_GDF_DEAD CORPSE_HEALTH
    ife enemy_headache 1
        action AC_MUTANT_GDF_DEADHEAD
    state enemy_body_code
enda

useractor notenemy A_NUKEMUTANT_GDF_DEADHEAD CORPSE_HEALTH
    set enemy_headache 1
    action AC_MUTANT_GDF_DEADHEAD
    state enemy_die_cleartags
    cactor A_NUKEMUTANT_GDF_DEAD
enda

useractor enemy A_NUKEMUTANT_GDF_RISE 100 AC_MUTANT_RISE
    fall
    clipdist 48
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
        geta .shade temp
        sub temp 4
        seta .shade temp
    }
    else
        set enemy_skipshade 0
    ife enemy_thisisahack 1
    {
        ifn sector.lotag 1
            set enemy_thisisahack 0
        seta .htbposz sprite.z
    }
    state nukemutant_cansee
    state enemy_check_init
    ife enemy_init_return 1
    {
        ifl counter 3
        {
            seta .htg_t 2 0
            seta .htg_t 3 0
            action AC_MUTANT_RISE
            break
        }
    }
    ifl counter 3
    {
        add counter 1
        seta .htg_t 2 0
        seta .htg_t 3 0
        action AC_MUTANT_RISE
    }
    else
    {
        cstat 257
        clipdist 48
        set face_target player.i
        state face_actor
        seta .ang face_return
        ifg sprite .htextra 0
            ifactioncount 4
            {
                action AC_MUTANT_GDF_IDLE
                cactor A_NUKEMUTANT_GDF
            }
        ifactioncount 7
        {
            action AC_MUTANT_GDF_IDLE
            cactor A_NUKEMUTANT_GDF
        }
    }
enda

useractor enemy A_NUKEMUTANT_GDF 100 AC_MUTANT_GDF_IDLE
    clipdist 48
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
        geta .shade temp
        sub temp 4
        seta .shade temp
    }
    else
        set enemy_skipshade 0

    set cansee_target player.i
    set cansee_height 8192
    getceilzofslope sprite.sectnum sprite.x sprite.y temp
    geta .z temp2
    sub temp2 cansee_height
    ifl temp2 temp
        set cansee_height 4096
    state cansee_actor
    
    state enemy_lotag_checkclear
    state enemy_check_pause
    ife eps_return 1
        break

    state e_wakemeup
    ife skip_see 1
    {
        set cansee_return 0
        set enemy_cantsee 5
    }
    ife cansee_return 1 ife skip_see 0
    {
        ifand se_lotag 1
        {
            set cansee_return 0
            set enemy_cantsee 5
        }
        else
            set se_hitag 0
    }
    ife cansee_return 1
    {
        set enemy_cantsee 0
        set enemy_target player.i
        set way_current -1
    }
    state mutant_helps
    state enemy_do_target_icon
    ife cansee_return_o 1
        state enemy_checkw1alt
    fall
    ife enemy_thisisahack 1
    {
        ifn sector.lotag 1
            set enemy_thisisahack 0
        seta .htbposz sprite.z
    }
    state enemy_check_init
    ife enemy_init_return 1
        break
    ife need_spot_sound 0
    {
        ifrnd 16 
        {
            rand temp4 1
            add temp4 S_ZOMBIE_GDF_RECOG1
            ifrnd 64
                soundvar temp4
            set need_spot_sound 1
        }
        else ifrnd 96
        {
             rand temp4 1
             add temp4 S_ZOMBIE_GDF_RECOG1_Q
             soundvar temp4
             set need_spot_sound 1
        }
    }
    else
    {
        ifg need_spot_sound 1
            sub need_spot_sound 1
        ifg sprite.extra 0
        {
            ifle sprite.htextra 0
            {
                ifrnd 64 ifpdistl ENEMY_SOUND_DIST ife need_spot_sound 1
                {
                    rand temp4 2
                    add temp4 S_ZOMBIE_GDF_ROAM1
                    soundvar temp4
                    set need_spot_sound 90
                }
            }
        }
    }
    state smg_flamechance
    ifaction AC_MUTANT_GDF_DYING
    {
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        cstat 0
        set enemy_xv 0
        set enemy_yv 0
        state enemy_do_move
        state dying_blood
        ife enemy_gibbed 1
            cstat 32768
        ifactioncount 7
        {
            state enemy_die_resolve
            ife enemy_gibbed 1
            {
                cstat 0
                action AC_BASE
                state enemy_die_cleartags
                cactor A_NUKEMUTANT_GDF_GIBBED
            }
            else
            {
                strength CORPSE_HEALTH
                action AC_ENEMY_BODY
                cstat 256
                state enemy_die_cleartags
                cactor A_NUKEMUTANT_GDF_DEAD
            }
        }
        break
    }
    ifaction AC_MUTANT_GDF_GIBBED
    {
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        cstat 0
        set enemy_xv 0
        set enemy_yv 0
        state enemy_do_move
        state dying_blood
        ifactioncount 9
        {
            state enemy_die_resolve
            cstat 0
            action AC_BASE
            state enemy_die_cleartags
            cactor A_NUKEMUTANT_GDF_GIBBED
        }
        break
    }
    ifaction AC_MUTANT_GDF_HEADACHE
    {
        stopactorsound THISACTOR S_AMB_NEONFLICKR01
        stopactorsound THISACTOR S_AMB_NEONFLICKR02
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        cstat 0
        set enemy_xv 0
        set enemy_yv 0
        state enemy_do_move
        state dying_blood
        ifactioncount 6
        {
            state enemy_die_resolve
            strength CORPSE_HEALTH
            set enemy_headache 1
            action AC_MUTANT_GDF_DEADHEAD
            cstat 256
            state enemy_die_cleartags
            cactor A_NUKEMUTANT_GDF_DEAD
        }
        break
    }
    state pup_damage_adjust
    state nukemutant_smg_adjust
    
    state nukemutant_damage_scale
    ifhitweapon
    {
        ifwasweapon P_SHOCKER
        {
            add enemy_shocked 1
            ifg enemy_shocked 3
                set enemy_shocked 1
            set temp4 temp2
            mul temp4 enemy_shocked

            geta .extra temp3
            sub temp3 temp4
            seta .extra temp3
        }
        geta .ang temp
        seta .ang sprite.htang
        set move_v temp2
        shiftl move_v 3
        state move_actor
        seta .ang temp
        add enemy_shotgun_xv move_xv
        add enemy_shotgun_yv move_yv
        clamp enemy_shotgun_xv -256 256
        clamp enemy_shotgun_yv -256 256
        ifn enemy_shocked 0
            action AC_MUTANT_GDF_SHOCKED
        else
            action AC_MUTANT_GDF_HIT
        ifdead
        {
            stopsound S_ZOMBIE_GDF_RECOG1
            stopsound S_ZOMBIE_GDF_RECOG2        
            stopsound S_ZOMBIE_GDF_RECOG1_Q
            stopsound S_ZOMBIE_GDF_RECOG2_Q
            state enemy_clearw1alt
            cstat 0
            shiftl enemy_shotgun_xv 1
            shiftl enemy_shotgun_yv 1
            state dying_blood
            action AC_MUTANT_GDF_DYING
            set temp4 0
            ifn enemy_headsound 0
                rand temp4 3
            ife temp4 0 ifge enemy_minigun_dmg 50
            {
                set enemy_gibbed 1
                state skull_gibs
                spawn A_ACIDYSPIT_SPLASH
                espawn A_GENERIC_PARTICLE
                setav[RETURN].particle_force_pal 5
                seta[RETURN].xrepeat 125
                action AC_MUTANT_GDF_GIBBED
                
                rand temp7 1
                add temp7 3
                for itervar range temp7
                {
                    espawn A_SMOKE2
                    geta .z temp
                    rand temp2 512
                    sub temp2 2048
                    add temp temp2
                    seta[RETURN].z temp
                    rand temp 16
                    add temp 36
                    seta[RETURN].xrepeat temp
                    seta[RETURN].yrepeat temp
                    rand temp 2048
                    shiftl temp 1
                    inv temp
                    set temp2 itervar
                    shiftl temp2 1
                    sub temp temp2
                    seta[RETURN].zvel temp
                    seta[RETURN].xvel 0
                    seta[RETURN].cstat 32768
                    setav[RETURN].prop_barrel_type 1
                }
                rand temp4 3
                add temp4 2
                for itervar range temp4
                    state spawn_shard
            }
            else
            {
                ifn enemy_headsound 0
                {
                    soundonce S_IMPACT_HEADSHOT
                    or p_wantline TALK_KILL
                    ifrnd 208
                    {
                        state crackhead
                        set enemy_headache 1
                        ifrnd 96
                            state skull_gibs
                        action AC_MUTANT_GDF_HEADACHE
                    }
                }
                rand temp4 1
                add temp4 S_ZOMBIE_GDF_DEAD1
                soundvar temp4
                set need_spot_sound 90
            }
            break
        }
        else
        {
            ifg enemy_smg_flame 4
            {
                rand temp4 1
                add temp4 S_ZOMBIE_GDF_RECOG1
            }
            else
            {
                rand temp4 3
                add temp4 S_ZOMBIE_GDF_HIT1
            }

            soundvar temp4
            set need_spot_sound 90
        }
        set enemy_headsound 0
    }

    ifaction AC_MUTANT_GDF_HIT
    {
        ifactioncount 2
            action AC_MUTANT_GDF_IDLE
        break
    }
    else ifaction AC_MUTANT_GDF_SHOCKED
    {
        ifand sprite.htg_t 2 1
        {
            seta .shade -127
            set enemy_skipshade 1
        }
        ife ms_flashpal 0
            ifn sprite.pal 0
                geta .pal ms_flashpal
        ifn ms_flashpal 0
        {
            ifand sprite.htg_t 2 1
                spritepal 0
            else
                seta .pal ms_flashpal
        }
        soundonce S_AMB_NEONFLICKR01
        soundonce S_AMB_NEONFLICKR02
        ifn enemy_shocked 0
        {
            switch enemy_shocked
            {
                case 1
                    ifactioncount 10
                    {
                        action AC_MUTANT_GDF_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
                case 2
                    ifactioncount 20
                    {
                        action AC_MUTANT_GDF_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
                case 3
                    ifactioncount 30
                    {
                        action AC_MUTANT_GDF_IDLE
                        stopactorsound THISACTOR S_AMB_NEONFLICKR01
                        stopactorsound THISACTOR S_AMB_NEONFLICKR02
                    }
                    break
            }
            endswitch
            set enemy_shocked 0
        }
        else
        {
            ifactioncount 7
                action AC_MUTANT_GDF_IDLE
        }

        break
    }
    else
    {
        ifn ms_flashpal 0
            ife sprite.pal 0
                seta .pal ms_flashpal
    }
    ifrnd 64
        ifaction AC_MUTANT_GDF_IDLE
            action AC_MUTANT_GDF_WALK
    
    ifrnd 8
        nullop
    else
        state e_fps
    ifpdistl 896 ife cansee_return 1
    {
        ifmove AM_ENEMY_SEARCH
            move AM_ENEMY_SEARCH_STOP
        ifaction AC_MUTANT_GDF_WALK
            action AC_MUTANT_GDF_IDLE
        ifaction AC_MUTANT_GDF_IDLE
        {
            set face_target enemy_target
            set face_target enemy_target
            state face_actor
            seta .ang face_return
            ifrnd 10
            {
                action AC_MUTANT_GDF_VOMIT
                rand temp4 2
                add temp4 S_ZOMBIE_GDF_PUKE1
                soundvar temp4
            }
        }
    }
    else ifpdistl 3328
    {
            ifrnd 6 ife cansee_return 1
            {
                ifaction AC_MUTANT_GDF_WALK
                {
                    action AC_MUTANT_GDF_VOMIT
                    rand temp4 2
                    add temp4 S_ZOMBIE_GDF_PUKE1
                    soundvar temp4
                }
            }
    }
    
    ifaction AC_MUTANT_GDF_VOMIT
    {
        set need_spot_sound 90
        ifl sprite.htg_t 2 2
        {
            set face_target enemy_target
            set face_target enemy_target
            state face_actor
            seta .ang face_return
        }
        ife enemy_shoot 0
        {
            ife sprite.htg_t 3 3
            {
                geta .x temp4
                geta .y temp5
                geta .sectnum temp6
                geta .z temp7
                geta .ang temp3
                cos move_xv temp3
                sin move_yv temp3

                shiftl move_xv 7
                shiftl move_yv 7
                shiftr move_xv 15
                shiftr move_yv 15
                add move_xv sprite.x
                add move_yv sprite.y
                seta .x move_xv
                seta .y move_yv
                
                geta .ang temp3
                sub temp3 512
                and temp3 2047
                cos move_xv temp3
                sin move_yv temp3

                shiftl move_xv 7
                shiftl move_yv 7
                shiftr move_xv 14
                shiftr move_yv 14
                add move_xv sprite.x
                add move_yv sprite.y
                seta .x move_xv
                seta .y move_yv
                set temp2 sprite.sectnum
                
                sub temp7 3072
                seta .z temp7
                updatesector sprite.x sprite.y temp2
                ifn temp2 -1
                    seta .sectnum temp2
                eshoot P_ACIDYSPIT
                setav[RETURN].se_extra 1
                getu .vm_distance temp3
                shiftr temp3 4
                geta[RETURN].zvel temp2
                add temp2 temp3
                seta[RETURN].zvel temp2
                ifg userdef .vm_distance 3072
                {
                    geta[RETURN].xvel temp3
                    add temp3 10
                    seta[RETURN].xvel temp3
                }
                eshoot P_ACIDYSPIT
                setav[RETURN].se_extra 1
                seta[RETURN].zvel temp2
                ifg userdef .vm_distance 3072
                {
                    geta[RETURN].xvel temp3
                    add temp3 10
                    seta[RETURN].xvel temp3
                }
                add temp7 3072
                seta .x temp4
                seta .y temp5
                seta .z temp7
                seta .sectnum temp6
            }
        }
        ifactioncount 6
        {
            action AC_MUTANT_GDF_IDLE
            set enemy_shoot 0
        }
    }
    ifaction AC_MUTANT_GDF_WALK
    {
        geta .htg_t 2 temp
        set temp2 temp
        mod temp2 4
        clamp temp 0 8
        shiftl temp 2
        ifl temp2 2
            shiftr temp 1
        ldist temp3 THISACTOR enemy_target
        ifl temp3 1536
            add temp 13
        set move_v temp
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ife enemy_target player.i
            ife cansee_return 1
                ifpdistl 512
                {
                    set enemy_xv 0
                    set enemy_yv 0
                }
        add enemy_stepcounter 1
        ifg enemy_stepcounter 8
        {
            iffloordistl 1 ifpdistl 8192 
            {
                ife enemy_stepcounter 12
                {
                    gets .floorpicnum surface_type
                    setp .sound_pitch -256
                    state player_footstep
                    set surface_type T_SLIME
                    setp .sound_pitch 256
                    state player_footstep
                    setp .sound_pitch 0
                }
                else ife enemy_stepcounter 28
                {
                    gets .floorpicnum surface_type
                    setp .sound_pitch -128
                    state player_footstep
                    set surface_type 6240
                    setp .sound_pitch 320
                    state player_footstep
                    setp .sound_pitch 0
                    set enemy_stepcounter 0
                }
            }
        }
    }
    else
    {
        set enemy_stepcounter 0
        set enemy_xv 0
        set enemy_yv 0
    }
    state enemy_do_move
enda


damageeventtile A_MECHBOSS_BOTTOM
damageeventtile A_MECHBOSS_TOP

appendevent EVENT_DAMAGESPRITE
    switch sprite[RETURN].picnum
        case A_MECHBOSS_TOP
        case A_MECHBOSS_BOTTOM
            ife sprite.picnum P_GRENADE ife actorvar[RETURN].mech_type 0
            {
                geta[RETURN].htextra temp2
                
                ifg temp2 0
                {
                    shiftl temp2 1
                    div temp2 3
                }
                seta[RETURN].htextra temp2
                ife temp2 -1
                    set RETURN -1
            }
            break
    endswitch
endevent
action AC_BOSSTOP_BASE 69 1 16 1 1 1
action AC_BOSSTOP_SHOOT 148 2 16 1 1 1
action AC_BOSSTOP_SHOOT2 180 2 16 1 1 4
action AC_BOSSBOTTOM_BASE 77 1 9 1 1
action AC_BOSSBOTTOM_WALK 77 7 9 1 12
action AC_BOSSBOTTOM_STOMP 77 7 9 1 8

appendevent EVENT_SPAWN
    switch sprite.picnum
        case A_MECHBOSS_BOTTOM
        case A_MECHBOSS_TOP
            
            ifspawnedby A_NEWRESPAWN
            {
                geta .owner respawntemp
                geta[respawntemp].pal respawntemp
                switch respawntemp
                    case PAL_MECHBOSS_MINI
                    case PAL_MECHBOSS_MINI_R
                        seta .pal respawntemp
                        break
                endswitch
            }
            ifactor A_MECHBOSS_TOP
                ifn sprite.htowner -1
                    seta .pal sprite[sprite.htowner].pal
            switch sprite.pal
                case PAL_MECHBOSS_MINI
                case PAL_MECHBOSS_MINI_R
                    sizeat 20 17
                    strength MECHBOSS_MINI_HEALTH
                    set boss_health MECHBOSS_MINI_HEALTH
                    ifspritepal PAL_MECHBOSS_MINI_R
                        set mech_type 1
                    ifspritepal PAL_MECHBOSS_MINI
                        set mech_type 2
                    state clear_enemy_vels
                    break
                default
                    sizeat 28 23
                    spritepal PAL_MECHBOSS
                    geta .hitag se_hitag
                    seta .hitag 0
                    break
            endswitch
            cstator 257
            changespritestat THISACTOR STAT_ACTOR
            sleeptime 300
            ifactor A_MECHBOSS_BOTTOM
            {
                getp .max_actors_killed temp
                sub temp 1
                setp .max_actors_killed temp
            }
            break
    endswitch
endevent

eventloadactor A_MECHBOSS_BOTTOM
    switch sprite.pal
        case PAL_MECHBOSS_MINI
        case PAL_MECHBOSS_MINI_R
            state enemy_load_init
            break
        default
            geta .lotag se_lotag
            seta .lotag 0
            geta .yvel se_yvel
            seta .yvel 0
            geta .xvel se_xvel
            seta .xvel 0
            break
    endswitch

    geta .owner tp_owner
enda


defstate mechboss_sparkit
    rand temp 2
    add temp 2
    for itervar range temp
    {
        espawn A_GENERIC_PARTICLE
        seta[RETURN].xrepeat 120
        seta[RETURN].pal 6

        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.htang
        add temp2 1024
        seta[RETURN].ang temp2


        geta .picnum temp2
        set temp4 tilesizy[temp2]
       // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
       // simplified to sizy*4*yrepeat
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        set temp2 sprite.z
        rand temp3 temp4
        sub temp2 temp3
        seta[RETURN].z temp2

        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.x
        seta[RETURN].x temp2
        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.y
        seta[RETURN].y temp2
    }
ends

defstate mechboss_smokeout
    rand temp 1
    add temp 1
    for itervar range temp
    {
        espawn A_SMOKE2
        rand temp2 8
        add temp2 8
        seta[RETURN].xrepeat temp2
        seta[RETURN].yrepeat temp2
        seta[RETURN].cstat 32768

        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.htang
        add temp2 1024
        seta[RETURN].ang temp2


        geta .picnum temp2
        set temp4 tilesizy[temp2]
       // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
       // simplified to sizy*4*yrepeat
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        set temp2 sprite.z
        rand temp3 temp4
        sub temp2 temp3
        seta[RETURN].z temp2

        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.x
        seta[RETURN].x temp2
        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.y
        seta[RETURN].y temp2

        set temp2 sprite[RETURN].sectnum
        updatesector sprite[RETURN].x sprite[RETURN].y temp2
        ife temp2 -1
        {
            seta[RETURN].xrepeat 0
            seta[RETURN].statnum STAT_ACTOR
        }
        else
            seta[RETURN].sectnum temp2
    }
ends

defstate mechboss_bleed
    geta .htang temp
    add temp 1024
    and temp 2047
    sub temp sprite.ang
    ifg temp 1023
        sub temp 2047
    ifl temp -1023
        add temp 2047
    abs temp

    ifg temp 16
        break

    rand temp 2
    add temp 2
    for itervar range temp
    {
        rand temp3 512
        add temp3 1024
        shiftl temp3 1
        inv temp3
        ezshoot temp3 P_BLOOD
        seta[RETURN].shade sprite.htg_t 8

        setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT
        rand temp2 16
        add temp2 32
        seta[RETURN].xvel temp2
        seta[RETURN].xrepeat 4
        seta[RETURN].yrepeat 4

        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.htang
        add temp2 1024
        seta[RETURN].ang temp2


        geta .picnum temp2
        set temp4 tilesizy[temp2]
       // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
       // simplified to sizy*4*yrepeat
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        shiftr temp4 1
        set temp2 sprite.z
        sub temp2 6144
        rand temp3 temp4
        sub temp2 temp3
        seta[RETURN].z temp2
    }
ends

defstate mechboss_sharedhit
    rand temp 2
    add temp 1
    for itervar range temp
    {
        espawn A_GENERIC_DEBRIS
        setav[RETURN].debris_type DEBRIS_METAL
        ifrnd 16
            seta[RETURN].pal 10
        ife boss_statechange 1
        {
            rand temp2 4
            add temp2 8
            setav[RETURN].debris_add_size temp2
            rand temp2 16
            setav[RETURN].debris_add_vel temp2
        }
        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.htang
        add temp2 1024
        seta[RETURN].ang temp2


        geta .picnum temp2
        set temp4 tilesizy[temp2]
       // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
       // simplified to sizy*4*yrepeat
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        set temp2 sprite.z
        rand temp3 temp4
        sub temp2 temp3
        seta[RETURN].z temp2

        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.x
        seta[RETURN].x temp2
        rand temp2 512
        ifrnd 127
            inv temp2
        add temp2 sprite.y
        seta[RETURN].y temp2

        set temp2 sprite[RETURN].sectnum
        updatesector sprite[RETURN].x sprite[RETURN].y temp2
        ife temp2 -1
        {
            seta[RETURN].xrepeat 0
            seta[RETURN].statnum STAT_ACTOR
        }
        else
            seta[RETURN].sectnum temp2
    }
    state mechboss_sparkit
ends

defstate mechboss_shade
    ife enemy_skipshade 0
    {
        ifoutside
            seta .shade sector.ceilingshade
        else
            seta .shade sector.floorshade
    }
    else
        set enemy_skipshade 0
ends

var mech_dist
defstate mech_adjust_dist
    ifn mech_dist 0
        ifn mech_type 0
        {
            shiftr mech_dist 2
            ifl mech_dist 1
                set mech_dist 1
        }
ends
useractor enemy A_MECHBOSS_TOP MECHBOSS_HEALTH AC_BOSSTOP_BASE
    state mechboss_shade
    ifspritepal PAL_MECHBOSS_MINI_R
        set mech_type 1
    ifspritepal PAL_MECHBOSS_MINI
        set mech_type 2
    ifpdistl 40960
    {

        ife boss_statechange -1
        {
            set boss_statechange 0
            getav[boss_btm_id].boss_health boss_health
        }
    }
    else ife boss_statechange -1
    {
        seta .htextra -1
        seta[boss_btm_id].htextra -1

        getav[boss_btm_id].boss_health boss_health
        ife mech_type 0
        {
            changespritestat boss_btm_id STAT_ZOMBIEACTOR
            changespritestat THISACTOR STAT_ZOMBIEACTOR
        }
        break
    }
    ife mech_type 0
    {
        set boss_currhp boss_health
        ifg boss_hpflash 0
            sub boss_hpflash 1
    }
    geta[boss_btm_id].ang temp
    add temp boss_top_ang
    and temp 2047
    seta .ang temp
    getav[boss_btm_id].tp_owner temp
    ifg temp 0
        set tp_owner temp

    ife counter 0
    {
        add boss_top_ang 16
        ifge boss_top_ang 400
        {
            set counter 1
            set boss_top_ang 400
        }
    }
    else ife counter 1
    {
        sub boss_top_ang 16
        ifle boss_top_ang -400
        {
            set counter 0
            set boss_top_ang -400
        }
    }

        ifn boss_btm_id -1
        {
            ife enemy_init 0
            {
                set enemy_init 1
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            }
        }
        else
        {
            ife sprite[boss_btm_id].statnum STAT_ZOMBIEACTOR
            {
                seta .htextra -1
                changespritestat THISACTOR STAT_ZOMBIEACTOR
            }
        }
        getp .i cansee_target
        geta .z temp
        sub temp 12288
        seta .z temp
        geta[cansee_target].z temp2
        sub temp2 12288
        seta[cansee_target].z temp2
        canseespr THISACTOR cansee_target cansee_return_o
        add temp 12288
        seta .z temp
        add temp2 12288
        seta[cansee_target].z temp2
        ldist temp6 THISACTOR player.i
        set cansee_return cansee_return_o
        state enemy_do_target_icon
        state enemy_checkw1alt
        set mech_dist 32768
        state mech_adjust_dist
        ife cansee_return_o 1 ifl temp6 mech_dist ife boss_turned 1
        {
            soundonce S_MECH_ROTATE
                set att_noclamp 1
            set att_target player.i
            ife boss_recog 0
            {
                sound S_MECH_RECOG
                set boss_recog 5
            }
            state angle_to_target
            ifn att_return 0
            {
                set enemy_fps_temp att_return
                shiftr enemy_fps_temp 4
                ifg enemy_fps_temp 0
                    set att_return 3
                else ifl enemy_fps_temp 0
                    set att_return -3
                else
                {
                    ifg att_return 0
                        set att_return 1
                    else
                        set att_return -1
                }
            }
            sub boss_top_ang att_return
            state angle_to_target
            abs att_return
            /* redefinequote 11 %ld
            qsprintf 11 11 enemy_shoot
            quote 11 */
            ifl att_return 32
            {
                ifaction AC_BOSSTOP_BASE
                {
                    sound S_MECH_PREPGUN2
                    action AC_BOSSTOP_SHOOT
                    set enemy_shoot 0
                }
            }
            else ifaction AC_BOSSTOP_SHOOT
            {
                ifactioncount 30
                    action AC_BOSSTOP_BASE

            }
            clamp boss_top_ang -400 400
            set counter 3

            ifn boss_mad 3
                set boss_mad 1
        }
        else
        {
            ife boss_recog 1
                sound S_MECH_LOST
            ifg boss_recog 0
                sub boss_recog 1
            ifaction AC_BOSSTOP_SHOOT
            {
                ifactioncount 30
                    action AC_BOSSTOP_BASE
            }
            ife counter 3
            {
                ifle boss_top_ang 0
                    set counter 0
                else
                    set counter 1
            }
            ife boss_mad 1
                set boss_mad 2
        }
        getav[boss_btm_id].boss_recog temp
        ifg temp 30
        {
            ifl temp 40
                ifrnd 64
                    set boss_mad 2
            shiftl enemy_xv 2
            shiftl enemy_yv 2
            set enemy_start 8
            switch sprite.pal
                case 9
                    spritepal 10
                    break
                case 10
                    spritepal 50
                    break
                default
                    spritepal 9
                    break
            endswitch
            ifand temp 2
            {
                espawn A_SMOKE2
                rand temp 31
                add temp 8
                seta[RETURN].xrepeat temp
                seta[RETURN].yrepeat temp
                seta[RETURN].cstat 32768
                rand temp 768
                ifrnd 127
                    inv temp
                add temp sprite.x
                seta[RETURN].x temp
                rand temp 768
                ifrnd 127
                    inv temp
                add temp sprite.y
                seta[RETURN].y temp
                rand temp 12287
                inv temp
                add temp sprite.z
                seta[RETURN].z temp
            }
        }
        else
        {
            switch mech_type
                case 1
                    spritepal PAL_MECHBOSS_MINI_R
                    break
                case 2
                    spritepal PAL_MECHBOSS_MINI
                    break
                default
                    spritepal PAL_MECHBOSS
                    break
            endswitch
        }
        ife boss_mad 3
        {
            ifaction AC_BOSSTOP_SHOOT2
                nullop
            else
            {
                sound S_MECH_PREPGUN1
                action AC_BOSSTOP_SHOOT2
                set att_target player.i
                set att_noclamp 1
                state angle_to_target
                sub boss_top_ang att_return
                clamp boss_top_ang -400 400
            }
            set boss_mad 0
        }
        else ifaction AC_BOSSTOP_SHOOT
        {
            ife sprite.htg_t 2 1
            {
                set face_target player.i
                set face_target player.i
                state face_actor
                seta .ang face_return
            }
            ife enemy_shoot 1
            {
                set enemy_skipshade 1
                seta .shade 0
                geta .x temp
                geta .y temp2
                geta .z temp5
                geta .ang temp3
                geta .sectnum temp9
                getu .vm_distance temp8
                set temp4 temp3
                sub temp4 512
                and temp4 2047
                seta .ang temp4
                ifn mech_type 0
                    set move_v 576
                else
                    set move_v 768
                state move_actor
                add move_xv sprite.x
                add move_yv sprite.y
                seta .x move_xv
                seta .y move_yv
                set move_v 30
                seta .ang temp3
                state move_actor
                add move_xv sprite.x
                add move_yv sprite.y
                seta .x move_xv
                seta .y move_yv
                set temp4 temp3
                ifpdistl 12288
                {
                    add temp4 32
                    rand temp8 8
                    ifrnd 127
                        inv temp8
                    add temp4 temp8
                    add temp4 40

                        ifn mech_type 0
                            add temp4 40
                }
                and temp4 2047
                seta .ang temp4
                add temp5 4096
                ifn mech_type 0
                    sub temp5 1024
                seta .z temp5
                ifand sprite.htg_t 2 1
                {
                    set att_target player.i
                    ifl att_return 256
                    {
                        set face_target player.i
                        state face_actor
                        seta .ang face_return
                    }
                }
                getprojectile[P_TURRET].workslike temp6
                rand temp7 255
                ifpdistl 16384
                {
                    ifg userdef.player_skill 2
                    {
                        shiftr temp7 1
                        ifg userdef.player_skill 3
                            ifrnd 32
                                shiftr temp7 1
                    }
                }
                else
                    shiftr temp7 1
                ifle temp7 32
                {
                    or temp6 1048576
                    setprojectile[P_TURRET].workslike temp6
                    shoot P_TURRET
                    xor temp6 1048576
                    setprojectile[P_TURRET].workslike temp6
                }
                else
                    shoot P_TURRET
                ldist temp6 THISACTOR player.i
                getp .posz h_zvel
                sub h_zvel sprite.z
                shiftl h_zvel 14
                div h_zvel temp6

                getp .i cansee_temp
                geta[cansee_temp].x face_x
                sub face_x sprite.x

                geta[cansee_temp].y face_y
                sub face_y sprite.y

                getangle cansee_temp3 face_x face_y

                set h_ang cansee_temp3
                cos h_cos h_ang
                sin h_sin h_ang
                hitscan sprite.x sprite.y sprite.z sprite.sectnum h_cos h_sin h_zvel hitsect hitwall hitsprite hitx hity hitz CLIPMASK_HITSCAN

                ifn hitsprite player.i
                {
                    ifl boss_canthit 15
                        add boss_canthit 1
                    else
                        set boss_canthit 120
                }
                else ifg boss_canthit 0
                    sub boss_canthit 1

                seta .ang temp3
                seta .x temp
                seta .y temp2
                set temp6 sprite.sectnum
                seta .sectnum temp9
                sub temp5 4096
                ifn mech_type 0
                    add temp5 1024
                seta .z temp5
                ifpdistl 18432
                {
                    set temp2 S_MECH_MGUN
                    soundvar temp2
                }
            }
            add enemy_shoot 1
            ifg enemy_shoot 2
                set enemy_shoot 0
        }
        else ife boss_mad 2
        {
            ifaction AC_BOSSTOP_SHOOT2
                nullop
            else
            {
                sound S_MECH_PREPGUN1
                action AC_BOSSTOP_SHOOT2
                set att_target player.i
                set att_noclamp 1
                state angle_to_target
                sub boss_top_ang att_return
                clamp boss_top_ang -400 400
            }
            set boss_mad 0
        }
        else ifg boss_canthit 0
            sub boss_canthit 1
        ifaction AC_BOSSTOP_SHOOT2
        {
            ife enemy_shoot 1
            {
                set enemy_skipshade 1
                seta .shade 0
                set att_target player.i
                set att_noclamp 1
                state angle_to_target
                sub boss_top_ang att_return
                clamp boss_top_ang -400 400

                ldist temp player.i THISACTOR
                ifn mech_type 1
                {
                    shiftr temp 2
                    inv temp
                }
                else
                {
                    geta .z temp5
                    geta[player.i].z temp6
                    sub temp6 temp5
                    shiftl temp6 8
                    div temp6 temp
                    set temp temp6
                }
                geta .x temp6
                geta .y temp2
                geta .z temp5
                geta .ang temp3
                set temp4 temp3
                add temp4 512
                and temp4 2047
                seta .ang temp4
                ifn mech_type 0
                    set move_v 320
                else
                    set move_v 384
                state move_actor
                add move_xv sprite.x
                add move_yv sprite.y
                seta .x move_xv
                seta .y move_yv
                set temp4 temp3
                sub temp4 20
                rand temp7 20
                ifrnd 127
                    inv temp7
                add temp4 temp7
                and temp4 2047
                seta .ang temp4
                add temp5 4096
                ifn mech_type 0
                    sub temp5 1024
                seta .z temp5
                geta .sectnum temp9
                set temp8 temp9
                updatesectorz sprite.x sprite.y sprite.z temp8
                ifn temp8 -1
                    seta .sectnum temp8
                ife mech_type 1
                {
                    getprojectile[P_MINIMISSILE].workslike temp4
                    or temp4 4096
                    setprojectile[P_MINIMISSILE].workslike temp4
                    ezshoot temp P_MINIMISSILE
                    xor temp4 4096
                    setprojectile[P_MINIMISSILE].workslike temp4
                    geta[RETURN].xvel temp8
                    add temp8 10
                    seta[RETURN].xvel temp8
                    ssp RETURN CLIPMASK1
                }
                else
                {
                    getprojectile[P_GRENADE].workslike temp4
                    or temp4 4096
                    setprojectile[P_GRENADE].workslike temp4
                    zshoot temp P_GRENADE
                    xor temp4 4096
                    setprojectile[P_GRENADE].workslike temp4
                }
                seta .x temp6
                seta .y temp2
                seta .z temp5
                seta .sectnum temp9
                ifpdistl 28672
                {
                    set temp2 S_MECH_GRENADE
                    soundvar temp2
                }
                add boss_grenades 1
            }
            add enemy_shoot 1
            ifg enemy_shoot 5
                set enemy_shoot 0
            ifactioncount 30
            {
                ife boss_grenades 6
                {
                    action AC_BOSSTOP_BASE
                    set boss_grenades 0
                }
            }
        }
        ifpdistl 24576
            nullop
        else
        {
            stopactorsound THISACTOR S_TRIFIRE1
            stopactorsound THISACTOR S_TRIFIRE2
            stopactorsound THISACTOR S_TRIFIRE3
            stopactorsound THISACTOR S_TRIFIRE4
        }
        ifn sprite.htextra -1
        {
            ifn sprite.htowner -1
            {
                geta .htowner temp
                switch sprite[temp].picnum
                    case A_MECHBOSS_BOTTOM
                    case A_MECHBOSS_TOP
                        ife boss_selfdmg 0
                            seta .htextra -1
                        else
                            set boss_selfdmg 0
                        break
                    case APLAYER
                        set cansee_return_o 2
                        set boss_recog 30
                        ife player.curr_weapon WEAPON_LOVERBOY
                        {
                            ifn weapon1_alt 0
                            {
                                 geta .htextra temp2
                                 shiftl temp2 1
                                 seta .htextra temp2
                            }
                        }
                        ife sprite.htpicnum P_SMG2
                        {
                            geta .htextra temp2
                            shiftr temp 1
                            clamp temp2 5 10
                            ifl temp2 8
                                add temp2 4
                            seta .htextra temp2
                        }
                        break
                endswitch
            }
        }

        state pup_damage_adjust
        geta .htextra temp6
        ifle boss_health 0
        {
            set boss_health -65536
            ifle sprite.htextra 0
                seta .htextra 1
        }
        else
        {
            set temp5 boss_health
            mul temp5 100
            ife mech_type 0
                div temp5 MECHBOSS_HEALTH
            else
                div temp5 MECHBOSS_MINI_HEALTH
            sub temp5 100
            abs temp5
            rand temp2 100
            add temp2 66
            ifl temp2 temp5
                state mechboss_sparkit
            rand temp2 100
            add temp2 50
            ifl temp2 temp5
                ifrnd 127
                    state mechboss_smokeout
        }
        ife boss_statechange 1
        {
            set temp5 12
            for temp5 range 12
            {
                state mechboss_sharedhit
                state mechboss_smokeout
            }
            setp .sound_pitch -1024
            sound S_SMASH_GLASSLAMP
            setp .sound_pitch 0
            set boss_statechange 2
        }
        ifl boss_lastang 0
        {
            inv boss_lastang
            seta .ang boss_lastang
            ifg enemy_lockang 0
            {
                inv boss_lastang
                sub enemy_lockang 1
            }
        }
        ifg enemy_annoyance 0
            sub enemy_annoyance 1
        ifhitweapon
        {
            ifg boss_lastang 0
                inv boss_lastang
            set enemy_lockang 2
            add enemy_annoyance temp6
            ifg enemy_annoyance 50
            {
                ifrnd 96
                {
                    getav[boss_btm_id].boss_recog temp
                    ifl temp 30
                        setav[boss_btm_id].boss_recog 120
                }
                else ifrnd 64
                    set boss_mad 3

                set enemy_annoyance 0
            }
            seta[boss_btm_id].cstat 257
            state mechboss_sharedhit
            ife boss_statechange 2
                state mechboss_bleed
            set boss_hpflash 12
            sub boss_health temp6
            ifle boss_health 0
            {
                espawn A_EXPLOSION
                seta[RETURN].xrepeat 72
                seta[RETURN].yrepeat 72
                geta[RETURN].z temp
                add temp 4096
                seta[RETURN].z temp
                setav[RETURN].smoke_offset 2048
                ifg boss_health -65536
                {
                    setav[boss_btm_id].boss_health boss_health
                    seta[boss_btm_id].htextra 100
                    setav[boss_btm_id].boss_selfdmg 1
                }
                sound S_MECH_MOAN
                ife mech_type 0
                {
                    set boss_currhp 0
                    set boss_fillhp 0
                }
                stopactorsound THISACTOR S_MECH_RECOG
                stopactorsound THISACTOR S_MECH_LOST
                stopactorsound THISACTOR S_MECH_STEP1
                stopactorsound THISACTOR S_MECH_STEP2
                stopactorsound THISACTOR S_MECH_ROTATE
                stopactorsound THISACTOR S_MECH_PREPGUN1
                stopactorsound THISACTOR S_MECH_PREPGUN2
                stopactorsound THISACTOR S_MECH_GRENADE
                stopactorsound THISACTOR S_MECH_HIT1
                stopactorsound THISACTOR S_MECH_HIT2
                stopactorsound THISACTOR S_MECH_DEATH
                stopactorsound THISACTOR S_MECH_MGUN
                ife mech_type 0
                    addkills 1

                ife mech_type 0
                    set fryall 1
                
                espawn I_MINIGUN
                setav[RETURN].st_do_once 1 // signal to not play the special shelly sound
                geta[RETURN].z temp
                sub temp 6144
                seta[RETURN].z temp
                rand temp 64
                add temp 96
                seta[RETURN].xvel temp
                rand temp -512
                sub temp 2048
                seta[RETURN].zvel temp
                geta .ang temp
                ifrnd 127
                    sub temp 256
                else
                    add temp 256
                and temp 2047
                seta[RETURN].ang temp
                ifg tp_owner 0 ife mech_type 0
                {
                    seta[RETURN].yvel tp_owner
                    setav[RETURN].se_yvel tp_owner
                }
                ssp RETURN CLIPMASK0
                state enemy_clearw1alt
                killit
            }
            else
            {
                setav[boss_btm_id].boss_health boss_health
                set mech_dist 12288
                state mech_adjust_dist
                ifg userdef.vm_distance mech_dist
                {
                    getav[boss_btm_id].boss_recog temp
                    ifl temp 30
                        setav[boss_btm_id].boss_recog 60
                }
                else
                {
                    getav[boss_btm_id].boss_recog temp
                    ifle temp 30
                        setav[boss_btm_id].boss_recog 30
                }
                ife mech_type 0
                    strength MECHBOSS_HEALTH
                else
                    strength MECHBOSS_MINI_HEALTH
            }
            rand temp 1
            add temp S_MECH_HIT1
            soundvar temp
        }
        else ifge boss_lastang 0
            geta .ang boss_lastang
enda

appendevent EVENT_ANIMATESPRITES
    ifactor A_MECHBOSS_BOTTOM
    {
        gettspr .tsprpicnum temp
        set temp4 tilesizy[temp]
       // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
       // simplified to sizy*4*yrepeat
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        geta .z temp
        sub temp temp4
        add temp 1024
        ifn boss_top_id -1
            seta[boss_top_id].z temp
        ife mech_type 0
            set temp MECHBOSS_HEALTH
        else
            set temp MECHBOSS_MINI_HEALTH
        shiftr temp 2
        ifle boss_currhp temp
        {
            gettspr .tsprpicnum temp
            add temp 207
            settspr .tsprpicnum temp
        }
    }
    else ifactor A_MECHBOSS_TOP
    {
        geta[boss_btm_id].htdispicnum temp
        set temp4 tilesizy[temp]
       // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
       // simplified to sizy*4*yrepeat
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        geta[boss_btm_id].z temp
        sub temp temp4
        add temp 1024
        seta .z temp
        ife mech_type 0 ifcount 10
        {
            set temp MECHBOSS_HEALTH
            shiftr temp 2
            ifle boss_currhp temp ifcount 2
            {
                ife boss_statechange 0
                    set boss_statechange 1
                gettspr .tsprpicnum temp
                ifaction AC_BOSSTOP_BASE
                    add temp 143
                else
                    add temp 80
                settspr .tsprpicnum temp
            }
        }
    }
endevent

defstate mechboss_init_attach_top
    geta .htdispicnum temp2
    set temp4 tilesizy[temp2]
    // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
    // simplified to sizy*4*yrepeat
    shiftl temp4 2
    mul temp4 sprite.yrepeat
    sub temp temp4
    add temp 1024
    seta[boss_top_id].z temp


    seta[boss_top_id].x sprite.x
    seta[boss_top_id].y sprite.y
    geta .z temp

    geta .htdispicnum temp2
    set temp4 tilesizy[temp2]
    shiftl temp4 2
    mul temp4 sprite.yrepeat
    sub temp temp4
    add temp 1024
    seta[boss_top_id].z temp
    geta .mdflags temp
    or temp 16
    seta .mdflags temp
    geta[boss_top_id].mdflags temp
    or temp 16
    seta[boss_top_id].mdflags temp
    seta[boss_top_id].sectnum sprite.sectnum
    setav[boss_top_id].mech_type mech_type
    seta .shade sprite[boss_top_id].shade
    changespritestat boss_top_id STAT_ACTOR
ends

defstate mechboss_attach_top
    seta[boss_top_id].x sprite.x
    seta[boss_top_id].y sprite.y
    geta .z temp

    geta .htdispicnum temp2
    set temp4 tilesizy[temp2]
   // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
   // simplified to sizy*4*yrepeat
    shiftl temp4 2
    mul temp4 sprite.yrepeat
    sub temp temp4
    add temp 1024
    seta[boss_top_id].z temp
    geta .mdflags temp
    or temp 16
    seta .mdflags temp
    geta[boss_top_id].mdflags temp
    or temp 16
    seta[boss_top_id].mdflags temp
    seta[boss_top_id].sectnum sprite.sectnum
ends

defstate mechboss_calc_waypoint
    set way_temp3 0
    for way_temp sprofstat STAT_LOCATOR
    {
        getav[way_temp].se_hitag way_temp2
        ife way_temp2 se_hitag
        {
            getav[way_temp].se_lotag way_temp2
            ife way_temp2 patrol_num
            {
                set way_current way_temp
                ldist way_temp2 way_temp THISACTOR
                ifl way_temp2 256
                {
                    ife boss_dir 0
                        add patrol_num 1
                    else
                    {
                        sub patrol_num 1
                        ifl patrol_num 0
                            add patrol_num boss_numpts
                    }
                    ifg sprite[way_temp].extra 0
                        ifrnd 64
                            set se_hitag sprite[way_temp].extra
                }
                set way_temp3 1
            }
            ldist temp6 way_temp player.i
            ife temp5 -1
            {
                set temp5 temp6
                set boss_bestnum sprite[way_temp].lotag
                set boss_bestpt way_temp
            }
            else ifl temp6 temp5
            {
                set temp5 temp6
                set boss_bestnum sprite[way_temp].lotag
                set boss_bestpt way_temp
            }
        }
    }
    ife way_temp3 0
        set patrol_num 0
    set enemy_search 0
    stopactorsound THISACTOR S_CULTIST_ROAM1
    stopactorsound THISACTOR S_CULTIST_ROAM2
    stopactorsound THISACTOR S_CULTIST_ROAM3
ends

defstate mechboss_hp_triggers
    ife mech_type 0
    {
        ifl boss_fillhp 100
        {
            ife boss_fillhp 0
            {
                starttrackslot -1 0
            }
            else ife boss_fillhp 30
            {
                stopactorsound player.i S_SHELLY_SEARCHTALK1
                stopactorsound player.i S_SHELLY_SEARCHTALK2
                stopactorsound player.i p_lastline
                setarray sound_playback[p_lastline] 0
                actorsound player.i S_SHELLYVO_LVLSND7
                set p_lastline S_SHELLYVO_LVLSND7
            }
            add boss_fillhp 2
            
            ifl boss_fillhp 96
                ifand boss_fillhp 4
                    soundonce S_PCBEEP
        }
    }
    ifg se_yvel 0 ife mech_type 0
    {
        ife st_do_once 0
        {
            ife mech_type 0
                set temp MECHBOSS_HEALTH
            else
                set temp MECHBOSS_MINI_HEALTH
            shiftr temp 1
            ifle boss_health temp
            {
                set st_do_once 1
                operateactivators se_yvel THISACTOR
                operatemasterswitches se_yvel

                operaterespawns se_yvel

                setarray preloadactivations[se_yvel] 1
            }
        }
    }
    ifg se_xvel 0 ife mech_type 0
    {
        operateactivators se_xvel THISACTOR
        operatemasterswitches se_xvel
        operaterespawns se_xvel
        setarray preloadactivations[se_xvel] 1
        set se_xvel 0
    }
ends

defstate mechboss_fps
    state angle_to_target
    ifn att_return 0
    {
        ife att_target player.i
        {
            set enemy_fps_temp att_return
            shiftr enemy_fps_temp 4
            ifg enemy_fps_temp 0
            {
                set att_return 16
            }
            else ifl enemy_fps_temp 0
            {
                set att_return -16
            }
            else
            {
                ifl att_return 0
                    set att_return -1
                else
                    set att_return 1
            }
        }
        else
        {
            set enemy_fps_temp att_return
            shiftr enemy_fps_temp 4
            ifg enemy_fps_temp 0
                set att_return enemy_fps_temp
            else ifl enemy_fps_temp 0
                set att_return enemy_fps_temp
        }
    }
    set boss_turned att_return
    abs boss_turned
    ifl boss_turned 320
        setav[boss_top_id].boss_turned 1
    else
        setav[boss_top_id].boss_turned 0
    geta .ang enemy_fps_temp
    sub enemy_fps_temp att_return
    and enemy_fps_temp 2047
    seta .ang enemy_fps_temp
ends

useractor enemy A_MECHBOSS_BOTTOM MECHBOSS_HEALTH AC_BOSSBOTTOM_BASE
    ife counter 0
    {
        espawn A_MECHBOSS_TOP
        ifn se_lotag 0 ife mech_type 0
            set patrol_num se_lotag
        set se_lotag 0
        setav[RETURN].boss_btm_id THISACTOR
        set boss_top_id RETURN
        set counter 1
        for way_temp sprofstat STAT_LOCATOR
        {
            getav[way_temp].se_hitag way_temp2
            ife way_temp2 se_hitag
            {
                add boss_numpts 1
            }
        }
        state mechboss_init_attach_top
        ife mech_type 0
            changespritestat THISACTOR STAT_ZOMBIEACTOR
        set boss_type 0
        break
    }
    seta .shade sprite[boss_top_id].shade
    ifpdistl 40960
    {
        seta[boss_top_id].pal sprite.pal
        ife boss_statechange -1
        {
            ife mech_type 0
                set boss_statechange 0
        }
    }
    else ife boss_statechange -1
    {
        seta .htextra -1
        ife counter 1
        {
            set counter 2
            seta[boss_top_id].htextra -1
            seta[boss_top_id].pal sprite.pal
            changespritestat boss_top_id STAT_ZOMBIEACTOR
            changespritestat THISACTOR STAT_ZOMBIEACTOR
        }
        break
    }
    changespritestat boss_top_id STAT_ACTOR
    state mechboss_hp_triggers
    fall

    state mechboss_attach_top
    sleeptime 300
    set temp5 -1
    ifn se_hitag 0
    {
        state mechboss_calc_waypoint

        set att_noclamp 1
        set att_target way_current
        ldist temp6 THISACTOR player.i
        getp .i cansee_target
        geta .z temp
        sub temp 12288
        seta .z temp
        geta[cansee_target].z temp2
        sub temp2 12288
        seta[cansee_target].z temp2
        canseespr THISACTOR cansee_target cansee_return_o
        ifpdistl 40960
            ifn mech_type 0
                ife boss_statechange -1
                {
                    ife cansee_return_o 1
                        set boss_statechange -1
                    else
                    {
                        add temp 12288
                        seta .z temp
                        add temp2 12288
                        break
                    }
                        
                }
        add temp 12288
        seta .z temp
        add temp2 12288
        seta[cansee_target].z temp2
        getav[boss_top_id].boss_canthit boss_canthit
        ifg boss_canthit 15
            set cansee_return_o 0
        ifn sprite.htextra -1
        {
            ifn sprite.htowner -1
            {
                geta .htowner temp
                switch sprite[temp].picnum
                    case A_MECHBOSS_BOTTOM
                    case A_MECHBOSS_TOP
                        ife boss_selfdmg 0
                            seta .htextra -1
                        else
                            set boss_selfdmg 0
                        break
                    case APLAYER
                        set cansee_return_o 2

                        ifg userdef.vm_distance 12288
                        {
                            ifl boss_recog 30
                            {
                                set boss_recog 60
                                set boss_bestnum sprite[boss_bestpt].lotag
                                set patrol_num sprite[boss_bestpt].lotag
                                set se_hitag sprite[boss_bestpt].hitag
                                set way_current boss_bestpt
                            }
                        }
                        else
                            set boss_recog 30
                        ife sprite.htpicnum P_SMG2
                        {
                            geta .htextra temp2
                            shiftr temp 1
                            clamp temp2 5 10
                            ifl temp2 8
                                add temp2 4
                            seta .htextra temp2
                        }
                        break
                endswitch
            }
        }
        ifn boss_recog 0
        {
            set cansee_return_o 2
            sub boss_recog 1
        }
        ifn cansee_return_o 0
        {
            ife cansee_return_o 2
            {
                ldist temp2 boss_bestpt player.i
                set mech_dist 8192
                state mech_adjust_dist
                ifg temp2 mech_dist
                {
                    ldist temp2 boss_bestpt THISACTOR
                    set mech_dist 4096
                    state mech_adjust_dist
                    ifg temp2 mech_dist
                        set att_target boss_bestpt
                    else
                        set att_target player.i
                }
                else
                    set att_target boss_bestpt
            }
            set temp patrol_num
            sub temp boss_bestnum
            set temp2 boss_numpts
            shiftr temp2 1
            add temp temp2
            ifg temp temp2
                sub temp boss_numpts
            /* redefinequote 11 %ld %ld %ld %ld
            qsprintf 11 11 boss_numpts patrol_num boss_bestnum temp
            quote 11 */
            ifl temp 0 // patrol_num
                set boss_dir 1
            else
                set boss_dir 0
            set mech_dist 8192
            state mech_adjust_dist
            ifl temp6 mech_dist
                set att_target player.i
            else
            {
                ldist temp2 way_current player.i
                ifg temp2 mech_dist
                {
                    ldist temp3 boss_bestpt player.i
                    ifg temp3 mech_dist
                    {
                        set mech_dist 4096
                        state mech_adjust_dist
                        ldist temp2 boss_bestpt THISACTOR
                        ifg temp2 mech_dist
                        {
                            set att_target boss_bestpt
                            set boss_bestnum sprite[boss_bestpt].lotag
                            // recalculate
                            set temp patrol_num
                            sub temp boss_bestnum
                            set temp2 boss_numpts
                            shiftr temp2 1
                            add temp temp2
                            ifg temp temp2
                                sub temp boss_numpts
                            ifl temp 0 // patrol_num
                                set boss_dir 1
                            else
                                set boss_dir 0
                        }
                        else
                            set att_target player.i
                    }
                }
            }
        }
        state mechboss_fps
        ifl enemy_start 8
        {
            ifrnd 64
                add enemy_start 1
        }
        else ifrnd 64
        {
            sub enemy_start 2
            clamp enemy_start 0 8
        }
        ife att_target player.i
            shiftr enemy_start 1
        ifg enemy_start 0
        {
            ifaction AC_BOSSBOTTOM_BASE
                action AC_BOSSBOTTOM_WALK
        }
        else ifaction AC_BOSSBOTTOM_WALK
        {
            ifn att_return 0
                nullop
            else ifactioncount 3
                action AC_BOSSBOTTOM_BASE
        }
        else ifaction AC_BOSSBOTTOM_BASE
        {
            set mech_dist 2048
            state mech_adjust_dist
            ifl mech_dist 1024
                set mech_dist 1024
            ifl userdef.vm_distance mech_dist
                action AC_BOSSBOTTOM_STOMP
            else
            ifn att_return 0
                    action AC_BOSSBOTTOM_WALK
        }
        else ifaction AC_BOSSBOTTOM_STOMP
        {
            
            set mech_dist 2048
            state mech_adjust_dist
            ifl mech_dist 1024
                set mech_dist 1024
            ifl userdef.vm_distance mech_dist
            {
                switch sprite.htg_t 2
                    case 2
                    case 4
                    case 6
                        addphealth -2
                        setp .sound_pitch 512
                        sound S_DOOR_CLANK_HUGE
                        setp .sound_pitch 0
                        break
                endswitch
                switch sprite.htg_t 2
                    case 0
                        sound S_MECH_STEP1
                        break
                    case 4
                        sound S_MECH_STEP2
                        break
                endswitch
            }
            else
                action AC_BOSSBOTTOM_BASE
            ifactioncount 6
                resetactioncount
        }
        set move_v enemy_start
        shiftl move_v 3
        state move_actor
        set enemy_xv move_xv
        set enemy_yv move_yv
        ifg boss_recog 30
        {
            switch mech_type
                case 1
                case 2
                    sub boss_recog 1
                    break
            endswitch
            shiftl enemy_xv 2
            shiftl enemy_yv 2
            set enemy_start 8
            switch sprite.pal
                case 9
                    spritepal 10
                    break
                case 10
                    spritepal 50
                    break
                default
                    spritepal 9
                    break
            endswitch
            ifand boss_recog 2
            {
                espawn A_SMOKE2
                rand temp 31
                add temp 8
                seta[RETURN].xrepeat temp
                seta[RETURN].yrepeat temp
                seta[RETURN].cstat 32768
                rand temp 768
                ifrnd 127
                    inv temp
                add temp sprite.x
                seta[RETURN].x temp
                rand temp 768
                ifrnd 127
                    inv temp
                add temp sprite.y
                seta[RETURN].y temp
                rand temp 12287
                inv temp
                sub temp 4096
                add temp sprite.z
                seta[RETURN].z temp
            }
            switch boss_recog
                case 59
                case 56
                case 50
                case 45
                case 37
                    setp .sound_pitch 512
                    sound S_DOOR_CLANK_HUGE
                    setp .sound_pitch 0
                    geta .htg_t 2 temp
                    add temp 1
                    seta .htg_t 2 temp
                    break
            endswitch
        }
        else
        {
            switch mech_type
                case 1
                    spritepal PAL_MECHBOSS_MINI_R
                    break
                case 2
                    spritepal PAL_MECHBOSS_MINI
                    break
                default
                    spritepal PAL_MECHBOSS
                    break
            endswitch
        }

        ifn sector.lotag 8192 ifn sector.lotag 8193
        {
            geta .x enemy_tox
            geta .y enemy_toy
            geta .z enemy_toz
            geta .sectnum enemy_tos
        }
        movesprite THISACTOR enemy_xv enemy_yv 0 CLIPMASK0 temp
        ifvarn temp -1 ife reverse_dir 0
        {
            ifg temp 49151
            {
                sub temp 49152
                getav[temp].actor_moveable temp2
                ife temp2 1
                {
                    getav[temp].actor_moveable_xv temp2
                    set temp3 enemy_xv
                    shiftr temp3 1
                    ifl temp3 2 ifg temp3 -2
                        set temp3 0
                    add temp2 temp3
                    setav[temp].actor_moveable_xv temp2

                    getav[temp].actor_moveable_yv temp2
                    set temp3 enemy_yv
                    shiftr temp3 1
                    ifl temp3 2 ifg temp3 -2
                        set temp3 0
                    add temp2 temp3
                    setav[temp].actor_moveable_yv temp2
                }

            }
        }
        ifg sector.lotag 8191 ifl sector.lotag 8194
        {
            seta .x enemy_tox
            seta .y enemy_toy
            seta .sectnum enemy_tos
            rand temp4 256
            ifrnd 127
                inv temp4

            add temp4 sprite.ang
            and temp4 2047
            seta .ang temp4

            movesprite THISACTOR -enemy_xv -enemy_yv 0 CLIPMASK0 temp
            set enemy_xv 0
            set enemy_yv 0

            geta .z temp4
            sub temp4 8192
            seta .z temp4
            canseespr THISACTOR way_current way_temp3
            set temp6 65536
            ife way_temp3 -1
            {
                for way_temp sprofstat STAT_LOCATOR
                {
                    getav[way_temp].se_hitag way_temp2
                    ife way_temp2 se_hitag
                    {
                        getav[way_temp].se_lotag way_temp2
                        canseespr THISACTOR way_current way_temp3
                        ife way_temp3 1
                        {
                            ldist way_temp2 way_temp THISACTOR

                            ifl way_temp2 temp6
                            {
                                set way_current way_temp
                                set temp6 way_temp2
                                set patrol_num sprite[way_current].lotag
                            }
                        }
                    }
                }
            }
            ife boss_dir 0
                set boss_dir 1
            else
                set boss_dir 0
            add temp4 8192
            seta .z temp4
        }
        /* redefinequote 11 %ld
        qsprintf 11 11 patrol_num
        quote 11 */
        geta .htextra temp6
        ifle boss_health 0
        {
            set boss_health -65536
            ifle sprite.htextra 0
                seta .htextra 1
        }
        ifaction AC_BOSSBOTTOM_WALK
        {
            switch sprite.htg_t 2
                case 0
                    sound S_MECH_STEP1
                    break
                case 4
                    sound S_MECH_STEP2
                    break
            endswitch
            ifactioncount 6
                resetactioncount
        }
    }
    state pup_damage_adjust
    geta .htextra temp4

    ifl boss_lastang 0
    {
        inv boss_lastang
        seta .ang boss_lastang
        ifg enemy_lockang 0
        {
            inv boss_lastang
            sub enemy_lockang 1
        }
    }
    ifhitweapon
    {
        ifg boss_lastang 0
            inv boss_lastang
        set enemy_lockang 2
        seta[boss_top_id].cstat 257
        state mechboss_sharedhit
        set boss_hpflash 12
        sub boss_health temp6
        ifle boss_health 0
        {
            espawn A_EXPLOSION
            seta[RETURN].xrepeat 72
            seta[RETURN].yrepeat 72
            geta[RETURN].z temp
            add temp 4096
            seta[RETURN].z temp
            setav[RETURN].smoke_offset 2048
            ifg boss_health -65536
            {
                ifn sprite[boss_top_id].statnum STAT_MAXSTATUS
                {
                    setav[boss_top_id].boss_health boss_health
                    seta[boss_top_id].htextra 100
                }
                setav[boss_top_id].boss_selfdmg 1
            }
            sound S_MECH_DEATH
            ife mech_type 0
            {
                set boss_currhp 0
                set boss_fillhp 0
            }
            stopactorsound THISACTOR S_MECH_RECOG
            stopactorsound THISACTOR S_MECH_LOST
            stopactorsound THISACTOR S_MECH_STEP1
            stopactorsound THISACTOR S_MECH_STEP2
            stopactorsound THISACTOR S_MECH_ROTATE
            stopactorsound THISACTOR S_MECH_PREPGUN1
            stopactorsound THISACTOR S_MECH_PREPGUN2
            stopactorsound THISACTOR S_MECH_GRENADE
            stopactorsound THISACTOR S_MECH_HIT1
            stopactorsound THISACTOR S_MECH_HIT2
            stopactorsound THISACTOR S_MECH_MGUN
            stopactorsound THISACTOR S_MECH_MOAN
            stopactorsound THISACTOR S_DOOR_CLANK_HUGE
            ifn mech_type 0
            {
                strength 0
                state enemy_die_resolve
            }
            else
            {
                ife VOLUME EP_MAIN
                    ife LEVEL EP_MAIN_ZONE_2_END
                        or cheevo_tracker 4
            }
            killit
        }
        else
        {
            setav[boss_top_id].boss_health boss_health
            ife mech_type 0
                strength MECHBOSS_HEALTH
            else
                strength MECHBOSS_MINI_HEALTH
        }
        rand temp 1
        add temp S_MECH_HIT1
        soundvar temp
    }
    else ifge boss_lastang 0
        geta .ang boss_lastang
enda

spritenoshade A_HESKEL_BOT
spritenopal A_HESKEL_BOT
eventloadactor A_HESKEL_BOT
    geta .lotag se_lotag
    seta .lotag 0
    geta .hitag se_hitag
    seta .hitag 0
    clamp se_hitag 0 65536
    geta .xvel se_xvel
    seta .xvel 0
    geta .yvel se_yvel
    seta .yvel 0
    cstat 0
    spritepal 80
    sizeat 25 22
enda

action AC_HESKEL_IDLE 0 4 5 1 16
action AC_HESKEL_ANGRY 55 5 5 1 16
action AC_HESKEL_PAIN 25 5 5 1 16

useractor notenemy A_HESKEL_BOT 0 AC_HESKEL_IDLE

    ifaction AC_HESKEL_IDLE
    {
        seta .htg_t 2 counter2
        seta .htg_t 3 counter2
        add counter 1
        ifge counter 5
        {
            rand counter2 3
            set counter 0
        }
    }
    ifg se_hitag 0
        ife activateshit[se_hitag] 1
            ifge counter3 0
                set counter3 1
    ifg se_lotag 0
        ife activateshit[se_lotag] 1
                set counter3 -1
    ifg counter3 0
    {
        add counter3 1
        ifaction AC_HESKEL_ANGRY
        {
            seta .htg_t 2 counter2
            seta .htg_t 3 counter2
            ifg counter3 80
                ifg counter2 0
                    set db_temp 1
            add counter 1
            ifge counter 3
            {
                set temp 1
                ife db_temp 1
                    inv temp
                add counter2 temp
                switch counter2
                    case 4
                    case 5
                        ife db_temp 0
                            set db_temp 1
                        break
                    case -1
                    case 0
                        ife db_temp 1
                            set db_temp 0
                        break
                    case 2
                    case 3
                        ifrnd 96
                            xor db_temp 1
                        break
                endswitch
                mod counter2 5
                set counter 0
            }
        }
        else
        {
            rand counter2 2
            set db_temp 0
            action AC_HESKEL_ANGRY
        }
        ifg counter3 90
        {
            set counter3 0
            set counter2 0
            seta .htg_t 2 0
            seta .htg_t 3 0
            action AC_HESKEL_IDLE
        }
    }
    else ifl counter3 0
    {
        sub counter3 1
        ifaction AC_HESKEL_PAIN
        {
            seta .htg_t 2 counter2
            seta .htg_t 3 counter2
            ifl counter3 -20
                ifg counter2 0
                    set db_temp 1
            add counter 1
            ifge counter 3
            {
                set temp 1
                ife db_temp 1
                    inv temp
                add counter2 temp
                switch counter2
                    case 4
                    case 5
                        ife db_temp 0
                            set db_temp 1
                        break
                    case -1
                    case 0
                        ife db_temp 1
                            set db_temp 0
                        break
                    case 2
                    case 3
                        ifrnd 96
                            xor db_temp 1
                        break
                endswitch
                mod counter2 5
                set counter 0
            }
        }
        else
        {
            set db_temp 0
            action AC_HESKEL_PAIN
        }
        ifl counter3 -60
        {
            set counter3 0
            set counter2 0
            seta .htg_t 2 0
            seta .htg_t 3 0
            action AC_HESKEL_IDLE
        }
    }
enda

appendevent EVENT_SPAWN
    ifactor A_PSEUDO_ENEMY
    {
        cstat 33024
        switch se_xvel
            case 1
                strength SBOSS_HEALTH
                break
            default
                strength HBOSS_HEALTH
                break
        endswitch
        set boss_fillhp 0
        ifg se_yvel 0
        {
            sleeptime 300
            set boss_recog 2
            changespritestat THISACTOR STAT_ACTOR
        }
    }
endevent

eventloadactor A_PSEUDO_ENEMY
    geta .lotag se_lotag
    seta .lotag 0
    geta .hitag se_hitag
    seta .hitag 0
    clamp se_hitag 0 100
    ifle se_hitag 0
        set se_hitag 100
    geta .xvel se_xvel
    seta .xvel 0
    geta .yvel se_yvel
    seta .yvel 0
enda
var ship_bbomb_count
defstate pseudo_ship
    ife st_do_once 0
    {
        set st_do_once sprite.extra
        geta .extra temp
        set counter2 temp
        mul temp se_hitag
        div temp 100
        set counter2 temp
        ife counter2 0
            set counter2 1
        for itervar sprofstat STAT_MASTER_MOVER
        {
            ife actorvar[itervar].pivot_hitag se_yvel
                set ps_master_id itervar
        }
    }
    ife bbomb_mode 1
    {
        findnearactorz P_BOWLINGBOMB 4096 2048 temp
        ifn temp -1
        {
            ifg actorvar[temp].bbomb_move_v 0
            {
                seta[temp].x sprite.x
                seta[temp].y sprite.y
                seta[temp].z sprite.z
                seta[temp].sectnum sprite.sectnum
                set temp2 temp
                add temp2 49152
                setav[temp].bbomb_interrupt temp2
            }
        }
    }
    ifn ps_master_id -1
    {
        seta .x sprite[ps_master_id].x
        seta .y sprite[ps_master_id].y
        set temp sprite[ps_master_id].z
        set temp4 tilesizy[A_PSEUDO_ENEMY]
        shiftl temp4 2
        mul temp4 sprite.yrepeat
        shiftr temp4 1
        add temp temp4
        seta .z temp
        seta .sectnum sprite[ps_master_id].sectnum
    }
    ife boss_recog 2
    {
        ifcanseetarget
            set boss_recog 0
        else ifg sprite.htextra 0
            set boss_recog 0
        else
            break
    }
    set enemy_init 1
    ifl boss_fillhp 100
    {
        add boss_fillhp 2
        ifl boss_fillhp 96
            ifand boss_fillhp 4
                soundonce S_PCBEEP
        ife boss_fillhp 2
            set boss_currhp SBOSS_HEALTH
    }
    set boss_type 1
    
    ifdead ife counter counter3
    {
        espawn A_EXPLOSION
        seta[RETURN].xrepeat 72
        seta[RETURN].yrepeat 72
        geta[RETURN].z temp
        add temp 4096
        seta[RETURN].z temp
        setav[RETURN].smoke_offset 2048
        set boss_currhp 0
        set boss_fillhp 0
        ifn ps_master_id -1
            setav[ps_master_id].ps_flash -1
        addkills 1
        ife VOLUME EP_MAIN
            ife LEVEL EP_MAIN_ZONE_3_END
                or cheevo_tracker 8
        killit
    }
    
    ifg boss_hpflash 0
        sub boss_hpflash 1
    state pup_damage_adjust
    
    ifg se_lotag 0
    {
        geta .extra temp
        ifg sprite.htextra 0
        {
            add enemy_annoyance sprite.htextra
            clamp enemy_annoyance 0 st_do_once
            set counter3 enemy_annoyance
            div counter3 counter2
        }
        ifl counter counter3
        {
            set temp se_lotag
            add temp counter
            operateactivators temp THISACTOR
            operatemasterswitches temp
            operaterespawns temp
            setarray preloadactivations[temp] 1
            add counter 1
        }
    }
    geta .htextra temp
    ifhitweapon
    {
        sub boss_currhp temp
        set boss_hpflash 12
        ifn ps_master_id -1
        {
            ifl actorvar[ps_master_id].ps_flash 12
                setav[ps_master_id].ps_flash 12
        }
    }
ends

useractor enemy A_PSEUDO_ENEMY 5000
    ifle se_xvel 0
    {
        set boss_type 5
        set heskel_sectnum sprite.sectnum
        ifl boss_fillhp 100
        {
            add boss_fillhp 2
            ife boss_fillhp 2
                set boss_currhp HBOSS_HEALTH
            ifl boss_fillhp 96
                ifand boss_fillhp 4
                    soundonce S_PCBEEP
        }
        ife st_do_once 0
        {
            set st_do_once sprite.extra
            geta .extra temp
            set counter2 temp
            mul temp se_hitag
            div temp 100
            set counter2 temp
            ife counter2 0
                set counter2 1
        }
        ifdead ife counter counter3
        {
            espawn A_EXPLOSION
            seta[RETURN].xrepeat 72
            seta[RETURN].yrepeat 72
            geta[RETURN].z temp
            add temp 4096
            seta[RETURN].z temp
            setav[RETURN].smoke_offset 2048
            set boss_currhp 0
            set boss_fillhp 0
            addkills 1
            ife VOLUME EP_MAIN
                ife LEVEL EP_MAIN_ZONE_7_END
                    or cheevo_tracker 128
            killit
        }
        ifg boss_hpflash 0
            sub boss_hpflash 1
        state pup_damage_adjust
        ifg se_lotag 0
        {
            geta .extra temp
            ifg sprite.htextra 0
            {
                add enemy_annoyance sprite.htextra
                clamp enemy_annoyance 0 st_do_once
                set counter3 enemy_annoyance
                div counter3 counter2
            }
            ifl counter counter3
            {
                set temp se_lotag
                add temp counter
                operateactivators temp THISACTOR
                operatemasterswitches temp
                operaterespawns temp
                setarray preloadactivations[temp] 1
                add counter 1
            }
        }
        geta .htextra temp
        ifhitweapon
        {
            sub boss_currhp temp
            set boss_hpflash 12
        }
    }
    else
    {
        switch se_xvel
            case 1
                state pseudo_ship
                break
        endswitch
    }
enda

var hide_bosshp

appendevent EVENT_DISPLAYREST
    ifp palive
    ifg boss_fillhp 0
    ife hide_bosshp 0
    ifn userdef.screen_size 0
    {
        // bar
        state ResetTile
        set hudx_x 320
        set hudx_y 30
        set hudx_tilenum 5883
        set hudx_orientation 1
        state DrawTile640x480Screen

        set hudx_tilenum 5884
        set hudx_orientation 0
        ifl boss_fillhp 100
        {
            ifand boss_hpflash 2
                set hudx_pal 1
            else
                set hudx_pal 5

            set hudx_x1 0
            set hudx_y1 0
            set hudx_y2 ydim
            scalevar GetWindowX 8192000 boss_fillhp 100 // (126 - 1) * hudx_scale
            add GetWindowX 20971520 // hudx_x << 16
            sub GetWindowX 4063232 // (63 - 1) * hudx_scale
            state 640Full16_to_xdim
            set hudx_x2 GetWindowX
            sub hudx_x2 1

            state DrawTile640x480Screen_Windowed
        }
        else
        {
            ifand boss_hpflash 2
                set hudx_pal 1
            else
            {
                
                switch boss_type
                    case 1
                        set temp SBOSS_HEALTH
                        break
                    case 2
                        set temp brute_boss_hp
                        break
                    case 5
                        set temp HBOSS_HEALTH
                        break
                    default
                        set temp MECHBOSS_HEALTH
                        break
                endswitch
                shiftr temp 1
                ifle boss_currhp temp
                {
                    shiftr temp 1
                    ifle boss_currhp temp
                        set hudx_pal 9
                    else
                        set hudx_pal 11
                }
                else
                    set hudx_pal 5
            }
            switch boss_type
                case 1
                    set temp9 SBOSS_HEALTH
                    break
                case 2
                    set temp9 brute_boss_hp
                    break
                case 5
                    set temp9 HBOSS_HEALTH
                    break
                default
                    set temp9 MECHBOSS_HEALTH
                    break
            endswitch
            ifl boss_currhp temp9
            {
                set hudx_x1 0
                set hudx_y1 0
                set hudx_y2 ydim
                scalevar GetWindowX 8192000 boss_currhp temp9 // (126 - 1) * hudx_scale
                add GetWindowX 20971520 // hudx_x << 16
                sub GetWindowX 4063232 // (63 - 1) * hudx_scale
                state 640Full16_to_xdim
                set hudx_x2 GetWindowX
                sub hudx_x2 1

                state DrawTile640x480Screen_Windowed
            }
            else
                state DrawTile640x480Screen
        }

        state ResetText
        set hudx_y 5
        set hudx_scale 36864
        set hudx_pal 9
        set hudx_tilenum STARTALPHANUM
        set hudx_orientation 17
        set hudx_quote 190
        switch boss_type
            case 1
                redefinequote 190 REVENANT 8991-PX
                break
            case 2
                redefinequote 190 MEGA BRUTALIZER TWINS
                break
            case 5
                redefinequote 190 HESKEL AND HIS BITCHIN' TERROR DOME
                break
            default
                redefinequote 190 WARMECH
                break
        endswitch
        set hudx_txtflags 2
        state DrawText640x480Screen
    }
endevent
