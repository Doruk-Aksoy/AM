/*
--------------------------------------------------------------------------------
================================================================================
                          +:                                                   
WWW@*WWWWWWW+  *WWWWWWW*  :=@       @WWWWWWWWW*WWW*  =WWW*WWWWWWWWWW@*WWW+  @WW
WWW@*WWWWWWWWW**WWWWWWWWW=   =*     @WWWWWWWWW*WWW*  =WWW*WWWWWWWWWW@*WWW+  @WW
WWW@*WWW+  WWWW*WWW*  @WWW :WWWWWW+ @WWW*    *+WWW*  =WWW*WWW#=#WWWW#*WWWWW@@WW
WWW@*WWW+  @WWW*WWW*  #WWW @WWWWWWW @WWW#WWWW@+WWW*  =WWW*WWW#WWWWW* *WWWWW@@WW
WWW@*WWW@  @WWW*WWW*  #WWW += =# += @WWW      +WWWW: =WWW*WWW=  @WWW@      *WWW
WWW@ *WWWWWWWWW*WWW*  #WWW   =WW@   @WWW       :WWWWWWWWW*WWW=   WWW@:WWWWWWWW@
@@@@   +@@@@@@@+@@@+  #WWW          @WWW         :WWWWWWW+W@@=   @@@@:@@@@@@#  

###############################################################################
Ion Fury
Code by Jonathan Strander, Fox Martins, Richard Gobeille, and Evan Ramos
All code as written belongs to Voidpoint and the respective authors.
(c) 2019 Voidpoint, LLC
--------------------------------------------------------------------------------
While we encourage you to experiment, modifications are allowed WITHOUT any
warranty or guarantee of support. Editing these files is AT YOUR OWN RISK, and
we encourage you to make backups.
--------------------------------------------------------------------------------

NOTES:
This file contains the code for the majority of particle and bullet effects seen
in the game, including gore. Some misc effectors have their code wrapped into
this file as well for similarity.
================================================================================
--------------------------------------------------------------------------------
*/
appendevent EVENT_SPAWN
    switch sprite[].picnum
        case A_SMOKE1:
            sizeat 10 10
            ifspawnedby A_SPARK1
                nullop
            else
                cstat 642
            ifrnd 128
                cstator 4
            break
        case A_SPARK1:
            sizeat 10 10
            cstat 130
            seta[].blend 255
            ifrnd 128
                cstator 4
            espawn A_SMOKE1
            seta[RETURN].cstat 32768
            break
        case 1890:
            cstat 32768
            break
        case A_EXPLOSION_FX:
            cstat 32768
            break
        case A_EXPLOSION:
            ifspawnedby P_FLAMER
                cstat 32768
            ifspawnedby P_PUCK_THROWN
                cstat 32768
            ifspawnedby P_PUCK_PLACED
                cstat 32768
            break
        case A_FIRE:
        case A_FIRE2:
            seta[].shade -127
            cstator 2
            seta[].blend 129
            geta .hitag se_hitag
            seta .hitag 0
            break
    endswitch
endevent

spritenoshade A_FIRE
spritenoshade A_FIRE2
spritenopal A_FIRE
spritenopal A_FIRE2

eventloadactor A_EXPLOSION_FX
    cstat 32768
    geta[].xvel se_xvel
    seta[].xvel 0
enda

action EXPLOSION_FRAMES 0 1 1 1 1
actor 1890 1 EXPLOSION_FRAMES // hardcoded for other stuff
    geta[].owner temp
    ife sprite[temp].picnum A_EXPLOSION_RELAY
        nullop
    else
    {
        set temp2 64
        rand temp3 7
        ifrnd 127
            inv temp3
        add temp2 temp3

        espawn A_EXPLOSION
        seta[RETURN].xrepeat temp2
        seta[RETURN].yrepeat temp2
        geta[RETURN].z temp
        shiftl temp2 6
        add temp temp2
        seta[RETURN].z temp
        seta[RETURN].cstat 2
        seta[RETURN].shade -127
        seta[RETURN].blend 129
    }
    killit
enda

eventloadactor A_PARTICLE_SPAWNER
    geta[].hitag se_hitag
    geta[].lotag se_lotag
    geta[].extra se_extra
    geta[].xvel se_xvel
    geta[].zvel se_zvel
    seta[].hitag 0
    seta[].lotag 0
    seta[].xvel 0
    seta[].zvel 0
    geta[].owner tp_owner
    cstator 32768
    geta[].cstat temp
    ifand temp 1
        xor temp 1
    ifand temp 256
        xor temp 256
    seta[].cstat temp
enda

var ps_triggered 0 2
var ps_bubbledist 0 2
appendevent EVENT_SPAWN
    ifactor A_PARTICLE_SPAWNER
        changespritestat THISACTOR STAT_PARTICLESPAWNER
endevent

useractor notenemy A_PARTICLE_SPAWNER
    changespritestat THISACTOR STAT_PARTICLESPAWNER
enda
appendevent EVENT_WORLD
    for temp7 sprofstat STAT_PARTICLESPAWNER
    {
        setu[].vm_sprite temp7
        ifle se_xvel 0
            set ps_triggered 1
        else
        {
            ife activateshit[se_xvel] 1
            {
                ife se_zvel 0
                    xor ps_triggered 1
                else
                    set ps_triggered se_zvel
            }
        }
        ifg ps_triggered 0
        {
            ife counter se_hitag
            {
                rand temp 3
                ifand sprite[].yvel 4
                    set temp 0
                ife temp 0
                {
                    set temp se_extra
                    ifl temp 1
                    {
                        ifand sprite[].yvel 1
                        {
                            espawnvar se_lotag
                           // ifg sprite[].xrepeat 64
                            set temp3 sprite[].xrepeat
                            set temp4 sprite[].yrepeat
                            ife se_lotag A_SMOKE2
                            {
                                clamp temp3 2 192
                                clamp temp4 2 192
                                seta[RETURN].xrepeat temp3
                                seta[RETURN].yrepeat temp4
                                ifand sprite[].yvel 8
                                {
                                    getav[RETURN].se_yvel temp3
                                    or temp3 1
                                    setav[RETURN].se_yvel temp3
                                }
                                ifand sprite[].yvel 16
                                {
                                    getav[RETURN].se_yvel temp3
                                    or temp3 2
                                    setav[RETURN].se_yvel temp3
                                    setav[RETURN].tp_owner tp_owner
                                }
                            }
                            else ife se_lotag A_FIRE_SPARK
                            {
                                sub temp3 64
                                sub temp4 64
                                clamp temp3 1 192
                                clamp temp4 1 192
                                seta[RETURN].xrepeat temp3
                                seta[RETURN].yrepeat temp4
                            }
                            else
                            {
                                seta[RETURN].xrepeat temp3
                                seta[RETURN].yrepeat temp4
                            }
                            ifn sprite[RETURN].statnum 0
                                seta[RETURN].cstat 32768
                            else
                            {
                                set temp3 sprite[].cstat
                                xor temp3 32768
                                seta[RETURN].cstat temp3
                            }
                            seta[RETURN].pal sprite[].pal
                        }
                        else ifand sprite[].yvel 2
                        {
                            espawn A_GENERIC_DEBRIS
                            setav[RETURN].debris_type se_lotag
                            setav[RETURN].particle_force_pal sprite[].pal
                            ifg tp_owner 0
                                setav[RETURN].debris_add_vel tp_owner
                            seta[RETURN].xrepeat 64
                            seta[RETURN].yrepeat 64
                            set temp2 sprite[].xrepeat
                            sub temp2 64
                            ifg temp2 0
                                setav[RETURN].debris_add_size temp2
                            ifand sprite[].yvel 8
                                setav[RETURN].debris_force_qstate 1
                            else ifand sprite[].yvel 16
                                setav[RETURN].debris_force_qstate -1
                            seta[RETURN].cstat 32768
                        }
                        else
                        {
                            espawn A_GENERIC_PARTICLE
                            setav[RETURN].particle_type se_lotag
                            setav[RETURN].particle_force_pal sprite[].pal
                            seta[RETURN].xrepeat 64
                            seta[RETURN].yrepeat 64
                            switch se_lotag
                                case PARTICLE_TYPE_BUBBLE
                                case PARTICLE_TYPE_BUBBLE2
                                    ifg tp_owner 1
                                        setav[RETURN].debris_add_vel tp_owner
                                        ifand sprite[].yvel 32
                                        {
                                            set temp3 tilesizx[sprite.picnum]
                                            mul temp3 sprite.xrepeat
                                            shiftr temp3 2
                                            setav[RETURN].ps_bubbledist temp3
                                        }
                                    break
                            endswitch
                            set temp2 sprite[].xrepeat
                            sub temp2 64
                            ifg temp2 0
                                setav[RETURN].debris_add_size temp2
                        }

                    }
                    else
                    {
                        for itervar range temp
                        {
                            ifand sprite[].yvel 2
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type se_lotag
                                setav[RETURN].particle_force_pal sprite[].pal
                                ifg tp_owner 0
                                    setav[RETURN].debris_add_vel tp_owner
                                seta[RETURN].xrepeat 64
                                seta[RETURN].yrepeat 64
                                set temp2 sprite[].xrepeat
                                sub temp2 64
                                ifg temp2 0
                                    setav[RETURN].debris_add_size temp2
                                ifand sprite[].yvel 8
                                    setav[RETURN].debris_force_qstate 1
                                else ifand sprite[].yvel 16
                                    setav[RETURN].debris_force_qstate -1
                                seta[RETURN].cstat 32768
                            }
                            else ifand sprite[].yvel 1
                            {
                                espawnvar se_lotag
                                set temp3 sprite[].xrepeat
                                set temp4 sprite[].yrepeat
                                ife se_lotag A_SMOKE2
                                {
                                    clamp temp3 2 192
                                    clamp temp4 2 192
                                    seta[RETURN].xrepeat temp3
                                    seta[RETURN].yrepeat temp4
                                    ifand sprite[].yvel 8
                                    {
                                        getav[RETURN].se_yvel temp3
                                        or temp3 1
                                        setav[RETURN].se_yvel temp3
                                    }
                                    ifand sprite[].yvel 16
                                    {
                                        getav[RETURN].se_yvel temp3
                                        or temp3 2
                                        setav[RETURN].se_yvel temp3
                                        setav[RETURN].tp_owner tp_owner
                                    }
                                }
                                else
                                {
                                    seta[RETURN].xrepeat temp3
                                    seta[RETURN].yrepeat temp4
                                }
                                ifn sprite[RETURN].statnum 0
                                    seta[RETURN].cstat 32768
                                else
                                {
                                    set temp3 sprite[].cstat
                                    xor temp3 32768
                                    seta[RETURN].cstat temp3
                                }
                                seta[RETURN].pal sprite[].pal
                            }
                            else
                            {
                                espawn A_GENERIC_PARTICLE
                                setav[RETURN].particle_type se_lotag
                                setav[RETURN].particle_force_pal sprite[].pal
                                seta[RETURN].xrepeat 64
                                seta[RETURN].yrepeat 64
                                switch se_lotag
                                    case PARTICLE_TYPE_BUBBLE
                                    case PARTICLE_TYPE_BUBBLE2
                                        ifg tp_owner 1
                                            setav[RETURN].debris_add_vel tp_owner
                                        ifand sprite[].yvel 32
                                        {
                                            set temp3 tilesizx[sprite.picnum]
                                            mul temp3 sprite.xrepeat
                                            shiftr temp3 2
                                            setav[RETURN].ps_bubbledist temp3
                                        }
                                    break
                                endswitch
                            }
                          //  sub temp 1
                        }
                    }
                }
                set counter 0
            }
            else
                addvar counter 1
            ifg se_zvel 0
                sub ps_triggered 1
        }
    }
endevent

action AC_SMOKEFADE 0 21 1 1 7
spritenoshade A_SMOKE2
spritenopal A_SMOKE2

eventloadactor A_SMOKE2
    sizeat 2 2
    cstat 32768
enda
appendevent EVENT_SPAWN
    ifactor A_SMOKE2
        changespritestat THISACTOR STAT_SMOKE2
endevent
move smokemove 30 0
move smokemove2 20 -10
useractor notenemy A_SMOKE2 0 AC_SMOKEFADE
    changespritestat THISACTOR STAT_SMOKE2
enda
appendevent EVENT_WORLD
    for temp6 sprofstat STAT_SMOKE2
    {
        setu[].vm_sprite temp6
        setu[].vm_player myconnectindex
        dist temp2 THISACTOR player[].i
        setu[].vm_distance temp2
        ifand se_yvel 2
        {
            ifn tp_owner 0
                movesprite THISACTOR 0 0 tp_owner CLIPMASK0 temp2
        }
        set temp7 0
        ife counter 0
        {
            add counter 1
            cstat 642
            ifrnd 127
                cstator 8
            ifrnd 127
                cstator 4
            seta[].shade 0
            ifspritepal 5
                set prop_barrel_type 1
            ifspawnedby P_SMOKE2
                spritepal 62
            else ifspawnedby P_MINIMISSILE
            {
                spritepal 62
                seta[].shade 4
            }
            else ifspawnedby A_SMOKE1
            {
                geta[].ang temp
                add temp 1024
                and temp 2047
                seta[].ang temp
            }
            else ifspawnedby P_DANCINGQUEEN
            {
                spritepal 10
                seta[].shade 0
                sizeat 8 8
            }
            else ifspawnedby A_RAINSPRITE
            {
                spritepal 62
                seta[].shade 10
                sizeat 16 16
            }
            else ifn prop_barrel_type 0
            {
                cstator 32768
                spritepal 5
                ife prop_barrel_type 1
                {
                    rand counter sprite.xrepeat
                    shiftr counter 2
                    inv counter
                }
                else
                    seta .xvel 0
                rand temp 2047
                seta .ang temp
                ssp THISACTOR 0
            }
        }
        seta[].blend 129
        seta[].shade 20
        ifspawnedby A_SMOKE1
        {
            add counter 1
            set temp 16
            add temp counter
            seta[].shade temp
            ife temp 30
                set temp7 1
            getu[].vm_distance temp2
            shiftr temp2 11
            add temp temp2
            seta[].shade temp
            ifg temp 30
                cstator 32768
            else
            {
                geta[].cstat temp2
                ifand temp2 32768
                {
                    xor temp2 32768
                    seta[].cstat temp2
                }
            }
            spritepal 62
            move smokemove2 6
        }
        else ifspawnedby P_DANCINGQUEEN
        {
            add counter 1
            set temp counter
            shiftr temp 1
            seta .xrepeat temp
            seta[].shade temp
            ife temp 30
                set temp7 1
            getu[].vm_distance temp2
            shiftr temp2 11
            add temp temp2
            seta[].shade temp
            ifg temp 30
                cstator 32768
            else
            {
                geta[].cstat temp2
                ifand temp2 32768
                {
                    xor temp2 32768
                    seta[].cstat temp2
                }
            }
            spritepal 10
            seta .blend 255
        }
        else ifspawnedby A_RAINSPRITE
        {
            add counter 1
            set temp 12
            add temp counter
            seta[].shade temp
            ife temp 30
                set temp7 1
            getu[].vm_distance temp2
            shiftr temp2 11
            add temp temp2
            seta[].shade temp
            ifg temp 30
                cstator 32768
            else
            {
                geta[].cstat temp2
                ifand temp2 32768
                {
                    xor temp2 32768
                    seta[].cstat temp2
                }
            }
            spritepal 62
        }
        else ifspawnedby P_GRENADE
        {
            add counter 1
            set temp2 counter
            shiftr temp2 1
            set temp 16
            add temp temp2
            ifg temp 26
                set temp7 1
            seta[].shade temp
        }
        else ifspawnedby P_MINIMISSILE
        {
            add counter 1
            set temp2 counter
            shiftr temp2 1
            set temp 18
            add temp temp2
            ifg temp 32
                set temp7 1
            seta[].shade temp
        }
        else ifspawnedby A_FIREEXT
        {
            add counter 1
            set temp2 counter
            shiftr temp2 1
            set temp 12
            add temp temp2
            ifg temp 32
            {
                seta[].xrepeat 0
                set temp7 1
            }
            seta[].shade temp
        }
        else ifspawnedby P_GIB_MEAT
        {
            add counter 2
            set temp2 counter
            shiftr temp2 1
            set temp 16
            add temp temp2
            ifg temp 32
                set temp7 1
            set temp2 temp
            shiftr temp 1
            seta .xrepeat temp
            seta .yrepeat temp
            add temp2 3
            seta[].shade temp2
            
        }
        else ifspawnedby P_SMOKE2
            move smokemove 3
        else ifn prop_barrel_type 0
        {
            add counter 1
            ife counter 0
                set counter 1
            ifg counter 0
            {
                geta[].cstat temp2
                ifand temp2 32768
                {
                    xor temp2 32768
                    seta[].cstat temp2
                }
            }
            else
                add counter 1
            set temp counter
            shiftr temp 2
            ifl counter 128
                shiftr temp 1
            clamp temp 0 21
            seta .htg_t 2 temp
            geta .htg_t 3 temp3
            seta .htg_t 3 temp
            ife prop_barrel_type 1
            {
                geta .xrepeat temp2
                ifl temp 18
                {
                    sub temp2 1
                    shiftr temp2 1
                }
                else
                    add temp2 1
                clamp temp2 24 255
                seta .xrepeat temp2
                seta .yrepeat temp2
            }
            else ifg counter 4 ifl counter 16
            {
                add counter 1
                geta .xrepeat temp2
                ifl temp 18
                    sub temp2 8
                clamp temp2 18 255
                seta .xrepeat temp2
                seta .yrepeat temp2
            }
            geta .htg_t 2 temp2
            shiftl temp2 1
            ifl counter 16 ifg counter 0
            {
                set temp3 counter
                shiftl temp3 1
                sub temp3 32
                inv temp3
                add temp2 temp3
            }
            clamp temp2 0 127
            seta .shade temp2
            set se_xvel 0
            move smokemove2 6
            ifg counter 1
            {
                rand temp 8
                sub temp 64
                seta .zvel temp
                geta .xvel temp
                ife prop_barrel_type 1
                {
                    add temp 1
                    ifg counter 8
                    {
                        ifg temp 16
                            sub temp 3
                    }
                    else
                    {
                        set temp2 counter
                        sub temp2 48
                        inv temp2
                        ifg counter 2
                            shiftr temp2 1
                        ifg counter 4
                        {
                            shiftr temp2 1
                            ifg counter 7
                                shiftr temp 2
                        }
                        add temp temp2
                    }
                }
                else
                {
                    shiftr temp 1
                    ifg counter 120
                        set temp7 1
                }
                seta .xvel temp
                ssp THISACTOR 0
                ifpdistl 512
                    ifrnd 8
                        addphealth -1
                ifrnd 16
                {
                    for itervar range num_flag32
                    {
                        set temp gameflag32[itervar]
                        ife sprite[temp].sectnum sprite.sectnum
                        {
                            dist temp2 THISACTOR temp
                            ifl temp2 512
                            {
                                switch sprite[temp].picnum
                                    case A_NUKEMUTANT
                                    case A_NUKEMUTANT_GDF
                                    case A_DIOPEDE_HEAD
                                    case A_DIOPEDE_BUTT
                                        changespritestat temp STAT_ACTOR
                                        ife actorvar[temp].enemy_init 0
                                            setav[temp].enemy_init 1
                                        break
                                    default
                                        seta[temp].htextra 2
                                        seta[temp].htpicnum BULLET
                                        changespritestat temp STAT_ACTOR
                                        ife actorvar[temp].enemy_init 0
                                            setav[temp].enemy_init 1
                                        seta[temp].htowner player[].i
                                        break
                                endswitch
                            }
                        }
                    }
                }
            }
        }
        geta[].xrepeat temp
        ifactioncount 11
            nullop
        else
        {
            ifspawnedby P_GRENADE
            {
                add temp 1
                ifl temp 16
                    add temp 1
            }
            else ifspawnedby P_MINIMISSILE
            {
                add temp 1
                ifl temp 16
                    add temp 1
            }
            else
            {
                ifand se_yvel 1
                    add temp 1
                else
                    add temp 2
            }
        }
        clamp temp 0 255
        seta[].xrepeat temp
        seta[].yrepeat temp        
        ifactioncount 21
            set temp7 1
            add se_xvel 1
            ifspawnedby P_DANCINGQUEEN
                set se_xvel 2
            ife se_xvel 2
            {
                set se_xvel 0
                geta[].htg_t 2 temp2
                add temp2 1
                geta[].htg_t 3 temp3
                add temp3 1
                ifg temp3 30
                    set temp3 0
                seta[].htg_t 3 temp3
                seta[].htg_t 2 temp2
            }
        ife temp7 1
        {
            seta[].xrepeat 0
            changespritestat THISACTOR STAT_ACTOR
        }
    }
endevent

action AC_LIGHTNING_SPIN 0 8 1 1 1
useractor notenemy A_LIGHTNINGBALL
    ifaction 0
        action AC_LIGHTNING_SPIN
    set temp5 0
    ifspawnedby P_SMOKE2
    {
        sizeat 24 24
        rand temp 7
        seta[].htg_t 3 temp
        ifcount 8
            killit
    }
    else
    {
        geta[].owner temp3
        geta[temp3].htowner temp3
        geta[temp3].picnum temp3
        switch temp3
            case A_CULTIST
            case A_SHOTGUNNER
            case A_GREATER
            case A_MECHBOSS_BOTTOM
            case A_MECHBOSS_TOP
            case A_SHOCKCANISTER_BROKE
            case A_SHOCKCANISTER
                ife temp3 A_SHOCKCANISTER_BROKE
                    set temp5 1
                ife temp3 A_SHOCKCANISTER
                    set temp5 1
                ife counter 0
                {
                    set counter 1
                    sizeat 48 48
                    geta[].ang temp
                    add temp 1024
                    and temp 2047
                    seta[].ang temp
                }
                seta[].xvel 1
                ssp THISACTOR 0
                geta[].xrepeat temp
                add temp 4
                seta[].xrepeat temp
                seta[].yrepeat temp
                rand temp 7
                seta[].htg_t 3 temp
                ifcount 7
                    killit
                    break
            case A_EXPLOSION
                set temp5 1
                ife counter 0
                {
                    set counter 1
                    sizeat 6 6
                    geta[].ang temp
                    add temp 1024
                    and temp 2047
                    seta[].ang temp
                    seta[].shade -127
                    set face_target player[].i
                    state face_actor
                    seta[].ang face_return
                    seta[].xvel 3
                    ssp THISACTOR 0
                }
                seta[].xvel 1
                ssp THISACTOR 0
                geta[].xrepeat temp
                add temp 2
                seta[].xrepeat temp
                seta[].yrepeat temp
                geta[].shade temp
                add temp 20
                seta[].shade temp
                rand temp 7
                seta[].htg_t 3 temp
                spritepal 1
                ifcount 7
                    killit
                    break
            default
                sizeat 32 32
                break
        endswitch
    }

    seta[].blend 129
    ifspawnedby A_EXPLOSION
        nullop
    else
        seta[].shade 0
    cstat 130
    ife temp5 1
    {
        ifrnd 127
            cstator 4
        ifrnd 127
            cstator 8
    }
enda

defstate fire_code
    ifrnd 28
    {
        ifand se_hitag 1
            ifpdistl 9728
                espawn A_FIRE_SPARK
        ifpdistl 1536
        {
            ifp palive
            {
                getu[].vm_distance temp
                geta[].xrepeat temp2
                mul temp2 14
                ifl sprite[].xrepeat 28
                    clamp temp2 512 1536
                else
                    clamp temp2 640 1536
                ifl temp temp2
                {
                    ifcansee
                    {
                        soundonce S_SHELLY_BREATH2
                        addphealth -1
                    }
                }
            }
        }
    }
    ifand sprite[].cstat 32768
    {
        geta[].cstat temp
        xor temp 32768
        seta[].cstat temp
    }
ends
useractor notenemy A_FIRE
    state fire_code
enda
useractor notenemy A_FIRE2
    state fire_code
enda

defineprojectile P_SMOKE2 PROJ_WORKSLIKE 36930 // 22734
defineprojectile P_SMOKE2 PROJ_SPAWNS -1
defineprojectile P_SMOKE2 PROJ_SXREPEAT 4
defineprojectile P_SMOKE2 PROJ_SYREPEAT 4
defineprojectile P_SMOKE2 PROJ_TXREPEAT 20
defineprojectile P_SMOKE2 PROJ_TYREPEAT 20
defineprojectile P_SMOKE2 PROJ_XREPEAT 1
defineprojectile P_SMOKE2 PROJ_YREPEAT 1
defineprojectile P_SMOKE2 PROJ_EXTRA 0
defineprojectile P_SMOKE2 PROJ_EXTRA_RAND 0
defineprojectile P_SMOKE2 PROJ_HITRADIUS 0
defineprojectile P_SMOKE2 PROJ_OFFSET 14354
defineprojectile P_SMOKE2 PROJ_PAL 59
defineprojectile P_SMOKE2 PROJ_SHADE 0
defineprojectile P_SMOKE2 PROJ_CSTAT 32768
defineprojectile P_SMOKE2 PROJ_TRAIL A_SMOKE2
defineprojectile P_SMOKE2 PROJ_TNUM 0
defineprojectile P_SMOKE2 PROJ_RANGE 5
defineprojectile P_SMOKE2 PROJ_BSOUND -1
defineprojectile P_SMOKE2 PROJ_BOUNCES 1
defineprojectile P_SMOKE2 PROJ_VEL 512
defineprojectile P_SMOKE2 PROJ_DROP 0

defineprojectile P_EXPLOSION_SPARK PROJ_WORKSLIKE 39054 // 22734
defineprojectile P_EXPLOSION_SPARK PROJ_SPAWNS -1
defineprojectile P_EXPLOSION_SPARK PROJ_TXREPEAT 4
defineprojectile P_EXPLOSION_SPARK PROJ_TYREPEAT 4
defineprojectile P_EXPLOSION_SPARK PROJ_XREPEAT 1
defineprojectile P_EXPLOSION_SPARK PROJ_YREPEAT 1
defineprojectile P_EXPLOSION_SPARK PROJ_EXTRA 0
defineprojectile P_EXPLOSION_SPARK PROJ_EXTRA_RAND 0
defineprojectile P_EXPLOSION_SPARK PROJ_HITRADIUS 0
defineprojectile P_EXPLOSION_SPARK PROJ_OFFSET 14354
defineprojectile P_EXPLOSION_SPARK PROJ_PAL 0
defineprojectile P_EXPLOSION_SPARK PROJ_SHADE 0
defineprojectile P_EXPLOSION_SPARK PROJ_CSTAT 32768
defineprojectile P_EXPLOSION_SPARK PROJ_TRAIL A_EXPLOSION_SPARK
defineprojectile P_EXPLOSION_SPARK PROJ_TNUM 0
defineprojectile P_EXPLOSION_SPARK PROJ_BSOUND -1
defineprojectile P_EXPLOSION_SPARK PROJ_BOUNCES 1
defineprojectile P_EXPLOSION_SPARK PROJ_VEL 128
defineprojectile P_EXPLOSION_SPARK PROJ_DROP -256

action AC_BALLBLAH 1 13 1 1 2

appendevent EVENT_EGS
    ifactor A_EXPLOSION_SPARK
    {
        ife sprite[sprite.owner].picnum P_EXPLOSION_SPARK
         seta .pal sprite[sprite.owner].pal
    }
endevent
spritenoshade A_EXPLOSION_SPARK
spritenopal A_EXPLOSION_SPARK
useractor notenemy A_EXPLOSION_SPARK 0 AC_BALLBLAH
    geta .xrepeat temp
    sub temp 1
    clamp temp 0 255
    seta .xrepeat temp
    seta .yrepeat temp
    seta .shade 10

    cstat 130
    seta .blend 255
    ifactioncount 13
        killit
enda



action AC_EXPLOSIONBASE 0 30 1 1 1
action AC_EXPLOSIONSKULL 1503 32 1 1 1
action AC_EXPLOSIONFLAME 254 1 1 1 1
action AC_EXPLOSIONSKULL2 6271 9 5 1 1
action AC_EXPLOSIONPLASMA 1559 16 1 1 1
action AC_EXPLOSION_ALT -34 14 1 1 1

spritenoshade A_EXPLOSION
spritenopal A_EXPLOSION



defstate lam_explosion
    ifaction AC_EXPLOSIONBASE
    {
		rand temp2 6
        add temp2 S_EXPL_MD001
        soundvar temp2   
        action AC_EXPLOSION_ALT
        seta .shade -8
    }
    ifaction AC_EXPLOSION_ALT
    {
        cstator 128
        geta .shade temp
        add temp 2
        seta .shade temp
        seta[].blend 255
        spritepal 62
        add counter3 1
        ifl counter3 2
        {
            set temp counter3
            shiftr temp 1
            seta .htg_t 2 temp
            seta .htg_t 3 temp
        }
        else ifg counter3 7 ifl counter 12
        {
            set temp counter3
            sub temp 2
            seta .htg_t 2 temp
            seta .htg_t 3 temp
        }
        ifactioncount 14
            killit
    }
ends

actor A_EXPLOSION 0 AC_EXPLOSIONBASE
    ifspawnedby P_BOWLINGBOMB
    {
        ifaction AC_EXPLOSIONBASE
        {
            action AC_EXPLOSIONSKULL
            geta[].z temp
            add temp 2048
            seta[].z temp
            cstat 2
        }
        ifspritepal 9
          spritepal 1
        else
        ifspritepal 1
          spritepal 9
    }
    else ifspawnedby A_SMOKE1
    {
        ifspritepal PAL_PLASMA_BOLT ifaction AC_EXPLOSIONBASE
        {
            action AC_EXPLOSIONPLASMA
            spritepal 9
            seta[].blend 129
            geta[].xrepeat temp
            add temp 1
            shiftl temp 2
            seta[].xrepeat temp
            seta[].yrepeat temp
            seta[].shade 0
            
            ifrnd 127
                cstator 8
            ifrnd 127
                cstator 4
            cstator 128
            espawn A_LIGHTNINGBALL
            seta[RETURN].pal 1
        }
    }
    else ifspawnedby P_FLAMINGSKULL
    {
        set explosion_silent 1
        set explosion_nosmoke 1
        sizeat 32 28
        ifaction AC_EXPLOSIONSKULL2
            nullop
        else
            action AC_EXPLOSIONSKULL2
        ifactioncount 9
            killit
    }
    else ifspawnedby A_DRONE
    {
        ifspritepal 10
        {
            action AC_EXPLOSIONPLASMA
            spritepal 0
            seta[].blend 129
            seta .shade -5
            cstat 2
        }
        ifaction AC_EXPLOSIONPLASMA
        {
            geta .xrepeat temp
            add temp 2
            clamp temp 1 255
            seta .xrepeat temp
            seta .yrepeat temp
        }
    }
    else ifspawnedby P_PUCK_THROWN
        state lam_explosion
    else ifspawnedby P_PUCK_PLACED
        state lam_explosion
    else ifg prop_barrel_type 0 ifl prop_barrel_type 3
    {
        state lam_explosion
        spritepal 5
    }
    geta[].htflags temp
    or temp 2048
    seta[].htflags temp
	
	ifspawnedby P_FLAMER
		nullop
	else
		set db_once 1
	
    ife sprite[].htg_t 2 1 ife db_once 1 // ifactioncount
    {
        ife explosion_silent 0
        {
            ifaction AC_EXPLOSIONPLASMA
                nullop
            else
                flash
        }
        ifspawnedby P_FLAMINGSKULL
            nullop
        else ifge sprite.xrepeat 32
        {
            ifn explosion_silent 2 ife explosion_nospark 0
            {
                rand temp 9
                add temp 1
                set temp3 2048
                ifle temp 2
                    rand temp3 1023
                else
                    div temp3 temp
                
                set temp4 tilesizy[sprite.picnum]
                shiftl temp4 2
                mul temp4 sprite.yrepeat
                shiftr temp4 1
                set temp5 sprite.z
                sub temp5 temp4
                getceilzofslope sprite.sectnum sprite.x sprite.y temp2
                ifl temp5 temp2
                    set temp5 temp2
                ifspawnedby P_DSLAM_THROWN
                    add temp 2
                else ifspawnedby P_DSLAM_PLACED
                    add temp 2
                for itervar range temp
                {
                    rand temp2 -8096
                    sub temp2 1024
                    ezshoot temp2 P_EXPLOSION_SPARK
                    set temp4 temp3
                    mul temp4 itervar
                    add temp4 sprite.ang
                    seta[RETURN].ang temp4
                    seta[RETURN].z temp5
                    seta[RETURN].pal sprite.pal
                    ifspawnedby P_BOWLINGBOMB
                          ifspritepal 1
                            seta[RETURN].pal 9
                }
            }
        }
        geta[].xrepeat temp
        shiftr temp 2
        getu[].vm_distance temp2
        shiftr temp2 12
        ifg temp2 1
            div temp temp2
       /* redefinequote 11 %ld %ld
        qsprintf 11 11 shakeitbaby temp
        quote 11 */
        ifaction AC_EXPLOSIONPLASMA
            nullop
        else ifg temp 1 ifn prop_barrel_type 2
        {
            add shakeitbaby temp
            clamp shakeitbaby 0 30
        }
        espawn A_SOUND_EMITTER
        seta[RETURN].extra SE_DIST_EXPLOSION // read distance
        seta[RETURN].xrepeat 64
        seta[RETURN].yrepeat 64
        seta[RETURN].yrepeat 32768
        geta[].ang temp

        ifspawnedby A_SMOKE1
            nullop
        else ifl sprite[].xrepeat 4
        {
            espawn A_SMOKE2
            rand temp3 512
            seta[RETURN].xvel temp3
            rand temp5 2047
            seta[RETURN].ang temp5
            ssp RETURN 0
        }
        else ifspawnedby P_BOMBETTE
        {
            espawn A_SMOKE2
            rand temp3 512
            seta[RETURN].xvel temp3
            rand temp5 2047
            seta[RETURN].ang temp5
            ssp RETURN 0
        }
        else
        {
            ifrnd 127 // hack to introduce additonal randomization seeding
                seta[].z sprite[].z
            switch explosion_silent
                case 0
                case 2
                    ifg sprite[].xrepeat 48
                    {
                        rand temp2 3
                        add temp2 S_EXPL_LG001
                        soundvar temp2
                    }
                    else ifl sprite[].xrepeat 14
                    {
                        rand temp2 4
                        add temp2 S_EXPL_SM001
                        soundvar temp2
                    }
                    else
                    {
                        rand temp2 6
                        add temp2 S_EXPL_MD001
                        soundvar temp2
                    }
                    ife explosion_silent 2
                        killit
                    break
            endswitch

			ifspawnedby P_GRENADE
            {
                rand temp2 6
                add temp2 S_EXPL_MD001
                soundvar temp2
            }

            geta[].cstat temp2
            ifand temp2 32768
                xor temp2 32768
            seta[].cstat temp2
            rand temp2 3
            add temp2 2
            set temp3 0
            ifspawnedby P_MINIMISSILE
            {
                shiftr temp2 2
                clamp temp2 1 2
            }
            ife explosion_nosmoke 1
                set temp2 0

            for temp3 range temp2
            {
                rand temp5 2047
                seta[].ang temp5
                rand temp4 6143
                ifrnd 127
                    inv temp4
                else iffloordistl 4
                    inv temp4
                ezshoot temp4 P_SMOKE2
                geta[].xrepeat temp4
                shiftr temp4 1
                clamp temp4 1 80
                ifinwater
                {
                    ifand temp3 1
                    {
                        setthisprojectile[RETURN].trail A_GENERIC_PARTICLE
                        setthisprojectile[RETURN].txrepeat 119
                        setthisprojectile[RETURN].tnum 2
                    }
                    else
                        setthisprojectile[RETURN].txrepeat temp4
                }
                else
                    setthisprojectile[RETURN].txrepeat temp4
                mul temp4 26
                seta[RETURN].xvel temp4
                shiftl temp4 3
                ifl sprite[RETURN].zvel -temp4
                    seta[RETURN].zvel -temp4
                else ifg sprite[RETURN].zvel temp4
                    seta[RETURN].zvel temp4
                geta[].yrepeat temp4
                shiftr temp4 1
                clamp temp4 1 80
                setthisprojectile[RETURN].tyrepeat temp4

                ifaction AC_EXPLOSIONSKULL
                {
                    geta[RETURN].z temp5
                    geta[].yrepeat temp4
                    shiftl temp4 7
                    add temp4 2048
                    sub temp5 temp4
                    seta[RETURN].z temp5
                }
                else
                {
                    geta[RETURN].z temp5
                    geta[].yrepeat temp4
                    shiftl temp4 8
                    sub temp5 temp4
                    seta[RETURN].z temp5
                }
                geta[RETURN].z temp5
                add temp5 smoke_offset
                seta[RETURN].z temp5
                ifand sprite[].cstat 128
                {
                    geta[].z temp5
                    geta[].yrepeat temp4
                    mul temp4 48
                    add temp5 temp4
                    seta[RETURN].z temp5
                    ifn smoke_offset 0
                    {
                        add temp5 smoke_offset
                        seta[RETURN].z temp5
                    }
                }
            }
        }
        seta[].ang temp
    }
    ifspawnedby P_FLAMER
    {
        ifaction AC_EXPLOSIONBASE
            action AC_EXPLOSIONFLAME
        seta[].blend 129
        seta[].shade 2
        ife counter 0
        {
            rand temp 8
            ifrnd 127
                inv temp
            add temp sprite[].x
            seta[].x temp

            rand temp 8
            ifrnd 127
                inv temp
            add temp sprite[].y
            seta[].y temp

            rand temp 128
            ifrnd 127
                inv temp
            add temp sprite[].z
            seta[].z temp
        }
        ife sprite[].xrepeat 127 ife counter 0
        {
            sizeat 2 2
            ldist temp player[].i THISACTOR
            shiftr temp 7
            mul temp sprite[].xrepeat
            seta[].xrepeat temp
            seta[].yrepeat temp
            add counter 1
            findnearactor A_EXPLOSION 256 temp
            ifn temp -1
                killit

        }
        else ife counter 0
        {
            sizeat 2 2
            ldist temp player[].i THISACTOR
            div temp 96
            mul temp sprite[].xrepeat
            seta[].xrepeat temp
            seta[].yrepeat temp
            seta[].cstat 642
            set counter 10

            rand temp 64
            ifrnd 127
                inv temp
            add temp sprite[].x
            seta[].x temp

            rand temp 64
            ifrnd 127
                inv temp
            add temp sprite[].y
            seta[].y temp

            rand temp 64
            ifrnd 127
                inv temp
            add temp sprite[].z
            seta[].z temp
        }

        add counter 1

        ifpdistl 512 ifl counter 10
            killit
        else
            seta[].cstat 642
        ifactioncount 6
        {
            fall
            seta[].zvel sprite[].yrepeat
        }
        else iffloordistl 1
            nullop
        else
        {
            geta[].z temp2
            add temp2 1024
            geta[].yrepeat temp
            shiftl temp 7
            ifl temp 1024
                set temp 1024
            sub temp2 temp
            seta[].z temp2
        }
        ifactioncount 12
            killit

    }
    else ifspawnedby P_BOMBETTE
    {
        ife counter 0
        {
            rand temp 2
            add temp S_BOMBETTE_EXP1
            soundvar temp
            add counter 1
            rand temp2 4
			add temp2 S_EXPL_SM001
			soundvar temp2
        }
    }
    else ifspawnedby A_FIREEXT
        cstat 32768
    else ifspawnedby P_FLAMINGSKULL
    {
       // spritepal 0
        geta[].htg_t 2 temp
        ifg temp 1 ifl temp 10
        {
            seta[].shade 15
            ifrnd 127
                cstator 4
        }
        cstator 2
        seta[].blend 129
    }
    else
    {
        ifspawnedby A_EXPLOSION_FX
            cstator 128
        cstator 2
        seta[].blend 129
    }
    ifaction AC_EXPLOSIONSKULL
    {
        ifactioncount 32
            killit
    }
    else ifaction AC_EXPLOSIONPLASMA
    {
        seta[].blend 129
        geta[].xrepeat temp
        add temp 2
        seta[].xrepeat temp
        seta[].yrepeat temp
        geta[].shade temp
        add temp 2
        seta[].shade temp
        ifactioncount 16
            killit
    }
    else
        ifactioncount 30
            killit
enda

actor A_EXPLOSION_BOTTOM 0
    killit
enda


action AC_SPARK1BASE 0 7 1 1 1
var bulletspark_id
var bullet_owner -1 0
var bullet_hole_id -1 2
appendevent EVENT_EGS
    switch sprite.picnum
        case A_SPARK1
        case A_BULLETHOLE
            geta .owner tp_owner
            ifactor A_SPARK1
                set bullet_owner THISACTOR
            ifactor A_BULLETHOLE
            {
                ifn tp_owner -1
                    set queued 1
                ifn bullet_owner -1
                    setav[bullet_owner].bullet_hole_id THISACTOR
                set bullet_owner -1
            }
            break
    endswitch
endevent
actor A_SPARK1 10 AC_SPARK1BASE
    ife sprite.htg_t 2 1
    {
        ifinwater
        {
            rand temp2 1
            add temp2 1
            for temp range temp2
            {
                espawn A_GENERIC_PARTICLE
                seta[RETURN].xrepeat 119
                seta[RETURN].cstat 32768
                setav[RETURN].debris_add_vel 1536
            }
        }
        espawn A_SOUND_EMITTER
        seta[RETURN].extra SE_DIST_BULLET // read distance
        seta[RETURN].xrepeat 64
        seta[RETURN].yrepeat 64
        seta[RETURN].cstat 32768

        espawn A_GENERIC_PARTICLE
        seta[RETURN].xrepeat 127
        set bulletspark_id RETURN

        // Move of this series of code relies on a hack assuming that A_BULLETHOLE
        // will exist within a frame or so and we can instantly swap it out for
        // new decals and perform new behaviors.

        geta .htg_t 6 temp // walls
        ifn temp -1
        {
            getw[temp].cstat temp2
            ifand temp2 2   // check for "split" texture walls
            {
                getw[temp].nextsector temp2
                ifn temp2 -1
                {
                    ifl sector[temp2].floorz sprite[].z // if z < floor we probably hit the upper texture
                        getw[temp].nextwall temp
                }
            }
            getw[temp].picnum surface_type
            state get_surface_type

            // this codeblock determines whether or not we hit a maskwall
            // bulletholes won't spawn on masked sectors and we can fix that
            // by flagging them and this allows us to spawn things nicely

            set temp2 0
            ifand wall[temp].cstat 16
                set temp2 1
            ifand wall[temp].cstat 32
                set temp2 1
            ife temp2 1 // if this wall has a maskwall
            {
                // this trick lets us determine if we're in between the ceiling and floor
                // and should be in the masked area
                getw[temp].nextsector temp3
                ifn temp3 -1
                {
                    ifl sprite[].z sector[temp3].floorz ifg sprite[].z sector[temp3].ceilingz
                    {
                        getw[temp].overpicnum surface_type // get the masked texture if so
                        state get_surface_type
                        switch wall[temp].overpicnum
                            case 6440
                            case 6465
                            case 6466
                            case 6467
                            case 6532
                            case 6534
                            case 7610
                            case 7948
                            case 8280
                            case 8281
                            case 8282
                                set temp2 0
                                break
                        endswitch
                    }
                }
            }

            ifn surface_type 0
            {
                set temp3 0 // we're about to recycle temp2 for a bunch of other stuff so
                ife temp2 1 // save its flagged value so we can forcefully spawn a bullethole/decal
                    set temp3 1

                set temp2 0 // reset this flag

                // water/underwater sectors don't normally spawn a decal on walls
                // so let's flag it and forcefully spawn one
                ife sector[].lotag 1
                    set temp2 1
                else ife sector[].lotag 2
                    set temp2 1
                ife temp3 1
                    set temp2 1
                geta[].owner temp3
                geta[].htowner temp3
                geta[temp3].owner temp3
                ife sprite[temp3].picnum A_CULTIST
                    set temp2 1
                else ife sprite[temp3].picnum A_SHOTGUNNER
                    set temp2 1
				else ife sprite[temp3].picnum AM_EXODUDE
					set temp2 1
                ife temp2 1
                {
                    eqspawn A_BULLETHOLE
                    setav[RETURN].tp_owner tp_owner
                    setav[RETURN].queued 1
                    set bullet_hole_id RETURN
                    set temp2 RETURN
                    seta[temp2].xrepeat 4
                    seta[temp2].yrepeat 4

                    // line up the bullethole with the wall
                    getw[temp].x temp4
                    getw[temp].point2 temp3
                    getw[temp3].x temp5
                    sub temp4 temp5

                    getw[temp].y temp5
                    getw[temp].point2 temp3
                    getw[temp3].y temp6
                    sub temp5 temp6

                    getangle temp6 temp4 temp5

                    add temp6 1536
                    and temp6 2047
                    seta[temp2].ang temp6

                    geta[temp2].cstat temp3
                    ifand temp3 32
                        sub temp3 32
                    set temp3 16
                    ifrnd 64
                        or temp3 4
                    ifrnd 64
                        or temp3 8

                    // this dumb hack prevents displaying
                    // in unwanted places by enemy fire
                    seta[].sectnum sprite[].sectnum
                    geta[].sectnum temp4
                    set temp5 tainted[temp4]
                    ife temp5 1
                        or temp3 32768

                    getw[temp].nextsector temp4
                    ifn temp4 -1
                    {
                        set temp5 tainted[temp4]
                        ife temp5 1
                            or temp3 32768
                    }
                    getw[temp].nextwall temp4
                    ifn temp4 -1
                    {
                        getw[temp4].nextsector temp4
                        ifn temp4 -1
                        {
                            set temp5 tainted[temp4]
                            ife temp5 1
                                or temp3 32768
                        }
                    }
                    seta[temp2].cstat temp3
                }

                set temp2 bullet_hole_id
                ifn temp2 -1
                {
                    getav[temp2].tp_owner temp3
                    ife temp3 tp_owner ife sprite[temp2].picnum A_BULLETHOLE
                    {
                        geta[temp2].cstat temp3
                        ifand sector[].ceilingstat 1
                            set temp5 2
                        else ifand sector[].floorstat 1
                            set temp5 2
                        getw[temp].nextsector temp4
                        ifn temp4 -1
                        {
                            ife temp5 2
                            {
                                set temp5 0
                                ifand sector[temp4].ceilingstat 1
                                    set temp5 1
                                else ifand sector[temp4].floorstat 1
                                    set temp5 2
                                ifn temp5 0
                                {
                                    ife temp5 1
                                    {
                                        ifl sprite[].z sector[temp4].ceilingz
                                            or temp3 32768
                                    }
                                    else ife temp5 2
                                    {
                                        ifg sprite[].z sector[temp4].floorz
                                            or temp3 32768
                                    }
                                    else ife sector[temp4].floorz sector[temp4].ceilingz
                                        or temp3 32768
                                    seta[temp2].cstat temp3
                                    seta[temp2].picnum A_BULLETHOLE_METAL
                                    ifand temp3 32768
                                    {
                                        seta[temp2].cstat temp3
                                        seta[temp2].picnum A_BULLETHOLE_METAL
                                        set temp2 -1
                                        killit
                                    }
                                }
                            }
                        }
                        rand temp4 3
                        add temp4 4
                        seta[temp2].xrepeat temp4
                        seta[temp2].yrepeat temp4
                        switch surface_type
                            case SURFACE_STONE
                                seta[temp2].picnum A_BULLETHOLE_STONE
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_STONE
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_TILE
                                seta[temp2].picnum A_BULLETHOLE_TILE
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_ROCK
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_METAL
                                seta[temp2].picnum A_BULLETHOLE_METAL
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_METAL
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_GLASS
                                seta[temp2].picnum A_BULLETHOLE_GLASS
                                seta[temp2].blend 129
                                geta[temp2].cstat temp3
                                or temp3 514
                                seta[temp2].cstat temp3
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GLASS
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_WOOD
                                seta[temp2].picnum A_BULLETHOLE_WOOD
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_WOOD
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_WATER
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 125
                                setav[bulletspark_id].particle_force_pal 7
                                ifn wall[temp].pal 0
                                {
                                    setav[RETURN].particle_force_pal wall[temp].pal
                                    ife wall[temp].pal 16
                                        setav[bulletspark_id].particle_force_pal 5
                                    else
                                        setav[bulletspark_id].particle_force_pal wall[temp].pal
                                }
                                break
                            case SURFACE_SLIME
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 125
                                setav[bulletspark_id].particle_force_pal 5
                                ifn wall[temp].pal 0
                                {
                                    setav[RETURN].particle_force_pal wall[temp].pal
                                    ife wall[temp].pal 16
                                        setav[bulletspark_id].particle_force_pal 5
                                    else
                                        setav[bulletspark_id].particle_force_pal wall[temp].pal
                                }
                                else
                                    setav[RETURN].particle_force_pal 5
                                break
                            case SURFACE_GRASS
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GRASS
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                seta[temp2].cstat 32768
                                setav[bulletspark_id].particle_force_pal 2
                                setav[bulletspark_id].particle_force_shade 20
                                break
                            case SURFACE_FABRIC
                                seta[temp2].picnum A_BULLETHOLE_FABRIC
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_FABRIC
                                    seta[RETURN].pal wall[temp].pal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_PLASTIC
                                seta[temp2].picnum A_BULLETHOLE_STONE
                                seta[temp2].pal 62
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_PLASTIC
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_LIGHT
                                seta[temp2].picnum A_BULLETHOLE_GLASS
                                seta[temp2].blend 129
                                geta[temp2].cstat temp3
                                or temp3 514
                                seta[temp2].cstat temp3
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GLASS
                                    seta[RETURN].pal wall[temp].pal
                                    setav[RETURN].particle_force_shade 5
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 123
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 122
                                seta[RETURN].pal wall[temp].pal
                                seta[RETURN].ang sprite[temp2].ang
                                break
                            case SURFACE_ELECTRICAL
                                seta[temp2].picnum A_BULLETHOLE_METAL
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 123
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 122
                                seta[RETURN].pal wall[temp].pal
                                seta[RETURN].ang sprite[temp2].ang
                                break
                        endswitch
                        geta[temp2].cstat temp3
                        or temp3 64
                        or temp3 128
                        geta[].sectnum temp4
                        set temp5 tainted[temp4]
                        ife temp5 1
                            or temp3 32768

                        getw[temp].nextsector temp4
                        ifn temp4 -1
                        {
                            set temp5 tainted[temp4]
                            ife temp5 1
                                or temp3 32768
                        }
                        seta[temp2].cstat temp3
                        seta[temp2].shade wall[temp].shade
                    }
                }

            }
        }
        else
        {
            geta[].htg_t 8 temp // EXPERIMENTAL AS FUCK .. sprites
            ifn temp -1
            {
                geta[temp].picnum surface_type
                state get_surface_type
                set temp2 0
                switch sprite[temp].picnum
                    case 8280
                    case 8281
                    case 8282
                        set temp2 1
                        break
                endswitch
                set temp7 0
                ife sprite[temp].statnum 0
                    set temp7 1
                else
                {
                    switch surface_type
                        case SURFACE_GRASS
                        case SURFACE_WATER
                        case SURFACE_SLIME
                            set temp7 1
                            break
                   endswitch
                }
                ifn surface_type 0 ifn surface_type SURFACE_FLESH ife temp7 1 ife temp2 0
                {
                    eqspawn A_BULLETHOLE
                    setav[RETURN].queued 1
                    set temp2 RETURN
                    geta[temp].cstat temp3
                    ifand temp3 1
                        sub temp3 1
                    ifrnd 64
                        or temp3 4
                    ifrnd 64
                        or temp3 8
                    seta[temp2].cstat temp3
                    rand temp4 3
                    add temp4 4
                    seta[temp2].xrepeat temp4
                    seta[temp2].yrepeat temp4

                    seta[temp2].ang sprite[temp].ang

                    switch surface_type
                        case SURFACE_STONE
                            seta[temp2].picnum A_BULLETHOLE_STONE
                            break
                        case SURFACE_TILE
                            seta[temp2].picnum A_BULLETHOLE_TILE
                            break
                        case SURFACE_METAL
                            seta[temp2].picnum A_BULLETHOLE_METAL
                            break
                        case SURFACE_GLASS
                            seta[temp2].picnum A_BULLETHOLE_GLASS
                            seta[temp2].blend 129
                            geta[temp2].cstat temp3
                            or temp3 514
                            seta[temp2].cstat temp3
                            rand temp3 1
                            add temp3 1
                            for itervar range temp3
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_GLASS
                                seta[RETURN].pal wall[temp].pal
                                setav[RETURN].particle_force_shade 5
                                geta[].ang temp4
                                add temp4 1024
                                and temp4 2047
                                seta[RETURN].ang temp4
                            }
                            break
                        case SURFACE_WOOD
                            seta[temp2].picnum A_BULLETHOLE_WOOD
                            break
                        case SURFACE_WATER
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            seta[temp2].cstat 32768
                            ifand sprite[temp].cstat 32
                            {
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 124
                                setav[bulletspark_id].particle_force_pal 7
                                ifn sprite[temp].pal 0
                                {
                                    setav[RETURN].particle_force_pal sprite[temp].pal
                                    ife sprite[temp].pal 16
                                        setav[bulletspark_id].particle_force_pal 5
                                    else
                                        setav[bulletspark_id].particle_force_pal sprite[temp].pal
                                }
                            }
                            else
                            {
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 125
                                setav[bulletspark_id].particle_force_pal 7
                                ifn sprite[temp].pal 0
                                {
                                    setav[RETURN].particle_force_pal sprite[temp].pal
                                    ife sprite[temp].pal 16
                                        setav[bulletspark_id].particle_force_pal 5
                                    else
                                        setav[bulletspark_id].particle_force_pal sprite[temp].pal
                                }
                            }
                            break
                        case SURFACE_SLIME
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            seta[temp2].cstat 32768
                            ifand sprite[temp].cstat 32
                            {
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 124
                                setav[bulletspark_id].particle_force_pal 5
                                ifn sprite[temp].pal 0
                                {
                                    setav[RETURN].particle_force_pal sprite[temp].pal
                                    ife sprite[temp].pal 16
                                        setav[bulletspark_id].particle_force_pal 5
                                    else
                                        setav[bulletspark_id].particle_force_pal sprite[temp].pal
                                }
                                else
                                    setav[RETURN].particle_force_pal 5
                            }
                            else
                            {
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 125
                                setav[bulletspark_id].particle_force_pal 5
                                ifn sprite[temp].pal 0
                                {
                                    setav[RETURN].particle_force_pal sprite[temp].pal
                                    ife sprite[temp].pal 16
                                        setav[bulletspark_id].particle_force_pal 5
                                    else
                                        setav[bulletspark_id].particle_force_pal sprite[temp].pal
                                }
                                else
                                    setav[RETURN].particle_force_pal 5
                            }
                            break
                        case SURFACE_GRASS
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_GRASS
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            seta[temp2].cstat 32768
                            setav[bulletspark_id].particle_force_pal 2
                            setav[bulletspark_id].particle_force_shade 20
                            break
                        case SURFACE_FABRIC
                            seta[temp2].picnum A_BULLETHOLE_FABRIC
                            break
                        case SURFACE_PLASTIC
                            seta[temp2].picnum A_BULLETHOLE_STONE
                            seta[temp2].pal 62
                            break
                        case SURFACE_LIGHT
                            seta[temp2].picnum A_BULLETHOLE_GLASS
                            seta[temp2].blend 129
                            geta[temp2].cstat temp3
                            ifand sprite[temp].cstat 48
                                nullop
                            else
                                or temp3 32768
                            or temp3 514
                            seta[temp2].cstat temp3
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 123
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 120
                            seta[RETURN].pal sprite[temp].pal
                            rand temp3 1
                            add temp3 1
                            for itervar range temp3
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_GLASS
                                seta[RETURN].pal wall[temp].pal
                                setav[RETURN].particle_force_shade 5
                                geta[].ang temp4
                                add temp4 1024
                                and temp4 2047
                                seta[RETURN].ang temp4
                            }
                            break
                        case SURFACE_ELECTRICAL
                            seta[temp2].picnum A_BULLETHOLE_METAL
                            seta[temp2].cstat 32768
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 123
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 120
                            seta[RETURN].pal sprite[temp].pal
                            break
                    endswitch
                    geta[temp2].cstat temp3
                    ifand temp3 16
                        or temp3 128
                    seta[temp2].cstat temp3
                    ifand temp3 48
                        nullop
                    else
                        seta[temp2].cstat 32768
                    seta[temp2].shade sprite[temp].shade
                    ife vent_spr 1
                        seta[temp2].cstat 32768
                    geta[].sectnum temp4
                    set temp5 tainted[temp4]
                    ife temp5 1
                        seta[temp2].cstat 32768
                }
                else ife surface_type SURFACE_FLESH
                {
                    geta[].ang temp2
                    rand temp3 256
                    ifrnd 127
                        inv temp3
                    add temp3 temp2
                    and temp3 2047
                    seta[].ang temp3
                    rand temp3 1024
                    shiftl temp3 1
                    ife temp3 0
                        set temp3 1
                    ifrnd 127
                        inv temp3
                    zshoot temp3 P_BLOOD
                    seta[].ang temp2

                    spawn A_GENERIC_BLOODSPLAT
                    geta[].owner temp2
                    geta[].htowner temp2
                    geta[temp2].owner temp2
                    ife sprite[temp2].picnum APLAYER
                    {
                        setav[temp].enemy_hz sprite[].z
                        geta[].ang temp3
                        add temp3 1024
                        mod temp3 2047
                        setav[temp].enemy_hang temp3
                        dist temp2 RETURN temp
                        ife player[].curr_weapon WEAPON_SHOTGUN
                        {
                            getactor[temp].htextra temp3
                            ifg temp3 0
                            {
                                set move_v temp3
                                ifg sprite[temp].extra 0
                                    shiftl temp3 3
                                cos move_xv sprite[temp].htang
                                sin move_yv sprite[temp].htang
                                mul move_xv move_v
                                mul move_yv move_v

                                shiftr move_xv 14
                                shiftr move_yv 14
                                getav[temp].enemy_shotgun_xv temp4
                                getav[temp].enemy_shotgun_yv temp5
                                add move_xv temp4
                                add move_yv temp5
                                clamp move_xv -256 256
                                clamp move_yv -256 256
                                setav[temp].enemy_shotgun_xv move_xv
                                setav[temp].enemy_shotgun_yv move_yv
                            }
                        }
                        ifl temp2 546
                            nullop
                        else
                        {
                            set temp6 temp2
                            shiftr temp2 6
                            getactor[temp].htextra temp3
                            ifg temp3 0
                            {
                                add temp3 temp2
                                ife player[].curr_weapon WEAPON_SMG
                                {
                                    set temp7 temp2
                                    shiftr temp7 2
                                    add temp3 temp7
                                }
                                setactor[temp].htextra temp3
                            }
                            switch sprite[temp].picnum
                                case A_CULTIST
                                case A_SHOTGUNNER
                                case A_GREATER
                                case A_DEACON
                                case A_NUKEMUTANT
                                case A_NUKEMUTANT_GDF
								case AM_EXODUDE
                                    set temp4 tilesizy[sprite[temp].picnum]
                                   // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
                                   // simplified to sizy*4*yrepeat
                                    shiftl temp4 2
                                    mul temp4 sprite[temp].yrepeat
                                    set temp5 sprite[temp].z
                                    sub temp5 temp4
                                    shiftr temp4 3
                                    add temp4 temp5
                                    ifl sprite[].z temp4
                                    {
                                        setav[temp].enemy_headsound 1
                                        ife player[].curr_weapon WEAPON_LOVERBOY
                                        {
                                            geta[temp].htextra temp3
                                            rand temp4 1
                                            add temp3 temp4
                                            seta[temp].htextra temp3
                                            ifrnd 4
                                                setav[temp].enemy_headache 1
                                            
                                        }
                                    }
                                    break
                            endswitch
                        }
                    }
                }
                else
                {
                    getav[temp].actor_moveable temp3
                    ife temp3 1
                    {
                        ife sprite[temp].picnum A_CANISTER_2
                        {
                                geta[].owner temp2
                                geta[].htowner temp2
                                geta[temp2].owner temp2
                                ife sprite[temp2].picnum APLAYER
                                {
                                    getactor[temp].htextra temp3
                                    shiftr temp3 3

                                    dist temp2 RETURN temp
                                    ifl temp2 310
                                        nullop
                                    else
                                    {
                                        getav[temp].prop_alt temp2
                                        add temp2 temp3
                                        add temp2 1
                                        setav[temp].prop_alt temp2
                                    }
                                }

                        }
                    }
                }
            }
            else
            {
                geta[].htg_t 7 temp // EXPERIMENTAL AS FUCK ALSO! ... sectors

                // this first flag tells us if we hit hit the floor or ceiling
                // 1 = ceil
                // 2 = flor
                set temp3 0

                getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                add temp2 256
                ifl sprite[].z temp2
                    set temp3 1
                getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                sub temp2 256
                ifg sprite[].z temp2
                    set temp3 2

                ifn temp -1 ifn temp3 0 // only do ops if we actually hit one of the above planes
                {
                    ife temp3 2
                        gets[temp].floorpicnum surface_type
                    else ife temp3 1
                    {
                        gets[temp].ceilingpicnum surface_type
                    }
                    state get_surface_type

                    eqspawn A_BULLETHOLE
                    setav[RETURN].queued 1
                    set temp2 RETURN
                    set temp4 96
                    ifrnd 64
                        or temp4 4
                    seta[temp2].cstat temp4
                    rand temp4 3
                    add temp4 4
                    seta[temp2].xrepeat temp4
                    seta[temp2].yrepeat temp4

                    ife temp3 1
                    {
                        getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp3
                        seta[temp2].z temp3

                        geta[temp2].cstat temp3
                        or temp3 12 // for ceiling alignment we need to flip both axis
                        seta[temp2].cstat temp3

                        // now we determine alignment. on slopes we need to do some tricky
                        // business and figure out how extreme it is.
                        getsector[].ceilingstat temp4
                        ifand temp4 2
                        {
                            gets[].ceilingslope temp4
                            ifle temp4 4096 ifge temp4 -4096
                                nullop
                            else    // if extreme slope, wall-align oriented to firstwall (safest dir)
                            {
                                gets[temp].wallptr temp3
                                getw[temp3].x temp4
                                getw[temp3].point2 temp3
                                getw[temp3].x temp5
                                sub temp4 temp5

                                gets[temp].wallptr temp3
                                getw[temp3].y temp5
                                getw[temp3].point2 temp3
                                getw[temp3].y temp6
                                sub temp5 temp6

                                getangle temp6 temp4 temp5

                                add temp6 1536
                                and temp6 2047
                                seta[temp2].ang temp6

                                geta[temp2].cstat temp3
                                ifand temp3 32
                                    sub temp3 32
                                set temp3 16
                            }
                        }
                        seta[temp2].cstat temp3
                        seta[temp2].shade sector[temp].ceilingshade
                        set temp3 1 // use this as a flag for ceiling or floor again...
                    }
                    else    // same as above for floors
                    {
                        getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp3
                        seta[temp2].z temp3
                        seta[temp2].shade sector[temp].floorshade
                        geta[temp2].cstat temp3
                        getsector[].floorstat temp4
                        ifand temp4 2
                        {
                            gets[].floorslope temp4
                            ifle temp4 4096 ifge temp4 -4096
                                nullop
                            else
                            {
                                gets[temp].wallptr temp3
                                getw[temp3].x temp4
                                getw[temp3].point2 temp3
                                getw[temp3].x temp5
                                sub temp4 temp5

                                gets[temp].wallptr temp3
                                getw[temp3].y temp5
                                getw[temp3].point2 temp3
                                getw[temp3].y temp6
                                sub temp5 temp6

                                getangle temp6 temp4 temp5

                                add temp6 1536
                                and temp6 2047
                                seta[temp2].ang temp6

                                geta[temp2].cstat temp3
                                ifand temp3 32
                                    sub temp3 32
                                set temp3 16
                            }
                        }
                        seta[temp2].cstat temp3
                        set temp3 0
                    }

                    switch surface_type
                        case SURFACE_STONE
                            seta[temp2].picnum A_BULLETHOLE_STONE
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_STONE
                                ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            break
                        case SURFACE_TILE
                            seta[temp2].picnum A_BULLETHOLE_TILE
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_ROCK
                                ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            break
                        case SURFACE_METAL
                            seta[temp2].picnum A_BULLETHOLE_METAL
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_METAL
                                ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            break
                        case SURFACE_GLASS
                            seta[temp2].picnum A_BULLETHOLE_GLASS
                            seta[temp2].blend 129
                            geta[temp2].cstat temp3
                            or temp3 514
                            seta[temp2].cstat temp3
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_GLASS
                                ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            break
                        case SURFACE_WOOD
                            seta[temp2].picnum A_BULLETHOLE_WOOD
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_WOOD
                                ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            break
                        case SURFACE_WATER
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            seta[temp2].cstat 32768
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 124
                            setav[bulletspark_id].particle_force_pal 7
                            ife temp3 1 ifn sector[temp].ceilingpal 0
                            {
                                setav[RETURN].particle_force_pal sector[temp].ceilingpal
                                ife sector[temp].ceilingpal 16  // slimy looking!
                                    setav[bulletspark_id].particle_force_pal 5
                                else
                                    setav[bulletspark_id].particle_force_pal sector[temp].ceilingpal
                            }
                            else ifn sector[temp].floorpal 0
                            {
                                setav[RETURN].particle_force_pal sector[temp].floorpal
                                ife sector[temp].floorpal 16
                                    setav[bulletspark_id].particle_force_pal 5
                                else
                                    setav[bulletspark_id].particle_force_pal sector[temp].floorpal
                            }
                            break
                        case SURFACE_SLIME
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            seta[temp2].cstat 32768
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 124
                            setav[bulletspark_id].particle_force_pal 5
                            ife temp3 1 ifn sector[temp].ceilingpal 0
                            {
                                setav[RETURN].particle_force_pal sector[temp].ceilingpal
                                ife sector[temp].ceilingpal 16  // slimy looking!
                                    setav[bulletspark_id].particle_force_pal 5
                                else
                                    setav[bulletspark_id].particle_force_pal sector[temp].ceilingpal
                            }
                            else ifn sector[temp].floorpal 0
                            {
                                setav[RETURN].particle_force_pal sector[temp].floorpal
                                ife sector[temp].floorpal 16
                                    setav[bulletspark_id].particle_force_pal 5
                                else
                                    setav[bulletspark_id].particle_force_pal sector[temp].floorpal
                            }
                            else
                                setav[RETURN].particle_force_pal 5
                            break
                        case SURFACE_GRASS
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_GRASS
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            seta[temp2].cstat 32768
                            setav[bulletspark_id].particle_force_pal 2
                            setav[bulletspark_id].particle_force_shade 20
                            break
                        case SURFACE_FABRIC
                            seta[temp2].picnum A_BULLETHOLE_FABRIC
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_FABRIC
                                ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            break
                        case SURFACE_PLASTIC
                            seta[temp2].picnum A_BULLETHOLE_STONE
                            seta[temp2].pal 62
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_PLASTIC
                                ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            break
                        case SURFACE_LIGHT
                            seta[temp2].picnum A_BULLETHOLE_GLASS
                            seta[temp2].blend 129
                            geta[temp2].cstat temp3
                            or temp3 514
                            seta[temp2].cstat temp3
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_GLASS
                                ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                                setav[RETURN].particle_force_shade 5
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 123
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 121
                            ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal

                            break
                        case SURFACE_ELECTRICAL
                            seta[temp2].picnum A_BULLETHOLE_METAL
                            seta[temp2].cstat 32768
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 123
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 121
                            ife temp3 1
                                    seta[RETURN].pal sector[temp].ceilingpal
                                else
                                    seta[RETURN].pal sector[temp].floorpal
                            break
                    endswitch
                    geta[temp2].cstat temp3
                    ifand temp3 16
                        or temp3 128
                    geta[].sectnum temp4
                    set temp5 tainted[temp4]
                    ife temp5 1
                        or temp3 32768
                    seta[temp2].cstat temp3
                }
            }

        }
        state bullet_impact_sound
    }
    ifcount 6
        killit
enda

// THIS CODE BLOCK PREVIOUSLY FIXES A WEIRD BUG

defstate bullet_sorting
    ifand sprite[].cstat 16
    {
        rand move_v 5
        add move_v 2
        state move_actor
        geta[].x temp
        add temp move_xv
        seta[].x temp
        geta[].y temp
        add temp move_yv
        seta[].y temp
    }
    else ifand sprite[].cstat 32
    {
        rand move_v 5
        add move_v 2
        ifand sprite[].cstat 8
            inv move_v
        geta[].z temp
        sub temp move_v
        seta[].z temp
    }
    ifand sprite.cstat 32768
    {
        seta .x 524288
        seta .y 524288
    }
ends

useractor notenemy A_BULLETHOLE // default spawned decal | turn this invisible
    ifcount 1
    {
        cstator 32768
        state bullet_sorting
        changespritestat THISACTOR 220
    }
enda
useractor notenemy A_BULLETHOLE_GLASS
    state bullet_sorting
        changespritestat THISACTOR 220
enda
useractor notenemy A_BULLETHOLE_METAL
    state bullet_sorting
        changespritestat THISACTOR 220
enda
useractor notenemy A_BULLETHOLE_TILE
    state bullet_sorting
        changespritestat THISACTOR 220
enda
useractor notenemy A_BULLETHOLE_STONE
    state bullet_sorting
        changespritestat THISACTOR 220
enda
useractor notenemy A_BULLETHOLE_WOOD
    state bullet_sorting
        changespritestat THISACTOR 220
enda
useractor notenemy A_BULLETHOLE_FABRIC
    state bullet_sorting
        changespritestat THISACTOR 220
enda

action AC_SMOKE1BASE 0 7 1 1 5

var htg_t2 -1 2
var htg_xvel 0 2
var htg_zvel 0 2
var htg_nostat 0 2
var htg_owner 0 2
var htg_extra 0 2

appendevent EVENT_EGS
    ifactor A_SMOKE1
    {
        geta[].owner htg_t2
        geta[htg_t2].owner htg_owner
        geta[htg_t2].xvel htg_xvel
        geta[htg_t2].zvel htg_zvel
        geta[htg_t2].extra htg_extra
        seta[].ang sprite[htg_t2].ang
        geta[htg_t2].zvel htzvel
        geta[htg_t2].htmovflag htg_t2

        ifl htg_t2 0
            add htg_t2 65536
      /*  redefinequote 11 %ld
        qsprintf 11 11 htg_t2
        quote 11 */
    }
endevent

var parallax_bw
var parallax_bs

defstate smoke_checksurface
    // Move of this series of code relies on a hack assuming that A_BULLETHOLE
    // will exist within a frame or so and we can instantly swap it out for
    // new decals and perform new behaviors.

    // This differs from the bullet type in that detection
    // difficulty is greatly increased. We require a lot more
    // setup to get even remotely close to the correct surface.
    set temp 0
    ifspawnedby P_PLASMA_BOLT
        set temp 1
    ife temp 1
    {
        set temp htg_t2  // EXPERIMENTAL AS FUCK .. sprites
        ifge temp 49152
        {
            sub temp 49152
            set temp2 0
            ifand tiledata[sprite[temp].picnum].gameflags 32
                set temp2 1
            else ife actorvar[temp].actor_moveable 1
                set temp2 1
            else
            {
                set surface_type sprite[temp].picnum
                state get_surface_type
                switch surface_type
                    case SURFACE_GLASS
                            ife sprite[temp].picnum A_GLASS_WINDOW_1
                            {
                                ifand actorvar[temp].se_lotag 2
                                    nullop
                                else ifand actorvar[temp].se_lotag 1
                                    nullop
                                else
                                    set temp2 1
                            }
                            else ife sprite[temp].picnum A_GLASS_WINDOW_2
                            {
                                ifand actorvar[temp].se_lotag 2
                                    nullop
                                else ifand actorvar[temp].se_lotag 1
                                    nullop
                                else
                                    set temp2 1
                            }
                            else ife sprite[temp].picnum A_GLASS_PANEL
                                set temp2 1
                        break
                    case SURFACE_GRASS
                    case SURFACE_PAPER
                    case SURFACE_FLESH
                    case SURFACE_FABRIC
                        set temp2 1
                        break
                endswitch
            }
            ife temp2 1
            {
                set temp5 sprite[].x
                set temp6 sprite[].y
                set temp7 sprite[].sectnum
                seta[].x sprite[temp].x
                seta[].y sprite[temp].y
                seta[].sectnum sprite[temp].sectnum
                set move_v sprite[temp].clipdist
                set temp2 sprite[temp].xvel
                abs temp2
                shiftl temp2 1
                add move_v temp2
                clamp move_v 16 65536

                state move_actor
                movesprite THISACTOR move_xv move_yv 0 0 temp2
                eshoot P_PLASMA_BOLT
                set temp2 htg_owner
                ifn sprite[temp2].picnum APLAYER
                {
                    seta[RETURN].pal PAL_PLASMA_BOLT_OTHER
                    setav[RETURN].particle_force_pal PAL_PLASMA_BOLT_OTHER
                }
                else
                    seta[RETURN].pal PAL_PLASMA_BOLT

                seta[RETURN].ang sprite[].ang
                getthisprojectile[RETURN].workslike temp3
                or temp3 4096
                setthisprojectile[RETURN].workslike temp3
                seta[RETURN].zvel htg_zvel
                seta[RETURN].xvel htg_xvel
                seta[RETURN].extra htg_extra
                seta[].x temp5
                seta[].y temp6
                seta[].sectnum temp7
            }
        }
    }
        getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp2
        sub temp2 256
        ifg sprite[].z temp2
            seta[].z temp2
        getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp2
        add temp2 256
        ifl sprite[].z temp2
            seta[].z temp2
        geta[].ang temp
        // sub temp 48
        and temp 2047
        seta[].ang temp
        cos h_cos sprite[].ang
        sin h_sin sprite[].ang
        set h_zvel htg_zvel
        shiftl h_zvel 4
        hitscan sprite[].x sprite[].y sprite[].z sprite[].sectnum h_cos h_sin h_zvel hitsect hitwall hitsprite hitx hity hitz CLIPMASK_HITSCAN
        ifn hitsect -1
        {
            seta[].x hitx
            seta[].y hity
            seta[].z hitz
            seta[].sectnum hitsect
            ifn hitwall -1
            {
                set parallax_bw hitwall
                set parallax_bs hitsect
            }
            else ifn hitsprite -1
            {
                ifand sprite[hitsprite].cstat 48
                    nullop
                else
                    set htg_nostat 1
            }
            else
            {
                set htg_t2 hitsect
                add htg_t2 16384
            }
        }
        espawn A_SOUND_EMITTER
        seta[RETURN].extra SE_DIST_PLASMA_SMG // read distance
        seta[RETURN].xrepeat 64
        seta[RETURN].yrepeat 64
        seta[RETURN].cstat 32768
        set temp htg_t2 // walls
        ifl temp 49152 ifge temp 32768
        {
            sub temp 32768
            getw[temp].cstat temp2
            ifand temp2 2   // check for "split" texture walls
            {
                getw[temp].nextsector temp2
                ifn temp2 -1
                {
                    ifl sector[temp2].floorz sprite[].z // if z < floor we probably hit the upper texture
                        getw[temp].nextwall temp
                }
            }
            getw[temp].picnum surface_type
            state get_surface_type

            // this codeblock determines whether or not we hit a maskwall
            // bulletholes won't spawn on masked sectors and we can fix that
            // by flagging them and this allows us to spawn things nicely

            set temp2 0
            ifand wall[temp].cstat 48
                set temp2 1
            ife temp2 1 // if this wall has a maskwall
            {
                // this trick lets us determine if we're in between the ceiling and floor
                // and should be in the masked area
                getw[temp].nextsector temp3
                ifn temp3 -1
                {
                    ifl sprite[].z sector[temp3].floorz ifg sprite[].z sector[temp3].ceilingz
                    {
                        getw[temp].overpicnum surface_type // get the masked texture if so
                        state get_surface_type
                        switch wall[temp].overpicnum
                            case 6440
                            case 6465
                            case 6466
                            case 6467
                            case 6532
                            case 6534
                            case 7610
                            case 7948
                            case 8280
                            case 8281
                            case 8282
                                set temp2 0
                                break
                        endswitch
                    }
                }
            }

            ifn surface_type 0
            {
                set temp3 0 // we're about to recycle temp2 for a bunch of other stuff so
                ife temp2 1 // save its flagged value so we can forcefully spawn a bullethole/decal
                    set temp3 1

                set temp2 0 // reset this flag

                // water/underwater sectors don't normally spawn a decal on walls
                // so let's flag it and forcefully spawn one
                ife sector[].lotag 1
                    set temp2 1
                else ife sector[].lotag 2
                    set temp2 1
                ife temp3 1
                    set temp2 1
                set temp2 1
                ife temp2 1
                {
                    eqspawn A_BULLETHOLE
                    setav[RETURN].queued 1
                    set bullet_hole_id RETURN
                    set temp2 RETURN
                    seta[temp2].xrepeat 4
                    seta[temp2].yrepeat 4

                    // line up the bullethole with the wall
                    getw[temp].x temp4
                    getw[temp].point2 temp3
                    getw[temp3].x temp5
                    sub temp4 temp5

                    getw[temp].y temp5
                    getw[temp].point2 temp3
                    getw[temp3].y temp6
                    sub temp5 temp6

                    getangle temp6 temp4 temp5

                    add temp6 1536
                    and temp6 2047
                    seta[temp2].ang temp6

                    geta[temp2].cstat temp3
                    ifand temp3 32
                        sub temp3 32
                    set temp3 16
                    ifrnd 64
                        or temp3 4
                    ifrnd 64
                        or temp3 8
                    ife htg_nostat 1
                        or temp3 32768
                    seta[temp2].cstat temp3
                }

                set temp2 bullet_hole_id
                ifn temp2 -1
                {
                    ife sprite[temp2].picnum A_BULLETHOLE
                    {
                        geta[temp2].cstat temp3
                        ifand sector[parallax_bs].ceilingstat 1
                            set temp5 2
                        else ifand sector[parallax_bs].floorstat 1
                            set temp5 2
                        getw[parallax_bw].nextsector temp4
                        ifn temp4 -1
                        {
                            ife temp5 2
                            {
                                set temp5 0
                                ifand sector[temp4].ceilingstat 1
                                    set temp5 1
                                else ifand sector[temp4].floorstat 1
                                    set temp5 2
                                ifn temp5 0
                                {
                                    ife temp5 1
                                    {
                                        ifl sprite[].z sector[temp4].ceilingz
                                            or temp3 32768
                                    }
                                    else ife temp5 2
                                    {
                                        ifg sprite[].z sector[temp4].floorz
                                            or temp3 32768
                                    }
                                    else ife sector[temp4].floorz sector[temp4].ceilingz
                                        or temp3 32768
                                    ifand temp3 32768
                                    {
                                        seta[temp2].cstat temp3
                                        seta[temp2].picnum A_BULLETHOLE_METAL
                                        set temp2 -1
                                        killit
                                    }
                                }
                            }
                        }
                        rand temp4 3
                        add temp4 4
                        seta[temp2].xrepeat temp4
                        seta[temp2].yrepeat temp4
                        switch surface_type
                            case SURFACE_STONE
                                seta[temp2].picnum A_BULLETHOLE_STONE
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_STONE
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_TILE
                                seta[temp2].picnum A_BULLETHOLE_TILE
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_ROCK
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_METAL
                                seta[temp2].picnum A_BULLETHOLE_METAL
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_METAL
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_GLASS
                                seta[temp2].picnum A_BULLETHOLE_GLASS
                                seta[temp2].blend 129
                                geta[temp2].cstat temp3
                                or temp3 514
                                seta[temp2].cstat temp3
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GLASS
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_WOOD
                                seta[temp2].picnum A_BULLETHOLE_WOOD
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_WOOD
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_WATER
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 125
                                ifn wall[temp].pal 0
                                    setav[RETURN].particle_force_pal wall[temp].pal
                                break
                            case SURFACE_SLIME
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 125
                                ifn wall[temp].pal 0
                                    setav[RETURN].particle_force_pal wall[temp].pal
                                else
                                    setav[RETURN].particle_force_pal 5
                                break
                            case SURFACE_GRASS
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GRASS
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                seta[temp2].cstat 32768
                                break
                            case SURFACE_FABRIC
                                seta[temp2].picnum A_BULLETHOLE_FABRIC
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_FABRIC
                                    seta[RETURN].pal wall[temp].pal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_PLASTIC
                                seta[temp2].picnum A_BULLETHOLE_STONE
                                seta[temp2].pal 62
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_PLASTIC
                                    seta[RETURN].pal wall[temp].pal
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                break
                            case SURFACE_LIGHT
                                seta[temp2].picnum A_BULLETHOLE_GLASS
                                seta[temp2].blend 129
                                geta[temp2].cstat temp3
                                or temp3 514
                                seta[temp2].cstat temp3
                                rand temp3 1
                                add temp3 1
                                for itervar range temp3
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GLASS
                                    seta[RETURN].pal wall[temp].pal
                                    setav[RETURN].particle_force_shade 5
                                    geta[].ang temp4
                                    add temp4 1024
                                    and temp4 2047
                                    seta[RETURN].ang temp4
                                }
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 123
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 122
                                seta[RETURN].pal wall[temp].pal
                                seta[RETURN].ang sprite[temp2].ang
                                break
                            case SURFACE_ELECTRICAL
                                seta[temp2].picnum A_BULLETHOLE_METAL
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 123
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 122
                                seta[RETURN].pal wall[temp].pal
                                seta[RETURN].ang sprite[temp2].ang
                                break
                        endswitch
                        geta[temp2].cstat temp3
                        or temp3 64
                        or temp3 128
                        geta[temp2].sectnum temp4
                        set temp5 tainted[temp4]
                        ife temp5 1
                            or temp3 32768
                        getw[temp].nextsector temp4
                        ifn temp4 -1
                        {
                            set temp5 tainted[temp4]
                            ife temp5 1
                                or temp3 32768
                        }
                        seta[temp2].cstat temp3
                        seta[temp2].shade wall[temp].shade
                    }
                }

            }
        }
        else
        {
            set temp htg_t2  // EXPERIMENTAL AS FUCK .. sprites
            ifge temp 49152
            {
                sub temp 49152
                geta[temp].picnum surface_type
                state get_surface_type
                set temp2 0
                switch sprite[temp].picnum
                    case 8280
                    case 8281
                    case 8282
                        set temp2 1
                        break
                endswitch
                set temp7 0
                ife sprite[temp].statnum 0
                    set temp7 1
                else
                {
                    switch surface_type
                        case SURFACE_GRASS
                        case SURFACE_WATER
                        case SURFACE_SLIME
                            set temp7 1
                            break
                   endswitch
                }
                ifn surface_type 0 ifn surface_type SURFACE_FLESH ife temp7 1 ife temp2 0
                {
                    eqspawn A_BULLETHOLE
                    setav[RETURN].queued 1
                    set temp2 RETURN
                    set bullet_hole_id RETURN
                    geta[temp].cstat temp3
                    ifand temp3 1
                        sub temp3 1
                    ifrnd 64
                        or temp3 4
                    ifrnd 64
                        or temp3 8
                    ife htg_nostat 1
                        or temp3 32768
                    seta[temp2].cstat temp3
                    rand temp4 3
                    add temp4 4
                    seta[temp2].xrepeat temp4
                    seta[temp2].yrepeat temp4

                    seta[temp2].ang sprite[temp].ang

                    switch surface_type
                        case SURFACE_STONE
                            seta[temp2].picnum A_BULLETHOLE_STONE
                            break
                        case SURFACE_TILE
                            seta[temp2].picnum A_BULLETHOLE_TILE
                            break
                        case SURFACE_METAL
                            seta[temp2].picnum A_BULLETHOLE_METAL
                            break
                        case SURFACE_GLASS
                            seta[temp2].picnum A_BULLETHOLE_GLASS
                            seta[temp2].blend 129
                            geta[temp2].cstat temp3
                            or temp3 514
                            seta[temp2].cstat temp3
                            break
                        case SURFACE_WOOD
                            seta[temp2].picnum A_BULLETHOLE_WOOD
                            break
                        case SURFACE_WATER
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            seta[temp2].cstat 32768
                            ifand sprite[temp].cstat 32
                            {
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 124
                                ifn sprite[temp].pal 0
                                    setav[RETURN].particle_force_pal sprite[temp].pal
                            }
                            else
                            {
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 125
                                ifn sprite[temp].pal 0
                                    setav[RETURN].particle_force_pal sprite[temp].pal
                            }
                            break
                        case SURFACE_SLIME
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            seta[temp2].cstat 32768
                            ifand sprite[temp].cstat 32
                            {
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 124
                                ifn sprite[temp].pal 0
                                    setav[RETURN].particle_force_pal sprite[temp].pal
                                else
                                    setav[RETURN].particle_force_pal 5
                            }
                            else
                            {
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 125
                                ifn sprite[temp].pal 0
                                    setav[RETURN].particle_force_pal sprite[temp].pal
                                else
                                    setav[RETURN].particle_force_pal 5
                            }
                            break
                        case SURFACE_GRASS
                            seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                            rand temp4 1
                            add temp4 1
                            for itervar range temp4
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_GRASS
                                rand temp5 2047
                                seta[RETURN].ang temp5
                            }
                            seta[temp2].cstat 32768
                            break
                        case SURFACE_FABRIC
                            seta[temp2].picnum A_BULLETHOLE_FABRIC
                            break
                        case SURFACE_PLASTIC
                            seta[temp2].picnum A_BULLETHOLE_STONE
                            seta[temp2].pal 62
                            break
                        case SURFACE_LIGHT
                            seta[temp2].picnum A_BULLETHOLE_GLASS
                            seta[temp2].blend 129
                            geta[temp2].cstat temp3
                            or temp3 514
                            ifand sprite[temp].cstat 48
                                nullop
                            else
                                or temp3 32768
                            seta[temp2].cstat temp3
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 123
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 120
                            seta[RETURN].pal sprite[temp].pal
                            rand temp3 1
                            add temp3 1
                            for itervar range temp3
                            {
                                espawn A_GENERIC_DEBRIS
                                setav[RETURN].debris_type DEBRIS_GLASS
                                seta[RETURN].pal wall[temp].pal
                                setav[RETURN].particle_force_shade 5
                                geta[].ang temp4
                                add temp4 1024
                                and temp4 2047
                                seta[RETURN].ang temp4
                            }
                            break
                        case SURFACE_ELECTRICAL
                            seta[temp2].picnum A_BULLETHOLE_METAL
                            seta[temp2].cstat 32768
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 123
                            espawn A_GENERIC_PARTICLE
                            seta[RETURN].xrepeat 120
                            seta[RETURN].pal sprite[temp].pal
                            break
                    endswitch
                    geta[temp2].cstat temp3
                    ifand temp3 16
                        or temp3 128
                    geta[temp2].sectnum temp4
                    set temp5 tainted[temp4]
                    ife temp5 1
                        or temp4 32768
                    seta[temp2].cstat temp3
                    ifand temp3 16
                        nullop
                    else ifand temp3 32
                        nullop
                    else
                        seta[temp2].cstat 32768
                    seta[temp2].shade sprite[temp].shade
                    ife vent_spr 1
                        seta[temp2].cstat 32768
                }
                else ife surface_type SURFACE_FLESH
                {
                    espawn A_GENERIC_PARTICLE
                    seta[RETURN].xrepeat 126
                    seta[RETURN].cstat 32768
                    seta[RETURN].ang temp3
                    spawn A_GENERIC_BLOODSPLAT
                    setav[temp].htzvel htzvel
                    set temp2 htg_owner
                    ife sprite[temp2].picnum APLAYER
                    {
                        dist temp2 RETURN temp
                        ifl temp2 546
                            nullop
                        else
                        {
                            shiftr temp2 2
                            getactor[temp].htextra temp3
                            ifg temp3 0
                            {
                                addvarvar temp3 temp2
                                setactor[temp].htextra temp3
                            }
                        }
                        switch sprite[temp].picnum
                            case A_CULTIST
                            case A_SHOTGUNNER
                            case A_GREATER
                            case A_DEACON
                            case A_NUKEMUTANT
                            case A_NUKEMUTANT_GDF
							case AM_EXODUDE
                                set temp4 tilesizy[sprite[temp].picnum]
                               // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
                               // simplified to sizy*4*yrepeat
                                shiftl temp4 2
                                mul temp4 sprite[temp].yrepeat
                                set temp5 sprite[temp].z
                                sub temp5 temp4
                                shiftr temp4 3
                                add temp4 temp5
                                ifl sprite[].z temp4
                                    setav[temp].enemy_headsound 1
                                break
                        endswitch
                    }
                    ifspawnedby P_PLASMA_BOLT
                    {
                        set temp2 htg_owner
                        ife sprite[temp2].picnum APLAYER ifand tiledata[sprite[temp].picnum].gameflags 32
                        {
                            ifg sprite[temp].extra 0
                            {
                                getav[temp].enemy_shocked temp3
                                ife sprite[temp].picnum A_MECHSECT
                                {
                                    ifge sprite[temp].htextra sprite[temp].extra
                                    {
                                        setav[temp].counter3 1
                                        set temp4 MECHSECT_HEALTH
                                        mul temp4 3
                                        ifg sprite[temp].htextra temp4
                                            setav[temp].counter3 2
                                    }
                                }
                                else ife sprite[temp].picnum A_DRONE
                                    add temp3 5
                                add temp3 1
                                ifn sprite[temp].picnum A_DRONE
                                    clamp temp3 0 2
                                setav[temp].enemy_shocked temp3
                            }
                            set move_v 8
                            ifg sprite[temp].extra 0
                                shiftl temp3 3
                            cos move_xv sprite[temp].htang
                            sin move_yv sprite[temp].htang
                            mul move_xv move_v
                            mul move_yv move_v

                            shiftr move_xv 14
                            shiftr move_yv 14
                            getav[temp].enemy_shotgun_xv temp4
                            getav[temp].enemy_shotgun_yv temp5
                            add move_xv temp4
                            add move_yv temp5
                            clamp move_xv -256 256
                            clamp move_yv -256 256
                            setav[temp].enemy_shotgun_xv move_xv
                            setav[temp].enemy_shotgun_yv move_yv
                        }
                    }
                }
            }
            else
            {
                set temp htg_t2
                set temp2 NUMSECTORS
                add temp2 16384
                ifg temp temp2
                    set temp 0
                ifge temp 16384
                {
                    sub temp 16384 // EXPERIMENTAL AS FUCK ALSO! ... sectors

                    // this first flag tells us if we hit hit the floor or ceiling
                    // 1 = ceil
                    // 2 = flor
                    set temp3 0

                    getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                    add temp2 1024
                    ifl sprite[].z temp2
                        set temp3 1
                    getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                    sub temp2 1024
                    ifg sprite[].z temp2
                        set temp3 2

                    ifn temp -1 ifn temp3 0 // only do ops if we actually hit one of the above planes
                    {
                        ife temp3 2
                            gets[temp].floorpicnum surface_type
                        else ife temp3 1
                        {
                            gets[temp].ceilingpicnum surface_type
                        }
                        state get_surface_type

                        eqspawn A_BULLETHOLE
                        setav[RETURN].queued 1
                        set bullet_hole_id RETURN
                        set temp2 RETURN
                        set temp4 96
                        ifrnd 64
                            or temp4 4
                        ife htg_nostat 1
                            or temp4 32768
                        seta[temp2].cstat temp4
                        rand temp4 3
                        add temp4 4
                        seta[temp2].xrepeat temp4
                        seta[temp2].yrepeat temp4

                        ife temp3 1
                        {
                            getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp3
                            seta[temp2].z temp3

                            geta[temp2].cstat temp3
                            or temp3 12 // for ceiling alignment we need to flip both axis
                            seta[temp2].cstat temp3

                            // now we determine alignment. on slopes we need to do some tricky
                            // business and figure out how extreme it is.
                            getsector[].ceilingstat temp4
                            ifand temp4 2
                            {
                                gets[].ceilingslope temp4
                                ifle temp4 4096 ifge temp4 -4096
                                    nullop
                                else    // if extreme slope, wall-align oriented to firstwall (safest dir)
                                {
                                    gets[temp].wallptr temp3
                                    getw[temp3].x temp4
                                    getw[temp3].point2 temp3
                                    getw[temp3].x temp5
                                    sub temp4 temp5

                                    gets[temp].wallptr temp3
                                    getw[temp3].y temp5
                                    getw[temp3].point2 temp3
                                    getw[temp3].y temp6
                                    sub temp5 temp6

                                    getangle temp6 temp4 temp5

                                    add temp6 1536
                                    and temp6 2047
                                    seta[temp2].ang temp6

                                    geta[temp2].cstat temp3
                                    ifand temp3 32
                                        sub temp3 32
                                    set temp3 16
                                }
                            }
                            seta[temp2].cstat temp3
                            seta[temp2].shade sector[temp].ceilingshade
                            set temp3 1 // use this as a flag for ceiling or floor again...
                        }
                        else    // same as above for floors
                        {
                            
                            getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp3
                            seta[temp2].z temp3
                            seta[temp2].shade sector[temp].floorshade
                            geta[temp2].cstat temp3
                            getsector[].floorstat temp4
                            ifand temp4 2
                            {
                                gets[].floorslope temp4
                                ifle temp4 4096 ifge temp4 -4096
                                    nullop
                                else
                                {
                                    gets[temp].wallptr temp3
                                    getw[temp3].x temp4
                                    getw[temp3].point2 temp3
                                    getw[temp3].x temp5
                                    sub temp4 temp5

                                    gets[temp].wallptr temp3
                                    getw[temp3].y temp5
                                    getw[temp3].point2 temp3
                                    getw[temp3].y temp6
                                    sub temp5 temp6

                                    getangle temp6 temp4 temp5

                                    add temp6 1536
                                    and temp6 2047
                                    seta[temp2].ang temp6

                                    geta[temp2].cstat temp3
                                    ifand temp3 32
                                        sub temp3 32
                                    set temp3 16
                                }
                            }
                            seta[temp2].cstat temp3
                            set temp3 0
                        }

                        switch surface_type
                            case SURFACE_STONE
                                seta[temp2].picnum A_BULLETHOLE_STONE
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_STONE
                                    ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_TILE
                                seta[temp2].picnum A_BULLETHOLE_TILE
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_ROCK
                                    ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_METAL
                                seta[temp2].picnum A_BULLETHOLE_METAL
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_METAL
                                    ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_GLASS
                                seta[temp2].picnum A_BULLETHOLE_GLASS
                                seta[temp2].blend 129
                                geta[temp2].cstat temp3
                                or temp3 514
                                seta[temp2].cstat temp3
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GLASS
                                    ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_WOOD
                                seta[temp2].picnum A_BULLETHOLE_WOOD
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_WOOD
                                    ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_WATER
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 124
                                ife temp3 1 ifn sector[temp].ceilingpal 0
                                    setav[RETURN].particle_force_pal sector[temp].ceilingpal
                                else ifn sector[temp].floorpal 0
                                    setav[RETURN].particle_force_pal sector[temp].floorpal
                                break
                            case SURFACE_SLIME
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 124
                                ife temp3 1 ifn sector[temp].ceilingpal 0
                                    setav[RETURN].particle_force_pal sector[temp].ceilingpal
                                else ifn sector[temp].floorpal 0
                                    setav[RETURN].particle_force_pal sector[temp].floorpal
                                else
                                    setav[RETURN].particle_force_pal 5
                                break
                            case SURFACE_GRASS
                                seta[temp2].picnum A_BULLETHOLE_WOOD // anything but default
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GRASS
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                seta[temp2].cstat 32768
                                break
                            case SURFACE_FABRIC
                                seta[temp2].picnum A_BULLETHOLE_FABRIC
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_FABRIC
                                    ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_PLASTIC
                                seta[temp2].picnum A_BULLETHOLE_STONE
                                seta[temp2].pal 62
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_PLASTIC
                                    ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                break
                            case SURFACE_LIGHT
                                seta[temp2].picnum A_BULLETHOLE_GLASS
                                seta[temp2].blend 129
                                geta[temp2].cstat temp3
                                or temp3 514
                                seta[temp2].cstat temp3
                                rand temp4 1
                                add temp4 1
                                for itervar range temp4
                                {
                                    espawn A_GENERIC_DEBRIS
                                    setav[RETURN].debris_type DEBRIS_GLASS
                                    ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                    setav[RETURN].particle_force_shade 5
                                    rand temp5 2047
                                    seta[RETURN].ang temp5
                                }
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 123
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 121
                                ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal

                                break
                            case SURFACE_ELECTRICAL
                                seta[temp2].picnum A_BULLETHOLE_METAL
                                seta[temp2].cstat 32768
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 123
                                espawn A_GENERIC_PARTICLE
                                seta[RETURN].xrepeat 121
                                ife temp3 1
                                        seta[RETURN].pal sector[temp].ceilingpal
                                    else
                                        seta[RETURN].pal sector[temp].floorpal
                                break
                        endswitch
                        geta[temp2].cstat temp3
                        ifand temp3 16
                            or temp3 128
                        geta[temp2].sectnum temp4
                        set temp5 tainted[temp4]
                        ife temp5 1
                            or temp3 32768
                        seta[temp2].cstat temp3
                    }
                }
            }

        }
    state bullet_impact_sound
ends

actor A_SMOKE1 0 AC_SMOKE1BASE
    ifspawnedby P_FIREBALL
    {
        for temp range 3
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 127
        }
        ife sprite[].htg_t 2 1 // ifactioncount
            add shakeitbaby 4
        cstat 32768
        ife counter 0
            state smoke_checksurface
        set counter 1
    }
    ifspawnedby P_PLASMA_BOLT
    {
        for temp range 2
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 128
        }
        ife counter 0
            state smoke_checksurface

        set counter 1
        ife sprite[].htg_t 2 1 // ifactioncount
        {
            add shakeitbaby 1
            espawn A_EXPLOSION
            seta[RETURN].xrepeat 1
            seta[RETURN].yrepeat 1
            seta[RETURN].pal PAL_PLASMA_BOLT
            seta[RETURN].cstat 130
            seta[RETURN].shade -127
            seta[RETURN].blend 129
        }
        spritepal PAL_PLASMA_BOLT
        ifcount 5
            killit
    }
    ifspawnedby P_SMG2
    {
        rand temp 3
        add temp 1
        for itervar range temp
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 129
        }
        ife counter 0
        {
            state smoke_checksurface
            ifpdistl 10240
            {
                ife surface_type SURFACE_FLESH
                    sound S_LAVANAIL_FLESH
                else
                    sound S_LAVANAIL_SURFACE
            }
        }
        set counter 1
        spawn A_SMOKE2
        spawn A_NAPALM_FLAME
        killit
    }
    ifspawnedby A_SPARK1
    {
        cstat 32768
        ife counter 0
        {
            spawn A_SMOKE2
            set counter 1
        }
    }
    ifspawnedby P_SHOCKER
    {
        flash
        seta[player[].i].shade -10
        cstat 32768
        ife counter 0
        {
            ifonwater
            {
                iffloordistl 12
                {
                    ife player[].cursectnum sprite[].sectnum
                    {
                        ifp ponground
                        {
                            addphealth -1
                            set p_sizzled_count 15
                            palfrom 16 63 63 63
                        }
                    }
                }
            }
            spawn A_SMOKE2
            ifinwater
                nullop
            else
            {
                getceilzofslope sprite.sectnum sprite.x sprite.y temp2
                sub temp2 256
                ifl sprite.z temp2
                    seta .z temp2
                espawn A_GENERIC_PARTICLE
                seta[RETURN].xrepeat 120
                setav[RETURN].particle_force_pal 7
                setav[RETURN].particle_force_shade 15
                seta[RETURN].blend 129
                espawn A_GENERIC_PARTICLE
                seta[RETURN].xrepeat 123
                setav[RETURN].particle_force_pal 7
                setav[RETURN].particle_force_shade 0
                rand temp 10
                add temp 10
                set temp2 0
                for temp2 range temp
                {
                    espawn A_GENERIC_PARTICLE
                    seta[RETURN].xrepeat 129
                    setav[RETURN].particle_force_shade 20
                    setav[RETURN].particle_force_pal 48
                }
                rand temp 4
                add temp 4
                set temp2 0
                for temp2 range temp
                {
                    espawn A_GENERIC_PARTICLE
                    seta[RETURN].xrepeat 128
                    setav[RETURN].particle_force_shade 20
                    setav[RETURN].particle_force_pal 48
                }
                set counter 1
                rand temp 2
                add temp S_ENV_ZAP1
                soundvar temp
            }
            rand temp 2
            add temp S_MELEE_THUD01
            soundvar temp
            geta[].htg_t 6 temp // walls
            ifn temp -1
            {
                getw[temp].cstat temp2
                ifand temp2 2   // check for "split" texture walls
                {
                    getw[temp].nextwall temp2
                    ifn temp2 -1
                    {
                        getw[temp].nextsector temp2
                        ifn temp2 -1
                        {
                            gets[temp2].floorz temp3
                            sub temp3 2048
                            ifl temp3 sprite[].z // if z < floor we probably hit the upper texture
                                getw[temp].nextwall temp
                        }
                    }
                }
                getw[temp].picnum surface_type
                state get_surface_type

                // this codeblock determines whether or not we hit a maskwall
                // bulletholes won't spawn on masked sectors and we can fix that
                // by flagging them and this allows us to spawn things nicely

                set temp2 0
                ifand wall[temp].cstat 16
                    set temp2 1
                ifand wall[temp].cstat 32
                    set temp2 1
                ife temp2 1 // if this wall has a maskwall
                {
                    // this trick lets us determine if we're in between the ceiling and floor
                    // and should be in the masked area
                    getw[temp].nextsector temp3
                    ifn temp3 -1
                    {
                        ifl sprite[].z sector[temp3].floorz ifg sprite[].z sector[temp3].ceilingz
                        {
                            getw[temp].overpicnum surface_type // get the masked texture if so
                            state get_surface_type
                        }
                    }
                }
            }
            geta[].htg_t 8 temp // EXPERIMENTAL AS FUCK .. sprites
            ifn temp -1
            {
                geta[temp].picnum surface_type
                state get_surface_type
                set temp3 0
                ifand tiledata[sprite[temp].picnum].gameflags 32
                {
                    ifge actorvar[temp].enemy_shocked 2
                        set temp3 1
                    else ife sprite[temp].picnum A_MECHSECT
                        set temp3 1
                }
                    ife temp3 1
                    {
                        palfrom 5 0 0 30
                        set move_v 128
                        ifg sprite[temp].extra 0
                            shiftl temp3 3
                        cos move_xv sprite[temp].htang
                        sin move_yv sprite[temp].htang
                        mul move_xv move_v
                        mul move_yv move_v

                        shiftr move_xv 14
                        shiftr move_yv 14
                        getav[temp].enemy_shotgun_xv temp4
                        getav[temp].enemy_shotgun_yv temp5
                        add move_xv temp4
                        add move_yv temp5
                        clamp move_xv -256 256
                        clamp move_yv -256 256
                        setav[temp].enemy_shotgun_xv move_xv
                        setav[temp].enemy_shotgun_yv move_yv
                    }
            }
            geta[].htg_t 7 temp // EXPERIMENTAL AS FUCK ALSO! ... sectors

            // this first flag tells us if we hit hit the floor or ceiling
            // 1 = ceil
            // 2 = flor
            set temp3 0

            getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp2
            add temp2 256
            ifl sprite[].z temp2
                set temp3 1
            getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp2
            sub temp2 2048
            set temp4 sprite.z
            ifge sprite[].z temp2
                set temp3 2

            ifn temp -1 ifn temp3 0 // only do ops if we actually hit one of the above planes
            {
                ife temp3 2
                    gets[temp].floorpicnum surface_type
                else ife temp3 1
                {
                    gets[temp].ceilingpicnum surface_type
                }
                state get_surface_type
            }
            ife surface_type SURFACE_LIGHT
                set surface_type SURFACE_GLASS

            switch surface_type
                case SURFACE_GLASS
                case SURFACE_WATER
                case SURFACE_SLIME
                case SURFACE_METAL
                case SURFACE_WOOD
                    state bullet_impact_sound
                    break
                case SURFACE_GRASS
                    rand temp4 1
                    add temp4 1
                    for itervar range temp4
                    {
                        espawn A_GENERIC_DEBRIS
                        setav[RETURN].debris_type DEBRIS_GRASS
                        rand temp5 2047
                        seta[RETURN].ang temp5
                    }
                    break
                case SURFACE_FLESH
                    sound S_IMPACT_HEADSHOT
                    break
            endswitch
            findnearactor3d A_BATONSWITCH_OFF 128 temp
            findnearactor3d A_BATONSWITCH_TIMED 128 temp2
            ifn temp -1
            {
                canseespr THISACTOR temp temp3
                ife temp3 1
                {
                    seta[temp].htpicnum P_SHOCKER
                    seta[temp].htextra 1
                }
            }
            else ifn temp2 -1
            {
                canseespr THISACTOR temp2 temp3
                ife temp3 1
                {
                    seta[temp2].htpicnum P_SHOCKER
                    seta[temp2].htextra 1
                }
            }
            killit
        }
    }
    ifcount 7
        killit
enda

actor BULLET
    killit
enda

action AC_BLOOD1BASE 0 5 1 1 5

appendevent EVENT_EGS
    ifactor 6711
        cstat 32768
endevent


// --------
// A_GENERIC_PARTICLE should be programmed to
// be any flashy spark required by the game
// with references to what spawned it to execute
//  the proper code.
//
// For its initial setup we absolutely must
// make it not take on the shade or pal of
// a given sector.
// --------
spritenoshade A_GENERIC_PARTICLE
spritenopal A_GENERIC_PARTICLE

action AC_BULLETTRAIL 0 1 1 1 1
action AC_BULLETSPARK 0 1 1 1 1
action AC_FIREBALLEXPLOSION 0 1 1 1 1
action AC_PLASMA_BOLTEXPLOSION 362 1 1 1 1
action AC_PLASMA_BOLT_TRAIL -765 1 5 1 1
action AC_BLOODPARTICLE 5 1 1 1 1
action AC_BOWLINGBOMBTRAIL -571 1 1 1 1
action AC_WATERSPLASH_WALL 436 15 1 1 1 // pal 7
action AC_WATERSPLASH_FLOOR 422 14 1 1 1
action AC_LIGHTSPARK_FLASH 359 3 1 1 2
action AC_LIGHTSPARK_SPARK 372 10 1 1 1
action AC_LIGHTSPARK_SPARK_SP 362 10 1 1 1
action AC_LIGHTSPARK_SPARK_FC 382 10 1 1 1
action AC_BUBBLEBOBBLE  417 1 1 1 1
action AC_BUBBLEBOBBLE2 417 1 1 1 1

var particle1 0 2
var particle2 0 2
var particle_spawned 0 2

eventloadactor A_GENERIC_PARTICLE
    cstat 32768
enda
defstate bullet_trail
    ife counter 0
    {
        getp[].i temp
        ldist temp THISACTOR temp
        ifl temp 400
            nullop
        else
            cstat 130
        shiftr temp 7
        ifg temp 24
            set temp 24
        seta[].xrepeat temp
        seta[].yrepeat temp
        seta[].shade -127
        seta[].blend 129
    }
    add counter 1 // keep this incrementing case we need it later for additional effects

    geta[].xrepeat temp
    sub temp 4
    ifl temp 1
        set temp 0
    seta[].xrepeat temp
    seta[].yrepeat temp




ends

defstate fireball_trail
    ife counter 0
    {
        rand temp 32
        add temp 32
        seta[].xrepeat temp
        seta[].yrepeat temp
        seta[].shade -127
        geta[].ang temp
        rand temp2 64
        ifrnd 127
            inv temp2
        add temp temp2
        add temp 1024
        and temp 2047
        seta[].ang temp
        spritepal 7
        rand particle1 40
        add particle1 80
        ifrnd 127
            inv particle1

    }
    seta[].blend 255
    seta[].xvel 80
    seta[].zvel particle1
    ssp THISACTOR 0
    add counter 1 // keep this incrementing case we need it later for additional effects

    geta[].xrepeat temp
    sub temp 4
    ifl temp 1
        set temp 0
    seta[].xrepeat temp
    geta[].yrepeat temp
    ifn temp 0
        sub temp 4
    seta[].yrepeat temp


    ifpdistl 400
        nullop
    else
        cstat 130
    ifg counter 5
        cstator 512
    iffloordistl 1
    {
        seta[].xrepeat 0
        seta[].statnum STAT_ACTOR
    }
ends

defstate fireball_explosion
    ife counter 0
    {
        rand temp 32
        add temp 32
        seta[].xrepeat temp
        seta[].yrepeat temp
        seta[].shade -127
        geta[].ang temp
        rand temp2 480
        ifrnd 127
            inv temp2
        add temp temp2
        add temp 1024
        and temp 2047
        seta[].ang temp
        spritepal 7

        rand particle2 1024
        add particle2 512
        ifrnd 127
            inv particle2
        seta[].zvel particle2

        rand particle1 20
        add particle1 60

        iffloordistl 1
        {
            geta[].zvel particle2
            ifg particle2 0
                inv particle2
            seta[].zvel particle2
        }
        else
        {
            geta[].z temp
            add temp 1536
            seta[].z temp
        }
    }

    seta[].xvel particle1
    seta[].zvel particle2
    ssp THISACTOR 0

    iffloordistl 1 ifl counter 15
        fall

    add counter 1 // keep this incrementing case we need it later for additional effects

    geta[].xrepeat temp
    sub temp 2
    ifl temp 1
        set temp 0
    seta[].xrepeat temp
    geta[].yrepeat temp
    ifn temp 0
        sub temp 2
    seta[].yrepeat temp



    cstat 130

    ifg counter 5
        cstator 512
ends

defstate bullet_spark
    ife counter 0
    {
        rand temp 4
        add temp 10
        ifg particle_force_shade 10
            sub temp 4
        seta[].xrepeat temp
        seta[].yrepeat temp
        seta[].shade -127
        geta[].ang temp
        rand temp2 480
        ifrnd 127
            inv temp2
        add temp temp2
        add temp 1024
        and temp 2047
        seta[].ang temp
        spritepal 11

        rand particle2 1024
        add particle2 512
        inv particle2
        iffloordistl 1
            sub particle2 2048
        seta[].zvel particle2

        rand particle1 20
        add particle1 60


            geta[].z temp
            add temp 1536
            seta[].z temp
    }

    seta[].xvel particle1
    ssp THISACTOR 0

        fall

    add counter 1 // keep this incrementing case we need it later for additional effects

    geta[].xrepeat temp
    sub temp 1
    ifl temp 1
        set temp 0
    seta[].xrepeat temp
    geta[].yrepeat temp
    ifn temp 0
        sub temp 1
    seta[].yrepeat temp



        cstat 130

    iffloordistl 1
    {
        shiftr particle2 1
        seta[].zvel particle2
    }
    else ifl particle2 -2048
    {
        add particle2 2048
        seta[].zvel particle2
    }
ends

defstate bubble_rise
    ife counter 0
    {
        ifspawnedby P_SMOKE2
            set debris_add_vel 1536
        rand temp 12
        add temp 4
        seta[].xrepeat temp
        mul temp 10
        div temp 13
        seta[].yrepeat temp
        seta[].shade 5
        seta[].blend 129
        rand temp 2047
        seta[].ang temp
        spritepal 1
        
        rand temp 256
        ifg ps_bubbledist 0
            clamp temp 0 ps_bubbledist
        ifrnd 127
            inv temp
        ifspawnedby A_SPARK1
            shiftr temp 2
        add temp sprite[].x
        seta[].x temp
        rand temp 256
        ifg ps_bubbledist 0
            clamp temp 0 ps_bubbledist
        ifrnd 127
            inv temp
        ifspawnedby A_SPARK1
            shiftr temp 2
        add temp sprite[].y
        seta[].y temp
        rand temp 2048
        inv temp
        add temp sprite[].z
        seta[].z temp
        set temp sprite[].sectnum
        updatesector sprite[].x sprite[].y temp
        ifn temp -1
            seta[].sectnum temp
        set counter 1
        ifrnd 127
            inv counter
        cstat 32768
    }
    else
    {
        rand temp sprite[].xrepeat
        shiftr temp 1
        add temp sprite[].xrepeat
        shiftr temp 2
        add temp 2
        seta[].xvel temp
        
        rand temp sprite[].yrepeat
        shiftr temp 1
        add temp sprite[].yrepeat
        shiftl temp 2
        add temp 64
        ifg debris_add_vel 1
            add temp debris_add_vel
        inv temp
        seta[].zvel temp
        
        
        geta[].xrepeat temp
        add temp sprite[].yrepeat
        rand temp2 temp
        ifrnd 92
            inv temp2
        ife counter -1
            inv temp2
        geta[].ang temp
        add temp temp2
        and temp 2047
        seta[].ang temp
        ssp THISACTOR CLIPMASK0
        
        cstat 130
    }
    ifceilingdistl 4
    {
        seta[].xrepeat 0
        seta[].yrepeat 0
        seta[].statnum STAT_ACTOR
    }
ends

defstate bubble_spray
    ife counter 0
    {
        rand temp 12
        add temp 4
        seta[].xrepeat temp
        mul temp 10
        div temp 13
        seta[].yrepeat temp
        seta[].shade 5
        seta[].blend 129

        rand temp 128
        ifrnd 127
            inv temp
        add temp sprite.ang
        add temp 1024
        and temp 2047
        seta[].ang temp
        spritepal 1
        
        rand temp 256
        ifrnd 127
            inv temp
        add temp sprite[].x
        seta[].x temp
        rand temp 256
        ifrnd 127
            inv temp
        add temp sprite[].y
        seta[].y temp
        rand temp 2048
        inv temp
        add temp sprite[].z
        seta[].z temp
        set temp sprite[].sectnum
        updatesector sprite[].x sprite[].y temp
        ifn temp -1
            seta[].sectnum temp
        set counter 1
        ifrnd 127
            inv counter
        cstat 32768
    }
    else
    {
        ifrnd 96
        {
            rand temp sprite.xrepeat
            shiftr temp 1
            add temp sprite.xrepeat
            shiftr temp 2
            add temp 2
            shiftl temp 5
            ife counter -1
                inv temp
            seta .zvel temp
        }
        else
        {
            geta .zvel temp
            shiftr temp 1
            seta .zvel temp
        }
        rand temp sprite.yrepeat
        shiftr temp 1
        add temp sprite.yrepeat
        shiftl temp 2
        add temp 64
        shiftr temp 1
        ifg debris_add_vel 1
            add temp debris_add_vel
        inv temp
        seta .xvel temp
        
        set move_v temp
        state move_actor
        movesprite THISACTOR move_xv move_yv sprite.zvel 0 temp
        ifg temp 32767 ifl temp 49152
            add counter3 1
        geta .xrepeat temp
        add temp sprite.yrepeat
        ssp THISACTOR CLIPMASK0
        
        cstat 130
    }
    ifceilingdistl 4
    {
        seta[].xrepeat 0
        seta[].yrepeat 0
        seta[].statnum STAT_ACTOR
    }
    iffloordistl 4
    {
        seta[].xrepeat 0
        seta[].yrepeat 0
        seta[].statnum STAT_ACTOR
    }
    ifg counter3 1
    {
        seta[].xrepeat 0
        seta[].yrepeat 0
        seta[].statnum STAT_ACTOR
    }
ends

defstate spawn_bloodsplatter
    espawn A_SOUND_EMITTER
    seta[RETURN].extra SE_DIST_BLOOD // read distance
    seta[RETURN].xrepeat 64
    seta[RETURN].yrepeat 64
    seta[RETURN].cstat 32768
    add particle_spawned 1

    geta[].sectnum temp2


    geta[].z temp2
    add temp2 -1024
    getzrange sprite [].x sprite [].y temp2 sprite[].sectnum temp4 temp5 temp6 temp7 64 2097152

    ifand temp7 32768
        ifand temp7 16384
            break

    spawn A_DROP

    findnearsprite A_GENERIC_BLOODSPLATTER 192 temp2
    ifn temp2 -1
        break

    set temp5 tainted[sprite [].sectnum]

    ife temp5 0
    {
        espawn A_GENERIC_BLOODSPLATTER

        set temp sprite[].sectnum
        set temp3 0
        iffloordistl 1
            gets[temp].floorpicnum surface_type
        else ifceilingdistl 1
        {
            gets[temp].ceilingpicnum surface_type
            set temp3 1
        }

        ife temp3 1
        {
            getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp3
            seta[RETURN].z temp3
            set temp2 sector[temp].ceilingshade
            add temp2 7
        }
        else
        {
            getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp3
            seta[RETURN].z temp3
            set temp2 sector[temp].floorshade
            add temp2 7
        }

            seta[RETURN].shade temp2

        rand temp2 18

        ife sprite[].statnum STAT_PROJECTILE
            clamp temp2 4 10
        else clamp temp2 5 18

        seta[RETURN].xrepeat temp2
        seta[RETURN].yrepeat temp2

        set temp3 tilesizx[sprite[RETURN].picnum]
        mul temp3 temp2
        shiftr temp3 2
        set move_v temp3
        state move_actor
        set temp2 0
        set temp6 0

        for temp6 range 5
        {
            set temp3 move_xv
            set temp4 move_yv
            geta[].ang temp5

            set temp7 temp6
            shiftl temp7 9
            add temp7 256
            add temp5 temp7

            and temp5 2047

            cos move_xv temp5
            sin move_yv temp5

            mul move_xv move_v
            mul move_yv move_v

            shiftr move_xv 14
            shiftr move_yv 14

            add move_xv sprite[].x
            add move_yv sprite[].y

            set temp5 sprite[].sectnum
            updatesector move_xv move_yv temp5

            ife temp5 sprite[].sectnum
                add temp2 1
            else ifn temp5 -1
            {
                ife sector[temp5].floorz sector[sprite[].sectnum].floorz
                    ife sector[temp5].floorslope sector[sprite[].sectnum].floorslope
                        add temp2 1
            }

            ifge temp6 4
                ifl temp2 4
            {
                geta[RETURN].xrepeat temp3
                shiftr temp3 1
                ife temp3 0
                {
                    seta[RETURN].xrepeat 6
                    seta[RETURN].yrepeat 6
                    set temp2 4
                }
                else
                {
                    seta[RETURN].xrepeat temp3
                    seta[RETURN].yrepeat temp3

                    set temp4 tilesizx[sprite[RETURN].picnum]
                    mul temp4 temp3
                    shiftr temp4 2

                    set move_v temp4
                    set temp6 0

                    ife temp2 0
                    {
                        seta[RETURN].xrepeat 6
                        seta[RETURN].yrepeat 6
                        set temp2 4
                    }
                }
            }
        }

        set temp3 32
        ifrnd 128 or temp3 4
        ifrnd 128 or temp3 8
        or temp3 32768
        seta[RETURN].cstat temp3
    }
ends

// 6895
defstate blood_particle
    ife counter 0
    {
        set temp 6
        seta[].xrepeat temp
        seta[].yrepeat temp
        seta[].shade -127
        geta[].ang temp
        rand temp2 480
        ifrnd 127
            inv temp2
        add temp temp2
        add temp 1024
        and temp 2047
        seta[].ang temp
        spritepal 10

        rand particle1 40
        add particle1 70


            geta[].z temp
            add temp 1536
            seta[].z temp
    }

        fall

    add counter 1 // keep this incrementing case we need it later for additional effects

    set temp2 counter
    cstat 130
    and temp2 6

    set temp2 counter
    mod temp2 16

    ifg temp2 3 ifl temp2 8
        cstator 4
    ifg temp2 7 ifl temp2 12
        cstator 12
    ifg temp2 11
        cstator 8

    ifg counter 20
    {
        seta[].xrepeat 0
        seta[].statnum STAT_ACTOR
        break
    }

    set temp2 counter
    mod temp2 4

    ifspawnedby P_BLOOD
        nullop
    else ife temp2 3
    {
        espawn A_GENERIC_BLOODSPLAT
        seta[RETURN].xrepeat 4
        seta[RETURN].yrepeat 4
        seta[RETURN].cstat 32768
    }

    iffloordistl 1
    {
        shiftr particle2 1
        shiftr particle1 1
    }

    set move_v particle1
    state move_actor
    clipdist 1
    movesprite THISACTOR move_xv move_yv particle2 CLIPMASK0 temp
    mul particle2 10
    div particle2 11
    add particle2 GRAVITATIONALCONSTANT

    set temp2 counter
    mod temp2 5
    ifl sprite[].xrepeat 18 ifg counter 1 ifl particle_spawned 1
    {
        set temp3 0
        iffloordistl 1
            set temp3 1
        else ifceilingdistl 1
            set temp3 1
        ife temp3 1 ife temp2 0
            state spawn_bloodsplatter
        else ifn temp 0
        {
            ifg temp 49151
                nullop
            else ifg temp 32767
            {
                sub temp 32768
                espawn A_SOUND_EMITTER
                seta[RETURN].extra SE_DIST_BLOOD // read distance
                seta[RETURN].xrepeat 64
                seta[RETURN].yrepeat 64
                seta[RETURN].cstat 32768
                add particle_spawned 1
                geta[].sectnum temp2
                set temp5 tainted[temp2]
                getw[temp].nextsector temp2
                ifn temp2 -1
                {
                    set temp6 tainted[temp2]
                    add temp5 temp6
                }

                // gobblydeegook
                getw[temp].nextsector temp3


                ifn temp3 -1 ifl sprite[].z sector[temp3].floorz ifg sprite[].z sector[temp3].ceilingz
                {
                    ifand wall[temp].cstat 16
                        set temp2 1
                    ifand wall[temp].cstat 32
                        set temp2 1
                    ife temp2 1 // if this wall has a maskwall
                    {
                        // this trick lets us determine if we're in between the ceiling and floor
                        // and should be in the masked area
                        ifl sprite[].z sector[temp3].floorz ifg sprite[].z sector[temp3].ceilingz
                            nullop
                        else
                            set temp5 1
                    }
                    else
                        set temp5 1
                }
                ife temp5 0
                {
                    geta [].z temp2
                    add temp2 -1024

                    spawn A_DROP

                    findnearsprite3d A_GENERIC_BLOODSPLATTER 192 temp2
                    ifn temp2 -1
                        break
                    
                    espawn A_GENERIC_BLOODSPLATTER

                    set temp7 wall[temp].shade
                    add temp7 7
                    seta[RETURN].shade temp7

                    // get the angle of a wall, rotated by 90 degrees to be the proper surface
                    getw[temp].x temp2
                    getw[temp].y temp3
                    getw[temp].point2 temp4
                    getw[temp4].x temp5
                    getw[temp4].y temp6
                    sub temp2 temp5
                    sub temp3 temp6
                    getangle temp5 temp2 temp3
                    add temp5 1536
                    and temp5 2047
                    seta[RETURN].ang temp5

                    rand temp2 14
                    clamp temp2 7 14

                    seta[RETURN].xrepeat temp2
                    seta[RETURN].yrepeat temp2
                    set temp4 tilesizy[8428] // currently hardcoded by us, change this later?

                   // basic formula: (sizy*256)/64 = base value then mul yrepeat for game topZ
                   // simplified to sizy*4*yrepeat
                    shiftl temp4 2

                    mul temp4 temp2
                    shiftr temp4 3 // adjust this as necessary IMO. How much leeway we give.

                    getw[temp].nextsector temp3

                    geta[].z temp5
                    sub temp5 temp4
                    geta[].z temp6
                    add temp6 temp4
                    ifn temp3 -1 ifl temp5 sector[temp3].floorz ifg temp6 sector[temp3].ceilingz
                    {
                        /* setp[myconnectindex].pals 2 30 // check if we're firing this fucking thing
                        setp[myconnectindex].pals_time 30 */
                        ifand wall[temp].cstat 16
                            set temp2 1
                        ifand wall[temp].cstat 32
                            set temp2 1
                        ife temp2 1 // if this wall has a maskwall
                        {
                            // this trick lets us determine if we're in between the ceiling and floor
                            // and should be in the masked area
                            // IS THIS REDUNDANT????
                            ifl temp5 sector[temp3].floorz ifg temp6 sector[temp3].ceilingz
                                nullop
                            else // delete this shit
                            {
                                seta[RETURN].xrepeat 0
                                seta[RETURN].yrepeat 0
                                seta[RETURN].statnum STAT_ACTOR
                            }
                        }
                        else
                        {
                            seta[RETURN].xrepeat 0
                            seta[RETURN].yrepeat 0
                            seta[RETURN].statnum STAT_ACTOR
                        }
                    }
                    set temp2 144
                    ifrnd 128 or temp2 4
                    ifrnd 128 or temp2 8
                    or temp2 32768
                    seta[RETURN].cstat temp2
                }
            }
        }
    }
    ife particle_spawned 1
    {
        seta[].xrepeat 0
        seta[].statnum STAT_ACTOR
    }
ends

eventloadactor A_GENERIC_BLOODSPLATTER
    cstat 32768
enda

spritenopal A_GENERIC_BLOODSPLATTER
spritenoshade A_GENERIC_BLOODSPLATTER

action AC_BLOODSPLATTER1 1528 1 1 1 1
action AC_BLOODSPLATTER2 1529 1 1 1 1
action AC_BLOODSPLATTER3 1530 1 1 1 1
action AC_BLOODSPLATTER4 1531 1 1 1 1
action AC_BLOODSPLATTER5 1532 1 1 1 1
action AC_BLOODSPLATTER6 1533 1 1 1 1
action AC_BLOODSPLATTER7 1534 1 1 1 1

action AC_BLOODSPLATTERW1 5084 6 1 1 16
action AC_BLOODSPLATTERW2 5092 6 1 1 16
action AC_BLOODSPLATTERW3 5100 6 1 1 16
action AC_BLOODSPLATTERW4 5108 6 1 1 16

appendevent EVENT_EGS
    ifactor A_GENERIC_BLOODSPLATTER
        geta[].owner tp_owner
endevent
useractor notenemy A_GENERIC_BLOODSPLATTER
    ifaction 0
    {
        ife tp_owner -1
        {
            cstator 2
            setactor[].blend 130
            setactor[].shade -32
            changespritestat THISACTOR STAT_BULLETHOLE
        }
        geta[].htflags temp
        or temp 2048
        seta[].htflags temp

        geta[].xrepeat se_xvel
        geta[].yrepeat se_yvel

        ife se_xvel 0
            ife se_yvel 0
                killit

        geta[].cstat temp4
        ifand temp4 32768
        {
            xor temp4 32768
            seta[].cstat temp4
        }
        else
        {
            ifand tiledata[sprite[temp].picnum].gameflags 32
                nullop
            else ifge sprite[].htpicnum 0
            {
                ifn sprite[].htpicnum sprite[].picnum
                    set se_yvel 7
            }
        }
        ifand sprite.cstat 32
        {
            getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp2
            add temp2 1024
            ifl sprite.z temp2
                ifoutside
                {
                    set st_do_once 1
                    cstator 32768
                }
        }
        ifand temp4 16 // wall oriented
        {
            ifinwater
                set st_do_once 1
            rand temp 3
            switch temp
            {
                case 0 action AC_BLOODSPLATTERW1 break
                case 1 action AC_BLOODSPLATTERW2 break
                case 2 action AC_BLOODSPLATTERW3 break
                case 3 action AC_BLOODSPLATTERW4 break
            }
            endswitch
            ifand temp4 8
            {
                xor temp4 8
                seta .cstat temp4
            }
        }
        else
        {
            rand temp 6
            switch temp
            {
                case 0 action AC_BLOODSPLATTER2 break
                case 1 action AC_BLOODSPLATTER3 break
                case 2 action AC_BLOODSPLATTER4 break
                case 3 action AC_BLOODSPLATTER5 break
                case 4 action AC_BLOODSPLATTER6 break
                case 5 action AC_BLOODSPLATTER7 break
                case 6 action AC_BLOODSPLATTER1 break
            }
            endswitch
        }

        ife splat_noblend 0
        {
            cstator 2
            seta .blend 130
            seta .shade -32
        }
        ifand temp4 16
            set se_yvel 7

        ifge se_yvel 7
        {
            iffloordistl 1
            {
                ifonwater
                    set st_do_once 1
                else ifinwater
                    set st_do_once 1
            }
            set queued 1
            insertspriteq
            ifand temp4 16
                nullop
            else ife st_do_once 0
                changespritestat THISACTOR STAT_BULLETHOLE
        
        }
        break
    }

    ifg st_do_once 0
    {
        ifand sprite.cstat 16
            nullop
        else
        {
            geta .xrepeat temp
            ifand st_do_once 1
                add temp 1
            seta .xrepeat temp
        }
            geta .yrepeat temp
            ifand st_do_once 1
                add temp 1
            seta .yrepeat temp
        ife st_do_once 4
        {
            seta .blend 0
            seta .shade 25
            seta .pal 63
        }
        else ife st_do_once 8
        {
            seta .blend 0
            seta .shade 25
            seta .pal 63
            cstator 512
        }
        ife st_do_once 12
        {
            cstator 32768
            changespritestat THISACTOR STAT_BULLETHOLE
        }
        add st_do_once 1
    }
    ifand sprite.cstat 16
    {
        ifactioncount 5
            changespritestat THISACTOR STAT_BULLETHOLE
        break
    }

    ifactioncount 6
        cstator 512
    ifactioncount 9
        killit
enda

action AC_DROP 0 9 1 1 4
spritenoshade A_DROP
useractor notenemy A_DROP
    ifaction 0
    {
        getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
        ife sprite[].z temp
            sizeat 10 10
        else
            sizeat 6 8
        gets[].floorshade temp
        add temp 12
        clamp temp 0 29
        seta[].shade temp
        action AC_DROP
        ifrnd 128
            cstat 4
        else cstat 0

        spritepal 101

        cstator 2
    }

    randvar temp 10
    seta[].zvel -temp
    fall

    iffloordistl 1
    {
        spawn A_GENERIC_BLOODSPLAT
        killit
    }

    ifactioncount 9
    {
        spawn A_GENERIC_BLOODSPLAT
        killit
    }

enda

defstate bowlingbomb_trail
    ife counter 0
    {
        seta[].pal 3
        geta[].owner temp
        getav[temp].bbomb_move_v temp
        div temp 6
        ifg temp 48
            set temp 48
        ifl temp 26
            set temp 26
        geta[].owner temp2
        getav[temp2].counter temp2
            ife temp 2
                set temp 1
            ifl temp2 7
                shiftr temp 1
        seta[].xrepeat temp
        seta[].yrepeat 26
        seta[].cstat 642
    }
    add counter 1
    geta[].xrepeat temp
    ifg counter 10 ifg temp 10
        sub temp 1
    sub temp 1
    ifg temp 26
        sub temp 2
    ifl temp 3
        set temp 0
    seta[].xrepeat temp
    ifn temp 0
    {
        sub temp 3
        ifg temp 26
            set temp 26
    }
    seta[].yrepeat temp
    cstator 16
    espawn FRAMEEFFECT1

    geta[].x temp
    sub temp 1
    seta[RETURN].x temp
    geta[].y temp
    sub temp 1
    seta[RETURN].y temp
    geta[].z temp
    sub temp 1
    seta[RETURN].z temp
    geta[].ang temp2
    set temp temp2
    add temp 512
    and temp 2047
    seta[].ang temp
    geta[].owner temp
    getav[temp].bbomb_move_v temp
    ifl temp 24
        seta[].xvel temp
    ssp THISACTOR 0
    seta[].ang temp2
ends

defstate plasma_bolt_trail
    ife counter 0
    {
        set temp 10
        add temp particle_shift_repeat
        seta[].xrepeat temp
        seta[].yrepeat temp
        set temp 0
        add temp particle_shift_shade
        seta[].shade temp
        seta[].blend 255
        geta[].z temp
        sub temp 32
        seta[].z temp
        geta[].ang temp
        add temp 1024
        and temp 2047
        seta[].ang temp
        spritepal PAL_PLASMA_BOLT
        set particle1 8
    }

    add counter 1 // keep this incrementing case we need it later for additional effects

    geta[].xrepeat temp
    ifge counter 3
    {
        sub temp 1
        set counter 1
    }

    ifl temp 1
        set temp 0
    seta[].xrepeat temp
    seta[].yrepeat temp
    geta[].shade temp
    add temp 1
    clamp temp -127 64
    seta[].shade temp

    cstat 130

    iffloordistl 1
    {
        seta[].xrepeat 0
        seta[].statnum STAT_ACTOR
    }
ends

defstate plasma_bolt_explosion
    ife counter 0
    {
        rand temp 4
        add temp 8
        seta[].xrepeat temp
        seta[].yrepeat temp
        seta[].shade -127
        seta[].blend 129
        geta[].ang temp
        rand temp2 512
        ifrnd 127
            inv temp2
        add temp temp2
        add temp 1024
        and temp 2047
        seta[].ang temp
        spritepal PAL_PLASMA_BOLT

        rand particle2 256
        add particle2 256
        ifrnd 127
            inv particle2
        seta[].zvel particle2

        rand particle1 10
        add particle1 20

        iffloordistl 1
        {
            geta[].zvel particle2
            ifg particle2 0
                inv particle2
            seta[].zvel particle2
        }
    }

    seta[].xvel particle1
    shiftl particle1 7
    div particle1 127

    ssp THISACTOR 0

    add counter 1 // keep this incrementing case we need it later for additional effects

    geta[].xrepeat temp
    set temp2 counter

        sub temp 1
    ifl temp 1
        set temp 0
    seta[].xrepeat temp
    seta[].yrepeat temp

    geta[].zvel temp
    ifg temp 1024
        set temp 1024
    seta[].zvel temp

    geta[].shade temp
    set temp2 counter
    shiftl temp2 1
    add temp temp2
    seta[].shade temp
    ifg counter 1
        cstat 130

    ifg counter 5
        cstator 512
ends

defstate watersplash_wall
    ife counter 0
    {
        ifrnd 127
            break
        cstat 642
        sizeat 8 8
        ifrnd 63
            cstator 4
        cstator 8
        geta[].ang temp
        rand temp2 64
        ifrnd 127
            inv temp2
        add temp temp2
        and temp 2047
        seta[].ang temp
        add counter 1
        geta[].z temp
        add temp 256
        seta[].z temp
        seta[].blend 129
        seta[].shade 15
        geta .xrepeat temp
        ifg debris_add_size 0
            add temp debris_add_size
        clamp temp 2 255
        seta .xrepeat temp
    }

    geta[].xrepeat temp
    add temp 1
    seta[].xrepeat temp
    seta[].yrepeat temp

    geta[].shade temp
    ifl temp 30
        add temp 1
    seta[].shade temp

    rand temp -64
    sub temp 64
    seta[].xvel -10
    seta[].zvel temp
    ssp THISACTOR 0

    geta[].htg_t 2 temp2
    add temp2 1

    ifg temp2 0
    {
        set temp2 0
        geta[].htg_t 3 temp3

        add temp3 1
        ifge temp3 15
        {
            set temp3 0
            seta[].xrepeat 0
            seta[].statnum STAT_ACTOR
        }
        seta[].htg_t 3 temp3
    }
    seta[].htg_t 2 temp2
ends

defstate watersplash_floor
    ife counter 0
    {
        cstat 514
        sizeat 12 12
        ifceilingdistl 1
        {
            cstator 8
            geta[].z temp
            add temp 128
            ifinwater
                add temp 1728
            seta[].z temp
        }
        else
        {
            geta[].z temp
            add temp 128
            seta[].z temp
        }
        add counter 1
    }

    geta[].htg_t 2 temp2
    add temp2 1

    ifg temp2 0
    {
        set temp2 0
        geta[].htg_t 3 temp3

        add temp3 1
        ifge temp3 14
        {
            set temp3 0
            seta[].xrepeat 0
            seta[].statnum STAT_ACTOR
        }
        seta[].htg_t 3 temp3
    }
    seta[].htg_t 2 temp2
ends

defstate lightspark_flash
    ife counter 0
    {
        cstat 130
        seta[].blend 129
        seta[].shade -127
        sizeat 18 18
        add counter 1
    }
    geta[].xrepeat temp
    seta[].xrepeat temp
    seta[].yrepeat temp
    geta[].htg_t 2 temp2
    add temp2 1

    ifg temp2 0
    {
        set temp2 0
        geta[].htg_t 3 temp3

        add temp3 1
        ifge temp3 3
        {
            set temp3 0
            seta[].xrepeat 0
            seta[].statnum STAT_ACTOR
        }
        seta[].htg_t 3 temp3
    }
    seta[].htg_t 2 temp2
ends

defstate lightspark_spark
    ife counter 0
    {
        sizeat 18 18
        ifaction AC_LIGHTSPARK_SPARK_FC
        {
            cstat 2
            getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
            sub temp 1024

            ifg sprite[].z temp
                nullop
            else
                cstator 8
            sizeat 24 24
        }
        else
            cstat 130
        seta[].blend 129
        seta[].shade 5
        getplayer[].i att_target
        set att_noclamp 1
        state angle_to_target
        ifg att_return -64 ifl att_return 64
        {
            ifrnd 127
                cstator 4
        }
        else ifl att_return 0
        {
                cstator 4
        }
        add counter 1
    }
    ifaction AC_LIGHTSPARK_SPARK_FC ifand sprite[].cstat 8
    {
        getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp
        set temp2 sprite[].xrepeat
        mul temp2 224
        add temp temp2
        seta[].z temp
    }
    geta[].shade temp
    add temp 1
    seta[].shade temp
    geta[].htg_t 2 temp2
    add temp2 1

    ifg temp2 0
    {
        set temp2 0
        geta[].htg_t 3 temp3

        add temp3 1
        ifge temp3 10
        {
            set temp3 0
            seta[].xrepeat 0
            seta[].statnum STAT_ACTOR
        }
        seta[].htg_t 3 temp3
    }
    seta[].htg_t 2 temp2
ends


var plasma_trail_temp

appendevent EVENT_SPAWN
    ifactor A_GENERIC_PARTICLE ifspawnedby P_PLASMA_BOLT
    {
        getav[sprite[].htowner].particle_force_pal plasma_trail_temp
        ifg plasma_trail_temp 0
            ifle particle_force_pal 0
                set particle_force_pal plasma_trail_temp
        getav[sprite[].htowner].particle_ignore_distance plasma_trail_temp
        ifg plasma_trail_temp 0
            ifle particle_ignore_distance 0
                set particle_ignore_distance plasma_trail_temp
    }
endevent
useractor notenemy A_GENERIC_PARTICLE
    geta[].htflags temp
    or temp 2048
    seta[].htflags temp
    sleeptime 300
    changespritestat THISACTOR 201
enda

var part_temp
var first_yvel 0 2

action AC_GIB_IDLE 0 1 1 1 1
var gib_saveframe 0 2
defstate gib_proj_code
    setu[].vm_sprite temp
    ife counter 0
    {

        ifn sprite[].picnum P_GIB_ARM
        {
            ifn sprite[].picnum P_GIB_LEG_LS
            {
                ifn sprite[].picnum P_GIB_LEG_GR
                {
                    cstat 0
                    ifrnd 127
                        cstator 4
                }
            }
        }
        ifrnd 127
            cstator 8
        geta[].yvel last_yvel
        set counter 2
        ifn sprite.blend 0
            cstator 2
    }
    ifn sprite[].yvel last_yvel
    {
        geta[].ang temp3
        rand temp4 64
        ifrnd 127
            inv temp4
        add temp3 temp4
        seta[].ang temp3
        geta[].yvel last_yvel
        geta[].zvel temp4
        ifl temp4 0
        {
            set temp3 0
            switch sprite[].picnum
                case P_GIB_SKULL
                case P_GIB_SKULL_LS
                case P_GIB_SKULL_GR
                    set temp3 1
                    break
            endswitch
            ife temp3 0
                shiftr temp4 1

            shiftr temp4 1
        }
        seta[].zvel temp4
        state spawn_bloodsplatter
    }
    ifactor P_GIB_EYE
        nullop
    else ifactor P_GIB_LEG_SECT
        nullop
    else
    {
        ifactor P_GIB_MEAT
        {
            ife sprite.blend 255
            {
                ifand sprite.htg_t 2 2
                    spawn A_SMOKE2
            }
        }
        ife sprite[].yvel 0
        {
            action AC_GIB_IDLE
            set counter 0
            set temp3 0
            switch sprite[].picnum
                case P_GIB_SKULL
                case P_GIB_SKULL_LS
                case P_GIB_SKULL_GR
                    set temp3 1
                    break
                case P_GIB_SPINE
                    geta[].cstat temp4
                    ifand temp4 8
                    {
                        xor temp4 8
                        seta[].cstat temp4
                    }
                    set gib_saveframe 10
                    break
                case P_GIB_CHUNK1
                    geta[].cstat temp4
                    ifand temp4 8
                    {
                        xor temp4 8
                        seta[].cstat temp4
                    }
                    set gib_saveframe 12
                    break
                case P_GIB_INTESTINE
                case P_GIB_MEAT
                case P_GIB_LUNG
                case P_GIB_LIVER
                case P_GIB_CHUNK2
                case P_GIB_HEART
                case P_GIB_EYE
                    geta[].cstat temp4
                    ifand temp4 8
                    {
                        xor temp4 8
                        seta[].cstat temp4
                    }
                    set gib_saveframe 8
                    ifand sprite.cstat 2
                    {
                        ifspritepal 63
                            spritepal 0
                    }
                    break
            endswitch
            ife temp3 0
                sound S_GIBDROP01

            changespritestat THISACTOR STAT_ACTOR
        }
        else
        {
            ifactor P_GIB_SKULL
            {
                geta[].htg_t 3 temp4
                switch temp4
                    case 0
                    case 3
                    case 5
                    case 7
                        set gib_saveframe temp4
                        break
                    case 10
                        set gib_saveframe 0
                        break
                endswitch
            }
            else ifactor P_GIB_SKULL_LS
            {
                geta[].htg_t 3 temp4
                switch temp4
                    case 0
                    case 4
                    case 8
                    case 9
                        set gib_saveframe temp4
                        break
                    case 10
                        set gib_saveframe 48
                        break
                endswitch
            }
            else ifactor P_GIB_SKULL_GR
            {
                geta[].htg_t 3 temp4
                switch temp4
                    case 0
                    case 4
                    case 5
                    case 6
                    case 9
                        set gib_saveframe temp4
                        break
                    case 10
                        set gib_saveframe 39
                        break
                endswitch
            }
            else ifactor P_GIB_ARM
            {
                geta[].htg_t 3 temp4
                switch temp4
                    case 4
                        set gib_saveframe temp4
                        break
                    default
                        set gib_saveframe 18
                        break
                endswitch
            }
            else ifactor P_GIB_LEG_LS
            {
                geta[].htg_t 3 temp4
                switch temp4
                    case 2
                        set gib_saveframe temp4
                        break
                    default
                        set gib_saveframe 25
                        break
                endswitch
            }
            else ifactor P_GIB_LEG_GR
            {
                geta[].htg_t 3 temp4
                switch temp4
                    case 0
                    case 5
                        set gib_saveframe temp4
                        break
                    default
                        set gib_saveframe 11
                        break
                endswitch
            }
        }
    }
ends

defstate smoke_action_select
    switch sprite[].xrepeat
    {
        case 129
            action AC_BULLETSPARK
            seta [].blend 129
            break
        case 128
            action AC_PLASMA_BOLTEXPLOSION
            break
        case 127
            action AC_FIREBALLEXPLOSION
            break
        case 126
            action AC_BLOODPARTICLE
            break
        case 125
            action AC_WATERSPLASH_WALL
            break
        case 124
            action AC_WATERSPLASH_FLOOR
            break
        case 123
            action AC_LIGHTSPARK_FLASH
            break
        case 122
            action AC_LIGHTSPARK_SPARK
            break
        case 121
            action AC_LIGHTSPARK_SPARK_FC
            break
        case 120
            action AC_LIGHTSPARK_SPARK_SP
            break
        case 119
            action AC_BUBBLEBOBBLE
            break
        case 118
            action AC_BUBBLEBOBBLE2
            break
    }
    endswitch
ends

defstate spark_action_select
    switch sprite[].xrepeat
    {
        case 127
            action AC_BULLETSPARK
            break
        case 126
            action AC_BLOODPARTICLE
            break
        case 125
            action AC_WATERSPLASH_WALL
            break
        case 124
            action AC_WATERSPLASH_FLOOR
            break
        case 123
            action AC_LIGHTSPARK_FLASH
            break
        case 122
            action AC_LIGHTSPARK_SPARK
            break
        case 121
            action AC_LIGHTSPARK_SPARK_FC
            break
        case 120
            action AC_LIGHTSPARK_SPARK_SP
            break
        case 119
            action AC_BUBBLEBOBBLE
            break
        case 118
            action AC_BUBBLEBOBBLE2
            break
    }
    endswitch
ends

defstate particle_action_select
    switch particle_type
        case PARTICLE_TYPE_FIREBALL_TRAIL
            state fireball_trail
            break
        case PARTICLE_TYPE_PLASMA_TRAIL
            state plasma_bolt_trail
            break
        case PARTICLE_TYPE_FIREBALL_EXPLOSION
            action AC_FIREBALLEXPLOSION
            break
        case PARTICLE_TYPE_PLASMA_EXPLOSION
            action AC_PLASMA_BOLTEXPLOSION
            break
        case PARTICLE_TYPE_BULLET_TRAIL
            action AC_BULLETTRAIL
            break
        case PARTICLE_TYPE_BOWLINGBOMB_TRAIL
            action AC_BOWLINGBOMBTRAIL
            break
        case PARTICLE_TYPE_WATERSPLASH_FLOOR
            action AC_WATERSPLASH_FLOOR
            break
        case PARTICLE_TYPE_WATERSPLASH_WALL
            action AC_WATERSPLASH_WALL
            break
        case PARTICLE_TYPE_LIGHTSPARK_FLASH
            action AC_LIGHTSPARK_FLASH
            break
        case PARTICLE_TYPE_LIGHTSPARK_SPARK
            action AC_LIGHTSPARK_SPARK
            break
        case PARTICLE_TYPE_LIGHTSPARK_FC
            action AC_LIGHTSPARK_SPARK_FC
            break
        case PARTICLE_TYPE_LIGHTSPARK_SP
            action AC_LIGHTSPARK_SPARK_SP
            break
        case PARTICLE_TYPE_BUBBLE
            action AC_BUBBLEBOBBLE
            break
        case PARTICLE_TYPE_BUBBLE2
            action AC_BUBBLEBOBBLE2
            break
        default
            state bullet_spark
            break
    endswitch
ends

defstate default_action_select
    switch sprite[].xrepeat
    {
        case 129:
            action AC_BULLETSPARK
            break
        case 128:
            action AC_PLASMA_BOLTEXPLOSION
            break
        case 127:
            action AC_FIREBALLEXPLOSION
            break
        case 126:
            action AC_BLOODPARTICLE
            break
        case 125:
            action AC_WATERSPLASH_WALL
            break
        case 124:
            action AC_WATERSPLASH_FLOOR
            break
        case 123:
            action AC_LIGHTSPARK_FLASH
            break
        case 122:
            action AC_LIGHTSPARK_SPARK
            break
        case 121:
            action AC_LIGHTSPARK_SPARK_FC
            break
        case 120:
            action AC_LIGHTSPARK_SPARK_SP
            break
        case 119:
            action AC_BUBBLEBOBBLE
            break
        case 118
            action AC_BUBBLEBOBBLE2
            break
    }
    endswitch
ends

appendevent EVENT_WORLD
    for part_temp sprofstat STAT_GENERIC_PARTICLE
    {
        setu[].vm_sprite part_temp
        setu[].vm_player myconnectindex
        dist temp THISACTOR player[].i
        setu[].vm_distance temp

        set temp2 tilesizx[sprite[].picnum]
        mul temp2 sprite[].xrepeat
        shiftl temp2 7

        ifn particle_ignore_distance 1
            ifg temp temp2
            {
                seta[].xrepeat 0
                seta[].statnum STAT_ACTOR
            }
        ife sprite.xrepeat 0
            changespritestat THISACTOR STAT_ACTOR
        else
        {
            ifn sprite[].xrepeat 0
            {
                switch sprite[].htpicnum
                {
                    case P_FIREBALL
                        state fireball_trail
                        break
                    case P_PLASMA_BOLT
                        ifaction 0
                            action AC_PLASMA_BOLT_TRAIL
                        state plasma_bolt_trail
                        break
                    case A_SMOKE1
                        state smoke_action_select
                        break
                    case A_SPARK1
                        state spark_action_select
                        break
                    case P_BOWLINGBOMB
                        geta[].xrepeat temp
                        ife temp 127
                            action AC_BOWLINGBOMBTRAIL
                        else ife temp 126
                            action AC_WATERSPLASH_FLOOR
                        else ife temp 129
                            action AC_BULLETSPARK
                        break
                    case A_PARTICLE_SPAWNER
                        ifaction 0
                            state particle_action_select
                        break
                    default
                        ife sprite[].xrepeat 127
                            action AC_BULLETTRAIL
                        else ife sprite[].xrepeat 126 // ifspawnedby P_BLOOD
                            action AC_BLOODPARTICLE
                        else
                            state default_action_select
                        break
                }
                endswitch
            }

            switch sprite [].htg_t 4
            {
                case AC_FIREBALLEXPLOSION:
                    state fireball_explosion
                    break
                case AC_BULLETTRAIL:
                    state bullet_trail
                    break
                case AC_BULLETSPARK:
                    state bullet_spark
                    break
                case AC_BLOODPARTICLE:
                    state blood_particle
                    break
                case AC_BOWLINGBOMBTRAIL:
                    state bowlingbomb_trail
                    break
                case AC_PLASMA_BOLTEXPLOSION:
                    state plasma_bolt_explosion
                    break
                case AC_WATERSPLASH_WALL:
                    state watersplash_wall
                    break
                case AC_WATERSPLASH_FLOOR:
                    state watersplash_floor
                    break
                case AC_LIGHTSPARK_FLASH:
                    state lightspark_flash
                    break
                case AC_LIGHTSPARK_SPARK:
                case AC_LIGHTSPARK_SPARK_FC:
                case AC_LIGHTSPARK_SPARK_SP:
                    state lightspark_spark
                    break
                case AC_BUBBLEBOBBLE:
                    state bubble_rise
                    break
                case AC_BUBBLEBOBBLE2:
                    state bubble_spray
                    break
            }
            endswitch

            ifspawnedby P_BLOOD
                cstat 32768
            ife sector[].floorz sector[].ceilingz
            {
                seta[].xrepeat 0
                seta[].statnum STAT_ACTOR
            }
            ifn particle_force_pal 0
                seta[].pal particle_force_pal
            ifn particle_force_shade 0
                seta[].shade particle_force_shade
            switch sprite [].htg_t 4
            {
                case AC_BUBBLEBOBBLE:
                case AC_BUBBLEBOBBLE2:
                    break
            }
            endswitch
            
            ifaction AC_BLOODPARTICLE
                nullop
            else
            {
                geta[].htflags temp3
                or temp3 2048
                seta[].htflags temp3
            }

            ife sprite[].xrepeat 0
                changespritestat THISACTOR STAT_ACTOR
        }
    }

    for temp sprofstat STAT_STANDABLE
    {
        ife sprite[temp].picnum A_EXPLOSION_FX
        {
            setu[].vm_sprite temp
            ife st_do_once 0
            {
                ife sprite[].lotag 0
                    seta[].lotag 1
                set st_do_once 1
                geta .lotag se_lotag
                geta .yvel se_yvel
                geta .z se_zvel
            }
            ifg se_yvel 0
            {
                setu .vm_player myconnectindex
                /* redefinequote 11 %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld
            qsprintf 11 11 sprite[].xvel sprite[].yvel sprite.zvel sprite.shade sprite.extra sprite[].hitag sprite.lotag sprite.htg_t 0 sprite.htg_t 1 sprite.htg_t 2 sprite.htg_t 3 sprite.htg_t 4
            quote 11 */
                ifand se_yvel 1
                {
                    ife sprite.htg_t 3 0
                    {
                        ifg sprite.hitag 0
                        {
                            ife activateshit[sprite.hitag] 1
                            {
                                seta .htg_t 3 1
                                seta .shade -32
                                ifle sprite.lotag 1
                                    seta .lotag -99
                            }
                        }
                    }
                }
            }
            ifl sprite[temp].lotag 0
            {
                geta[temp].xrepeat temp2
                shiftl temp2 1
                ifl temp2 16
                    rand temp3 3
                else
                    rand temp3 7
                ifrnd 127
                    inv temp3
                add temp2 temp3
                clamp temp2 4 255

                ifn sprite[temp].pal 9 ifn sprite[temp].pal 10 ifn sprite[temp].pal 11
                {
                    set temp3 temp2
                    shiftl temp3 5
                    ifg se_xvel 1
                    {
                        switch se_xvel
                            case 2
                                hitradiusvar temp3 10 20 40 80
                                break
                            case 3
                                hitradiusvar temp3 15 30 60 120
                                break
                            case 4
                                hitradiusvar temp3 20 40 80 160
                                break
                            case 5
                                hitradiusvar temp3 25 50 100 200
                                break
                            case 6
                                hitradiusvar temp3 30 60 120 240
                                break
                            case 7
                                hitradiusvar temp3 35 70 140 280
                                break
                            case 8
                                hitradiusvar temp3 40 80 160 320
                                break
                            case 9
                                hitradiusvar temp3 45 90 180 360
                                break
                            case 10
                                hitradiusvar temp3 50 100 200 400
                                break
                            default
                                hitradiusvar temp3 100 200 400 800
                                break
                        endswitch
                    }
                    else
                        hitradiusvar temp3 5 10 20 40
                }

                ifn sprite[temp].pal 1
                {
                    espawn A_EXPLOSION
                    ife sprite[temp].pal 10
                        setav[RETURN].explosion_silent 1
                    else ife sprite[temp].pal 11
                        setav[RETURN].explosion_silent 2
                    ifand se_yvel 4
                        setav[RETURN].explosion_nospark 1
                    ifand se_yvel 8
                        setav[RETURN].explosion_nosmoke 1
                    seta[RETURN].xrepeat temp2
                    seta[RETURN].yrepeat temp2
                    geta[temp].z temp3
                    shiftl temp2 6
                    sub temp3 temp2
                    set temp4 temp2
                    shiftl temp4 2
                    seta[temp].z temp3
                    setav[RETURN].smoke_offset temp4
                    seta[RETURN].cstat 32770
                    seta[RETURN].shade -127
                    seta[RETURN].blend 129
                }
                ifg se_yvel 0
                {
                    ifand se_yvel 2
                    {
                        seta .lotag se_lotag
                        seta .htg_t 3 0
                        seta .shade -16
                        seta .z se_zvel
                    }
                    else
                        seta[temp].picnum A_EXPLOSION_RELAY
                }
                else
                    seta[temp].picnum A_EXPLOSION_RELAY
            }
        }
    }
    resizearray nades 0
    resizearray nades 16384
    set num_nades 0
    for temp sprofstat STAT_PROJECTILE
    {
        state weapon_projectiles
        switch sprite[temp].picnum
        {
			case 2595:
                seta[temp].xrepeat 0
                changespritestat temp STAT_ACTOR
                break
            case P_GIB_SKULL:
            case P_GIB_SKULL_LS:
            case P_GIB_SKULL_GR:
            case P_GIB_CHUNK1:
            case P_GIB_MEAT:
            case P_GIB_CHUNK2:
            case P_GIB_EYE:
            case P_GIB_ARM:
            case P_GIB_LEG_LS:
            case P_GIB_LEG_GR:
            case P_GIB_LEG_SECT:
                state gib_proj_code
                break
            case P_EXPLOSION_SPARK:
                setu [].vm_sprite temp
                ife counter 0
                {
                    set counter 1
                    ifoutside
                        ifceilingdistl 4
                            seta .yvel 2
                }
                ifl sprite.zvel -4096
                {
                    geta .zvel temp2
                    add temp2 256
                    seta .zvel temp2
                }
                ifg sprite.xvel 0
                {
                    geta .xvel temp2
                    sub temp2 1
                    seta .xvel temp2
                }
                break
            case A_COIN1:
            {
                setu [].vm_sprite temp
                ife counter 1
                    cstat 128
                else
                    set counter 1
                break
            }
            case A_SHELL1:
            {
                setu [].vm_sprite temp
                setu [].vm_player myconnectindex
                ifspawnedby APLAYER
                {
                    ife se_ang 0
                    {
                        geta[].x se_xvel
                        sub se_xvel player[].posx
                        geta[].y se_yvel
                        sub se_yvel player[].posy
                        set se_ang 1
                    }
                    else ifl se_ang 2
                    {
                        getp[].posx temp3
                        add temp3 se_xvel
                        seta[].x temp3
                        getp[].posy temp3
                        add temp3 se_yvel
                        seta[].y temp3
                        add se_ang 1
                    }
                }
                ife shell_shot 1
                {
                    seta[].xrepeat 8
                    seta[].yrepeat 8
                    spritepal 62
                }
                ife counter 0
                {
                    ife shell_smg 0
                    {
                        geta [].ang temp3
                        sub temp3 256
                        rand temp4 64
                        ifrnd 127
                            inv temp4
                        add temp3 temp4
                        seta [].ang temp3
                    }
                    else
                    {
                        geta[].htflags temp3
                        or temp3 2048
                        seta[].htflags temp3
                    }
                        geta [].zvel temp3
                        rand temp4 32
                        ifrnd 127
                            inv temp4
                        add temp3 temp4
                        seta [].zvel temp3

                    geta [].yvel last_yvel
                    rand temp3 3
                    add last_yvel temp3
                    seta [].yvel last_yvel
                    set first_yvel last_yvel
                    set counter 2
                }

                ifl last_yvel first_yvel
                {
                    getp[].sound_pitch temp3
                    ife shell_shot 1
                        setp[].sound_pitch -480
                    rand temp2 5
                    add temp2 S_SHELL01
                    ldist temp4 player[myconnectindex].i THISACTOR
                    ifl temp4 8192
                        soundvar temp2
                    setp[].sound_pitch temp3
                    set first_yvel 0
                    set temp3 last_yvel
                    sub temp3 2
                    geta [].xvel temp4
                    add temp4 temp3
                    seta [].xvel temp4
                }

                ifn sprite [].yvel last_yvel
                {
                    geta [].ang temp3
                    rand temp4 64
                    ifrnd 127
                        inv temp4
                    add temp3 temp4
                    seta [].ang temp3
                    geta [].yvel last_yvel
                    geta [].zvel temp4
                    ifl temp4 0
                        shiftr temp4 1
                    seta [].zvel temp4
                    ifg shell_invisible 0
                        sub shell_invisible 1
                }

                ife sprite [].yvel 0
                {
                    action AC_SHELL_IDLE
                    set counter 0
                    set shell_invisible 0
                    cstat 0
                    changespritestat THISACTOR STAT_ACTOR
                }

                ldist temp2 temp player[].i

                ifg shell_invisible 0
                    sub shell_invisible 1
                else ifg temp2 256 // we don't want the projectile to spawn in the player's face
                    seta[temp].cstat 0

                break
            }
        }
        endswitch
    }

    for temp sprofstat STAT_CLIPBARRIER
    {
        ife sprite[temp].picnum A_LADDER
        {
            getav[temp].se_lotag temp3

            ifl temp3 0
            {
                abs temp3
                setav[temp].se_lotag temp3
                
                geta[temp].cstat temp2
                xor temp2 2048
                seta[temp].cstat temp2
                
                ife activateshit[temp3] 1
                {
                    geta[temp].cstat temp2
                    xor temp2 2048
                    seta[temp].cstat temp2
                }
            }
            else ifg temp3 0
            {
                ife activateshit[temp3] 1
                {
                    geta[temp].cstat temp2
                    xor temp2 2048
                    seta[temp].cstat temp2
                }
            }
        }
        else
        {
            getav[temp].se_hitag temp3

            ifg temp3 0
            {
                ife activateshit[temp3] 1
                {
                    ife sprite[temp].cstat 32768
                    {
                        getav[temp].st_do_once temp3
                        seta[temp].cstat temp3
                    }
                    else
                        seta[temp].cstat 32768

                }
                else
                {
                    ifand sprite[temp].cstat 1
                    {
                        getav[temp].st_do_once temp3
                        seta[temp].cstat temp3
                    }
                }
            }
            else ife temp3 0
            {
                ifand sprite[temp].cstat 1
                {
                    getav[temp].st_do_once temp3
                    seta[temp].cstat temp3
                }
            }
        }
    }
endevent

eventloadactor A_GENERIC_BLOODSPLAT
    ifspawnedby A_GENERIC_PARTICLE
    {
        sizeat 2 2
        cstat 32768
    }
    else
    {
        sizeat 64 64
        cstat 128
    }
enda

action AC_GENERIC_BLOODSPLAT 0 5 1 1 8
action AC_GENERIC_BLOODSPLAT2 1 4 1 1 8
action AC_GENERIC_BLOODSPLAT3 1718 6 1 1 8
action AC_GENERIC_BLOODSPLAT4 643 5 1 1 8
action AC_GENERIC_BLOODSPLAT5 658 5 1 1 8
defstate bloodsplat_byskull
    cstat 128

    ifrnd 128
        cstator 4

    ifrnd 128
        cstator 8

    sizeto 40 40
    action AC_GENERIC_BLOODSPLAT
    seta[].xrepeat 2
    seta[].yrepeat 2
    changespritestat THISACTOR 200
ends

spritenoshade A_GENERIC_BLOODSPLAT
appendevent EVENT_SPAWN
    ifactor A_GENERIC_BLOODSPLAT
        changespritestat THISACTOR STAT_BLOODSPLATHOST
endevent
useractor notenemy A_GENERIC_BLOODSPLAT
    changespritestat THISACTOR STAT_BLOODSPLATHOST
enda
appendevent EVENT_WORLD
for temp7 sprofstat STAT_BLOODSPLATHOST
{
    setu[].vm_sprite temp7
    ifaction 0
    {
        ifspawnedby A_GENERIC_PARTICLE
        {
            cstat 128
            sizeto 10 10
            action AC_GENERIC_BLOODSPLAT2
            fall
        }
        else ifspawnedby P_BLOOD
        {
            cstat 128
            action AC_GENERIC_BLOODSPLAT3
            seta[].xrepeat 6
            seta[].yrepeat 6
            set st_do_once 1
            changespritestat THISACTOR 200
        }
        else ifspawnedby P_GIB_SKULL
            state bloodsplat_byskull
        else ifspawnedby P_GIB_SKULL_LS
            state bloodsplat_byskull
        else ifspawnedby P_GIB_SKULL_GR
            state bloodsplat_byskull
        else
        {
            sizeto 100 100
            cstat 128
            ifrnd 64
                action AC_GENERIC_BLOODSPLAT5
            else ifrnd 64
                action AC_GENERIC_BLOODSPLAT4
            else
                action AC_GENERIC_BLOODSPLAT
            seta[].xrepeat 6
            seta[].yrepeat 6
            changespritestat THISACTOR 200
        }
    }

    set temp 9
    add temp sector[].floorshade
    ifg temp 14
        sub temp 4
    seta[].shade temp

    ifaction AC_GENERIC_BLOODSPLAT2 ifactioncount 3
    {
        seta[].xrepeat 0
        seta[].statnum STAT_ACTOR
    }
    else ifactioncount 5
    {
        seta[].xrepeat 0
        seta[].statnum STAT_ACTOR
    }
    ifg sprite[].xrepeat 0
    {
        geta[].htg_t 2 temp3

        add se_yvel 1
        ifg se_yvel 2
        {
            add temp3 1
            set se_yvel 0
            geta[].htg_t 3 temp4
            add temp4 1
            ifaction AC_GENERIC_BLOODSPLAT3
            {
                ifg temp4 6
                    set temp4 0
            }
            else ifg temp4 5
                set temp4 0
            seta[].htg_t 3 temp4
        }
        seta[].htg_t 2 temp3
    }
    ife sprite[].xrepeat 0
        changespritestat THISACTOR STAT_ACTOR
}
endevent

appendevent EVENT_WORLD
    for temp4 sprofstat STAT_BLOODSPLAT
    {
        setu[].vm_sprite temp4

        geta[].htflags temp
        or temp 2048
        seta[].htflags temp
        add counter 1
        ifg counter 10
        {
            seta[].xrepeat 0
            seta[].yrepeat 0
            seta[].statnum STAT_ACTOR
        }
        else ife counter 1
        {
                geta[].xrepeat temp
                add temp 4
                ife st_do_once 1
                {
                    rand temp 12
                    clamp temp 5 12
                }
                seta[].xrepeat temp
                seta[].yrepeat temp
        }

        geta[].htg_t 4 temp3
        geta[].htg_t 2 temp3
        add temp3 1

        ifg temp3 2
        {
            set temp3 0
            geta[].htg_t 3 temp4
            ife st_do_once 0
            {
                add temp4 1
                ifg temp4 4
                    set temp4 0
            }
            else
            {
                add temp4 1
                ifg temp4 5
                    set temp4 0
            }
            seta[].htg_t 3 temp4
        }
        seta[].htg_t 2 temp3

        ife sprite[].xrepeat 0
            changespritestat THISACTOR STAT_ACTOR
    }
endevent


// DEBRIS PIECES!!
spritenopal A_GENERIC_DEBRIS
eventloadactor A_GENERIC_DEBRIS
    cstat 32768
enda

action AC_DEBRIS_ROCK 0 1 1 1 1
action AC_DEBRIS_ROCK_SPIN 0 8 1 1 4

action AC_DEBRIS_GLASS 8 1 1 1 1
action AC_DEBRIS_GLASS_SPIN 8 8 1 1 4

action AC_DEBRIS_PIPE 16 1 1 1 1
action AC_DEBRIS_PIPE_SPIN 16 8 1 1 4

action AC_DEBRIS_WOOD 24 1 1 1 1
action AC_DEBRIS_WOOD_SPIN 24 8 1 1 4

action AC_DEBRIS_METAL 32 1 1 1 1
action AC_DEBRIS_METAL_SPIN 32 8 1 1 4

action AC_DEBRIS_STONE 40 1 1 1 1
action AC_DEBRIS_STONE_SPIN 40 8 1 1 4
action AC_DEBRIS_STONE2 982 1 1 1 1
action AC_DEBRIS_STONE2_SPIN 982 8 1 1 4
action AC_DEBRIS_STONE3 990 1 1 1 1
action AC_DEBRIS_STONE3_SPIN 990 8 1 1 4

action AC_DEBRIS_BRICK 54 1 1 1 1
action AC_DEBRIS_BRICK_SPIN 48 8 1 1 4

action AC_DEBRIS_CINDER 56 1 1 1 1
action AC_DEBRIS_CINDER_SPIN 56 8 1 1 4

action AC_DEBRIS_GRASS 958 1 1 1 1
action AC_DEBRIS_GRASS_SPIN 958 8 1 1 4

action AC_DEBRIS_FABRIC 966 1 1 1 1
action AC_DEBRIS_FABRIC_SPIN 966 8 1 1 4

action AC_DEBRIS_PLASTIC 979 1 1 1 1 // default frame was bleh, so breaking pattern
action AC_DEBRIS_PLASTIC_SPIN 974 8 1 1 4

defstate debris_shared_code
    cstat 0
    ifrnd 127
        cstator 4
    ifrnd 127
        cstator 8

    rand temp 4
    add temp 2
    ifg debris_add_size 0
        add temp debris_add_size
    clamp temp 2 255
    seta[].xrepeat temp
    seta[].yrepeat temp

    rand temp 256
    ifrnd 127
        inv temp
    add temp sprite[].ang
    and temp 2047
    seta[].ang temp

    rand temp 50
    add temp 30
    ifspawnedby A_GLASS_PANEL
        add temp 64
    else ifspawnedby A_GLASS_WINDOW_1
        add temp 64
    else ifspawnedby A_GLASS_WINDOW_2
        add temp 64
    ifg debris_add_vel 0
        add temp debris_add_vel
    seta[].xvel temp

    rand temp -768
    sub temp 768
    ifceilingdistl 1
    {
        shiftr temp 3
        inv temp
        geta[].z temp2
        add temp2 2048
        geta[].z temp2
    }
    seta[].zvel temp
ends

var debris_odd 0 2
var debris_got_slope 0 2

defstate get_debris_slope
    getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
    sub temp 512
    ifand sector[].floorstat 2 ifg sprite[].z temp
    {
        gets[].wallptr temp
        getw[temp].x temp2
        getw[temp].y temp3
        getw[temp].point2 temp4
        getw[temp4].x temp5
        getw[temp4].y temp6
        sub temp2 temp5
        sub temp3 temp6
        getangle temp temp2 temp3
        add temp 1536
        ifl sector[].floorslope 0
            add temp 1024
        rand temp2 128
        ifrnd 127
            inv temp2
        add temp temp2
        and temp 2047
        seta[].ang temp
        add debris_got_slope 1
    }
ends

var delete_debris 0 2
var debris_loop

appendevent EVENT_SPAWN
    ifactor A_GENERIC_DEBRIS
        changespritestat THISACTOR STAT_GENERIC_DEBRIS
endevent
useractor notenemy A_GENERIC_DEBRIS
    changespritestat THISACTOR STAT_GENERIC_DEBRIS
enda
var debris_skip 0 2
appendevent EVENT_WORLD
    for debris_loop sprofstat STAT_GENERIC_DEBRIS
    {
        setu[].vm_sprite debris_loop
        ife sprite[].xrepeat 0
            changespritestat THISACTOR STAT_ACTOR
        else ifg debris_skip 0
            sub debris_skip 1
        else
        {
            set debris_skip 0
            ife sprite[].xvel 0
                ife sprite[].zvel 0
                    set debris_skip 2
            
            set temp7 0
            geta[].htflags temp
            or temp 2048
            seta[].htflags temp
            fall
            clipdist 1
            iffloordistl 2 ifactioncount 4
            {
                geta[].zvel temp
                shiftr temp 2
                inv temp
                seta[].zvel temp
            }
            switch debris_type
                case DEBRIS_ROCK
                    ifaction 0
                    {
                        action AC_DEBRIS_ROCK_SPIN
                        state debris_shared_code
                        ifspawnedby A_TEACUP_1
                        {
                            rand temp 2
                            add temp 2
                            seta[].xrepeat temp
                            seta[].yrepeat temp
                        }
                        else ifspawnedby A_COFFEEMUG_1
                        {
                            rand temp 2
                            add temp 2
                            seta[].xrepeat temp
                            seta[].yrepeat temp
                        }
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_ROCK_SPIN ifactioncount 4
                        action AC_DEBRIS_ROCK
                    break
                case DEBRIS_GLASS
                    ifaction 0
                    {
                        action AC_DEBRIS_GLASS_SPIN
                        seta[].blend 129
                        state debris_shared_code
                        cstator 2
                        ifspawnedby A_SPARK1
                        {
                            gets[].floorshade temp
                            ifg temp particle_force_shade
                            {
                                ifg temp 18
                                {
                                    set temp2 temp
                                    sub temp2 18
                                    shiftr temp2 1
                                    sub temp temp2

                                }
                                set particle_force_shade temp
                            }
                        }
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_GLASS_SPIN ifactioncount 4
                    {
                        ife flat_glass 1
                            cstator 32
                        action AC_DEBRIS_GLASS
                    }
                    break
                case DEBRIS_PIPE
                    ifaction 0
                    {
                        action AC_DEBRIS_PIPE_SPIN
                        state debris_shared_code
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_PIPE_SPIN ifactioncount 4
                        action AC_DEBRIS_PIPE
                    break
                case DEBRIS_WOOD
                    ifaction 0
                    {
                        action AC_DEBRIS_WOOD_SPIN
                        state debris_shared_code
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_WOOD_SPIN ifactioncount 4
                        action AC_DEBRIS_WOOD
                    break
                case DEBRIS_METAL
                    ifaction 0
                    {
                        action AC_DEBRIS_METAL_SPIN
                        state debris_shared_code
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_METAL_SPIN ifactioncount 4
                        action AC_DEBRIS_METAL
                    break
                case DEBRIS_STONE
                    ifaction 0
                    {
                        ifrnd 64
                            action AC_DEBRIS_STONE2_SPIN
                        else ifrnd 64
                            action AC_DEBRIS_STONE3_SPIN
                        else
                            action AC_DEBRIS_STONE_SPIN
                        ifaction AC_DEBRIS_STONE3_SPIN ifspritepal 0
                            spritepal 1
                        state debris_shared_code
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_STONE_SPIN ifactioncount 4
                        action AC_DEBRIS_STONE
                    else iffloordistl 1 ifaction AC_DEBRIS_STONE2_SPIN ifactioncount 4
                        action AC_DEBRIS_STONE2
                    else iffloordistl 1 ifaction AC_DEBRIS_STONE3_SPIN ifactioncount 4
                        action AC_DEBRIS_STONE3
                    break
                case DEBRIS_BRICK
                    ifaction 0
                    {
                        action AC_DEBRIS_BRICK_SPIN
                        state debris_shared_code
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_BRICK_SPIN ifactioncount 4
                        action AC_DEBRIS_BRICK
                    break
                case DEBRIS_CINDER
                    ifaction 0
                    {
                        action AC_DEBRIS_CINDER_SPIN
                        state debris_shared_code
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_CINDER_SPIN ifactioncount 4
                        action AC_DEBRIS_CINDER
                    break
                case DEBRIS_GRASS
                    ifaction 0
                    {
                        action AC_DEBRIS_GRASS_SPIN
                        state debris_shared_code
                        rand temp 4
                        add temp 4
                        ifg debris_add_size 0
                            add temp debris_add_size
                        clamp temp 2 255
                        seta[].xrepeat temp
                        seta[].yrepeat temp

                        cstator 2
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_GRASS_SPIN ifactioncount 4
                        action AC_DEBRIS_GRASS
                    break
                case DEBRIS_FABRIC
                    ifaction 0
                    {
                        action AC_DEBRIS_FABRIC_SPIN
                        state debris_shared_code
                        rand temp 4
                        add temp 4
                        ifg debris_add_size 0
                            add temp debris_add_size
                        clamp temp 2 255
                        seta[].xrepeat temp
                        seta[].yrepeat temp
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_FABRIC_SPIN ifactioncount 4
                        action AC_DEBRIS_FABRIC
                    break
                case DEBRIS_PLASTIC
                    ifaction 0
                    {
                        action AC_DEBRIS_PLASTIC_SPIN
                        state debris_shared_code
                    }
                    iffloordistl 1 ifaction AC_DEBRIS_PLASTIC_SPIN ifactioncount 4
                        action AC_DEBRIS_PLASTIC
                    break
            endswitch

            ifceilingdistl 0 ifl sprite[].zvel 0
            {
                geta[].zvel temp
                shiftr temp 3
                seta[].zvel temp
                geta[].xvel temp
                shiftr temp 1
                seta[].xvel temp
            }

            ife debris_type DEBRIS_GRASS
            {
                ifg sprite[].zvel 60
                    seta[].zvel 60
            }
            else ife debris_type DEBRIS_FABRIC
            {
                ifg sprite[].zvel 60
                    seta[].zvel 60
            }

            ife debris_got_slope 0
                state get_debris_slope
            ifg sprite[].xvel 0
                ssp THISACTOR 0

            set temp sprite[].sectnum
            updatesector sprite[].x sprite[].y temp
            ifn temp -1
                seta[].sectnum temp
            ifinwater
                ifle sprite.zvel 0
                {
                    geta .zvel temp2
                    add temp2 GRAVITATIONALCONSTANT
                    seta .zvel temp2
                }
            iffloordistl 1
            {
                getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
                geta[].z temp2
                ifl temp2 temp
                {
                    set temp4 GRAVITATIONALCONSTANT
                    shiftl temp4 2
                    add temp2 temp4
                    ifg temp2 temp
                        set temp2 temp
                    seta[].z temp2
                }
                else
                    seta[].z temp

                ife sector[].lotag 3072
                {
                    for temp spritesofsector sprite[].sectnum
                    {
                        ife sprite[temp].picnum SECTOREFFECTOR
                        {
                            ife sprite[temp].lotag 26
                            {
                                seta[].ang sprite[temp].ang
                                geta[temp].xvel temp2
                                seta[].xvel temp2
                            }
                        }
                    }
                }
                ife debris_type DEBRIS_GRASS iffloordistl 0 ifactioncount 30
                {
                    gets[].floorpicnum surface_type
                    state get_surface_type
                    ife surface_type SURFACE_GRASS
                        cstat 32768
                }
            }
            geta[].xvel temp
            ifg temp 0
            {
                sub temp 1
                iffloordistl 2
                    shiftr temp 1
                ifl temp 0
                    set temp 0
                seta[].xvel temp

                iffloordistl 1
                {
                    setu[].vm_player myconnectindex
                    getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
                    sub temp 512
                    ifand sector[].floorstat 2
                    {
                        gets[].floorslope temp2
                        abs temp2
                        ifg temp2 8192
                            add temp 512
                    }
                    ifl sprite[].z temp ife sprite[].zvel 0
                    {
                        gets[].wallptr temp
                        getw[temp].x temp2
                        getw[temp].y temp3
                        getw[temp].point2 temp4
                        getw[temp4].x temp5
                        getw[temp4].y temp6
                        sub temp2 temp5
                        sub temp3 temp6
                        getangle temp temp2 temp3
                        add temp 1536
                        ifl sector[].floorslope 0
                            add temp 1024
                        rand temp2 128
                        ifrnd 127
                            inv temp2
                        add temp temp2
                        and temp 2047
                        geta[].ang temp2
                        seta[].ang temp
                        seta[].xvel 100
                        set move_v sprite[].xvel
                        state move_actor
                        seta[].ang temp2
                        movesprite THISACTOR move_xv move_yv 0 CLIPMASK0 temp
                        getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                        seta[].z temp2
                        ifl temp 49152
                        {
                            ifge temp 32768
                            {
                                ifand sector[].floorstat 2
                                {
                                    gets[].floorslope temp2
                                    abs temp2
                                    ifg temp2 8192
                                    {
                                        sub temp 32768
                                        getw[temp].nextsector temp
                                        ifn temp -1
                                        {
                                            seta[].xvel 0
                                            getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                                            add temp2 1
                                            seta[].z temp2
                                            seta[].zvel 0
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            ifn particle_force_pal 0
                seta[].pal particle_force_pal
            ifn particle_force_shade 0
            {
                geta[].htflags temp
                or temp 4
                seta[].htflags temp
                seta[].shade particle_force_shade
            }

            set temp 0
            ife sprite[].zvel 0
                set temp 1
            else ifg sprite[].zvel -48 ifl sprite[].zvel 2
                set temp 1
            geta[].sectnum temp4
            set temp5 tainted[temp4]
            ife temp5 1
                set temp 0
            ife temp 1
            {
                set temp sprite[].sectnum
                updatesector sprite[].x sprite[].y temp
                ifn temp -1
                    seta[].sectnum temp
                else
                    set temp7 1
                getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp

                geta[].z temp2
                ifl temp2 temp
                {
                    fall
                    set temp4 GRAVITATIONALCONSTANT
                    shiftl temp4 2
                    add temp2 temp4
                    ifg temp2 temp
                        set temp2 temp
                    seta[].z temp2
                    seta[].xvel 25
                    ssp THISACTOR 0
                }
                else
                    seta[].z temp
            }
            ifspawnedby A_GLASS_PANEL
            {
                iffloordistl 1
                {
                    ife delete_debris 0
                    {
                        set delete_debris 1
                        ifrnd 64
                            inv delete_debris
                        else
                        {
                            ife st_do_once 0
                            {
                                set queued 1
                                insertspriteq
                                set st_do_once 1
                            }
                        }
                    }
                }
                ife delete_debris -1
                    set temp7 1
            }
            else
            {
                ife st_do_once 0
                {
                    set temp 0
                    ife debris_force_qstate -1
                        set temp 0
                    else ifg sprite[].xrepeat 2
                        set temp 1
                    ife temp 1
                    {
                        ifpdistl 12288
                        {
                            ife debris_force_qstate 0
                            {
                                set queued 1
                                insertspriteq
                            }
                            set st_do_once 1
                        }
                        else
                        {
                            ifg sprite[].xrepeat 3
                            {
                                ife debris_force_qstate 0
                                {
                                    set queued 1
                                    insertspriteq
                                }
                                set st_do_once 1
                            }
                            else
                                set st_do_once 2
                        }
                    }
                    else
                    {
                        iffloordistl 1
                        {
                            ifactioncount 9
                                cstator 2
                            ifactioncount 12
                                cstator 512
                            ifactioncount 15
                                set temp7 1
                            ife sprite[].sectnum -1
                                set temp7 1
                            getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
                            getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                            ife temp temp2
                                set temp7 1
                        }
                    }
                }
                else ife st_do_once 2
                {
                    ife debris_force_qstate 1
                        break
                    iffloordistl 1
                    {
                        ifactioncount 9
                            cstator 2
                        ifactioncount 12
                            cstator 512
                        ifactioncount 15
                            set temp7 1
                        getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
                        getceilzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                        ife temp temp2
                            set temp7 1
                    }
                }
            }
            add counter 1
            ife counter 2
            {
                set counter 0
                geta[].htg_t 2 temp2
                add temp2 1
                geta[].htg_t 3 temp3

                switch sprite[].htg_t 4
                    case AC_DEBRIS_ROCK
                    case AC_DEBRIS_GLASS
                    case AC_DEBRIS_PIPE
                    case AC_DEBRIS_WOOD
                    case AC_DEBRIS_METAL
                    case AC_DEBRIS_STONE
                    case AC_DEBRIS_STONE2
                    case AC_DEBRIS_STONE3
                    case AC_DEBRIS_BRICK
                    case AC_DEBRIS_CINDER
                    case AC_DEBRIS_GRASS
                    case AC_DEBRIS_FABRIC
                    case AC_DEBRIS_PLASTIC
                        set temp3 0
                        break
                    default
                        add temp3 1
                        break
                endswitch
                ifg temp3 7
                    set temp3 0
                seta[].htg_t 3 temp3
                seta[].htg_t 2 temp2
            }
            ife temp7 1
            {
                seta[].xrepeat 0
                changespritestat THISACTOR STAT_ACTOR
            }
        }
    }
endevent

spriteflags P_BLOOD 2056

defineprojectile P_BLOOD PROJ_WORKSLIKE 6158 // 22734
defineprojectile P_BLOOD PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_BLOOD PROJ_SXREPEAT 126
defineprojectile P_BLOOD PROJ_SYREPEAT 1
defineprojectile P_BLOOD PROJ_XREPEAT 8
defineprojectile P_BLOOD PROJ_YREPEAT 8
defineprojectile P_BLOOD PROJ_EXTRA 0
defineprojectile P_BLOOD PROJ_EXTRA_RAND 0
defineprojectile P_BLOOD PROJ_HITRADIUS 0
defineprojectile P_BLOOD PROJ_OFFSET 14354
defineprojectile P_BLOOD PROJ_PAL 59
defineprojectile P_BLOOD PROJ_SHADE 0
defineprojectile P_BLOOD PROJ_CSTAT 32768
defineprojectile P_BLOOD PROJ_TRAIL A_GENERIC_BLOODSPLAT
defineprojectile P_BLOOD PROJ_BSOUND -1
defineprojectile P_BLOOD PROJ_BOUNCES 1
defineprojectile P_BLOOD PROJ_VEL 128
defineprojectile P_BLOOD PROJ_DROP -400

// gibs

defineprojectile P_GIB_SPINE PROJ_WORKSLIKE 6146 // 22734
defineprojectile P_GIB_SPINE PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_SPINE PROJ_SXREPEAT 126
defineprojectile P_GIB_SPINE PROJ_SYREPEAT 1
defineprojectile P_GIB_SPINE PROJ_XREPEAT 16
defineprojectile P_GIB_SPINE PROJ_YREPEAT 16
defineprojectile P_GIB_SPINE PROJ_EXTRA 0
defineprojectile P_GIB_SPINE PROJ_EXTRA_RAND 0
defineprojectile P_GIB_SPINE PROJ_HITRADIUS 0
defineprojectile P_GIB_SPINE PROJ_OFFSET 14354
defineprojectile P_GIB_SPINE PROJ_PAL 0
defineprojectile P_GIB_SPINE PROJ_SHADE 0
defineprojectile P_GIB_SPINE PROJ_CSTAT 128
defineprojectile P_GIB_SPINE PROJ_TRAIL -1
defineprojectile P_GIB_SPINE PROJ_BSOUND -1
defineprojectile P_GIB_SPINE PROJ_BOUNCES 2
defineprojectile P_GIB_SPINE PROJ_VEL 256
defineprojectile P_GIB_SPINE PROJ_DROP -244

defineprojectile P_GIB_SKULL PROJ_WORKSLIKE 39054 // 6278 // 22734
defineprojectile P_GIB_SKULL PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_SKULL PROJ_SXREPEAT 126
defineprojectile P_GIB_SKULL PROJ_SYREPEAT 1
defineprojectile P_GIB_SKULL PROJ_XREPEAT 15
defineprojectile P_GIB_SKULL PROJ_YREPEAT 15
defineprojectile P_GIB_SKULL PROJ_EXTRA 10
defineprojectile P_GIB_SKULL PROJ_EXTRA_RAND 5
defineprojectile P_GIB_SKULL PROJ_HITRADIUS 0
defineprojectile P_GIB_SKULL PROJ_OFFSET 14354
defineprojectile P_GIB_SKULL PROJ_PAL 0
defineprojectile P_GIB_SKULL PROJ_SHADE 0
defineprojectile P_GIB_SKULL PROJ_CSTAT 0
defineprojectile P_GIB_SKULL PROJ_TRAIL A_GENERIC_BLOODSPLAT
defineprojectile P_GIB_SKULL PROJ_TXREPEAT 2
defineprojectile P_GIB_SKULL PROJ_TYREPEAT 2
defineprojectile P_GIB_SKULL PROJ_TOFFSET -4
defineprojectile P_GIB_SKULL PROJ_BSOUND S_GIBDROP02
defineprojectile P_GIB_SKULL PROJ_BOUNCES 3
defineprojectile P_GIB_SKULL PROJ_VEL 256
defineprojectile P_GIB_SKULL PROJ_DROP -244

defineprojectile P_GIB_SKULL_LS PROJ_WORKSLIKE 39054 // 6278 // 22734
defineprojectile P_GIB_SKULL_LS PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_SKULL_LS PROJ_SXREPEAT 126
defineprojectile P_GIB_SKULL_LS PROJ_SYREPEAT 1
defineprojectile P_GIB_SKULL_LS PROJ_XREPEAT 14
defineprojectile P_GIB_SKULL_LS PROJ_YREPEAT 14
defineprojectile P_GIB_SKULL_LS PROJ_EXTRA 10
defineprojectile P_GIB_SKULL_LS PROJ_EXTRA_RAND 5
defineprojectile P_GIB_SKULL_LS PROJ_HITRADIUS 0
defineprojectile P_GIB_SKULL_LS PROJ_OFFSET 14354
defineprojectile P_GIB_SKULL_LS PROJ_PAL 0
defineprojectile P_GIB_SKULL_LS PROJ_SHADE 0
defineprojectile P_GIB_SKULL_LS PROJ_CSTAT 0
defineprojectile P_GIB_SKULL_LS PROJ_TRAIL A_GENERIC_BLOODSPLAT
defineprojectile P_GIB_SKULL_LS PROJ_TXREPEAT 2
defineprojectile P_GIB_SKULL_LS PROJ_TYREPEAT 2
defineprojectile P_GIB_SKULL_LS PROJ_TOFFSET -4
defineprojectile P_GIB_SKULL_LS PROJ_BSOUND S_GIBDROP02
defineprojectile P_GIB_SKULL_LS PROJ_BOUNCES 3
defineprojectile P_GIB_SKULL_LS PROJ_VEL 256
defineprojectile P_GIB_SKULL_LS PROJ_DROP -244

defineprojectile P_GIB_SKULL_GR PROJ_WORKSLIKE 39054 // 6278 // 22734
defineprojectile P_GIB_SKULL_GR PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_SKULL_GR PROJ_SXREPEAT 126
defineprojectile P_GIB_SKULL_GR PROJ_SYREPEAT 1
defineprojectile P_GIB_SKULL_GR PROJ_XREPEAT 14
defineprojectile P_GIB_SKULL_GR PROJ_YREPEAT 14
defineprojectile P_GIB_SKULL_GR PROJ_EXTRA 10
defineprojectile P_GIB_SKULL_GR PROJ_EXTRA_RAND 5
defineprojectile P_GIB_SKULL_GR PROJ_HITRADIUS 0
defineprojectile P_GIB_SKULL_GR PROJ_OFFSET 14354
defineprojectile P_GIB_SKULL_GR PROJ_PAL 0
defineprojectile P_GIB_SKULL_GR PROJ_SHADE 0
defineprojectile P_GIB_SKULL_GR PROJ_CSTAT 0
defineprojectile P_GIB_SKULL_GR PROJ_TRAIL A_GENERIC_BLOODSPLAT
defineprojectile P_GIB_SKULL_GR PROJ_TXREPEAT 2
defineprojectile P_GIB_SKULL_GR PROJ_TYREPEAT 2
defineprojectile P_GIB_SKULL_GR PROJ_TOFFSET -4
defineprojectile P_GIB_SKULL_GR PROJ_BSOUND S_GIBDROP02
defineprojectile P_GIB_SKULL_GR PROJ_BOUNCES 3
defineprojectile P_GIB_SKULL_GR PROJ_VEL 256
defineprojectile P_GIB_SKULL_GR PROJ_DROP -244

defineprojectile P_GIB_CHUNK1 PROJ_WORKSLIKE 6158 // 22734
defineprojectile P_GIB_CHUNK1 PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_CHUNK1 PROJ_SXREPEAT 126
defineprojectile P_GIB_CHUNK1 PROJ_SYREPEAT 1
defineprojectile P_GIB_CHUNK1 PROJ_XREPEAT 10
defineprojectile P_GIB_CHUNK1 PROJ_YREPEAT 10
defineprojectile P_GIB_CHUNK1 PROJ_EXTRA 0
defineprojectile P_GIB_CHUNK1 PROJ_EXTRA_RAND 0
defineprojectile P_GIB_CHUNK1 PROJ_HITRADIUS 0
defineprojectile P_GIB_CHUNK1 PROJ_OFFSET 14354
defineprojectile P_GIB_CHUNK1 PROJ_PAL 0
defineprojectile P_GIB_CHUNK1 PROJ_SHADE 0
defineprojectile P_GIB_CHUNK1 PROJ_CSTAT 0
defineprojectile P_GIB_CHUNK1 PROJ_TRAIL -1
defineprojectile P_GIB_CHUNK1 PROJ_BSOUND -1
defineprojectile P_GIB_CHUNK1 PROJ_BOUNCES 2
defineprojectile P_GIB_CHUNK1 PROJ_VEL 256
defineprojectile P_GIB_CHUNK1 PROJ_DROP -244

defineprojectile P_GIB_INTESTINE PROJ_WORKSLIKE 6154 // 22734
defineprojectile P_GIB_INTESTINE PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_INTESTINE PROJ_SXREPEAT 126
defineprojectile P_GIB_INTESTINE PROJ_SYREPEAT 1
defineprojectile P_GIB_INTESTINE PROJ_XREPEAT 16
defineprojectile P_GIB_INTESTINE PROJ_YREPEAT 16
defineprojectile P_GIB_INTESTINE PROJ_EXTRA 0
defineprojectile P_GIB_INTESTINE PROJ_EXTRA_RAND 0
defineprojectile P_GIB_INTESTINE PROJ_HITRADIUS 0
defineprojectile P_GIB_INTESTINE PROJ_OFFSET 14354
defineprojectile P_GIB_INTESTINE PROJ_PAL 0
defineprojectile P_GIB_INTESTINE PROJ_SHADE 0
defineprojectile P_GIB_INTESTINE PROJ_CSTAT 128
defineprojectile P_GIB_INTESTINE PROJ_TRAIL -1
defineprojectile P_GIB_INTESTINE PROJ_BSOUND -1
defineprojectile P_GIB_INTESTINE PROJ_BOUNCES 2
defineprojectile P_GIB_INTESTINE PROJ_VEL 256
defineprojectile P_GIB_INTESTINE PROJ_DROP -244

defineprojectile P_GIB_MEAT PROJ_WORKSLIKE 6158 // 22734
defineprojectile P_GIB_MEAT PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_MEAT PROJ_SXREPEAT 126
defineprojectile P_GIB_MEAT PROJ_SYREPEAT 1
defineprojectile P_GIB_MEAT PROJ_XREPEAT 10
defineprojectile P_GIB_MEAT PROJ_YREPEAT 10
defineprojectile P_GIB_MEAT PROJ_EXTRA 0
defineprojectile P_GIB_MEAT PROJ_EXTRA_RAND 0
defineprojectile P_GIB_MEAT PROJ_HITRADIUS 0
defineprojectile P_GIB_MEAT PROJ_OFFSET 14354
defineprojectile P_GIB_MEAT PROJ_PAL 0
defineprojectile P_GIB_MEAT PROJ_SHADE 0
defineprojectile P_GIB_MEAT PROJ_CSTAT 0
defineprojectile P_GIB_MEAT PROJ_TRAIL -1
defineprojectile P_GIB_MEAT PROJ_BSOUND -1
defineprojectile P_GIB_MEAT PROJ_BOUNCES 2
defineprojectile P_GIB_MEAT PROJ_VEL 256
defineprojectile P_GIB_MEAT PROJ_DROP -244

defineprojectile P_GIB_LUNG PROJ_WORKSLIKE 6154 // 22734
defineprojectile P_GIB_LUNG PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_LUNG PROJ_SXREPEAT 126
defineprojectile P_GIB_LUNG PROJ_SYREPEAT 1
defineprojectile P_GIB_LUNG PROJ_XREPEAT 16
defineprojectile P_GIB_LUNG PROJ_YREPEAT 16
defineprojectile P_GIB_LUNG PROJ_EXTRA 0
defineprojectile P_GIB_LUNG PROJ_EXTRA_RAND 0
defineprojectile P_GIB_LUNG PROJ_HITRADIUS 0
defineprojectile P_GIB_LUNG PROJ_OFFSET 14354
defineprojectile P_GIB_LUNG PROJ_PAL 0
defineprojectile P_GIB_LUNG PROJ_SHADE 0
defineprojectile P_GIB_LUNG PROJ_CSTAT 128
defineprojectile P_GIB_LUNG PROJ_TRAIL -1
defineprojectile P_GIB_LUNG PROJ_BSOUND -1
defineprojectile P_GIB_LUNG PROJ_BOUNCES 2
defineprojectile P_GIB_LUNG PROJ_VEL 256
defineprojectile P_GIB_LUNG PROJ_DROP -244

defineprojectile P_GIB_LIVER PROJ_WORKSLIKE 6154 // 22734
defineprojectile P_GIB_LIVER PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_LIVER PROJ_SXREPEAT 126
defineprojectile P_GIB_LIVER PROJ_SYREPEAT 1
defineprojectile P_GIB_LIVER PROJ_XREPEAT 16
defineprojectile P_GIB_LIVER PROJ_YREPEAT 16
defineprojectile P_GIB_LIVER PROJ_EXTRA 0
defineprojectile P_GIB_LIVER PROJ_EXTRA_RAND 0
defineprojectile P_GIB_LIVER PROJ_HITRADIUS 0
defineprojectile P_GIB_LIVER PROJ_OFFSET 14354
defineprojectile P_GIB_LIVER PROJ_PAL 0
defineprojectile P_GIB_LIVER PROJ_SHADE 0
defineprojectile P_GIB_LIVER PROJ_CSTAT 128
defineprojectile P_GIB_LIVER PROJ_TRAIL -1
defineprojectile P_GIB_LIVER PROJ_BSOUND -1
defineprojectile P_GIB_LIVER PROJ_BOUNCES 2
defineprojectile P_GIB_LIVER PROJ_VEL 256
defineprojectile P_GIB_LIVER PROJ_DROP -244

defineprojectile P_GIB_CHUNK2 PROJ_WORKSLIKE 6158 // 22734
defineprojectile P_GIB_CHUNK2 PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_CHUNK2 PROJ_SXREPEAT 126
defineprojectile P_GIB_CHUNK2 PROJ_SYREPEAT 1
defineprojectile P_GIB_CHUNK2 PROJ_XREPEAT 10
defineprojectile P_GIB_CHUNK2 PROJ_YREPEAT 10
defineprojectile P_GIB_CHUNK2 PROJ_EXTRA 0
defineprojectile P_GIB_CHUNK2 PROJ_EXTRA_RAND 0
defineprojectile P_GIB_CHUNK2 PROJ_HITRADIUS 0
defineprojectile P_GIB_CHUNK2 PROJ_OFFSET 14354
defineprojectile P_GIB_CHUNK2 PROJ_PAL 0
defineprojectile P_GIB_CHUNK2 PROJ_SHADE 0
defineprojectile P_GIB_CHUNK2 PROJ_CSTAT 0
defineprojectile P_GIB_CHUNK2 PROJ_TRAIL -1
defineprojectile P_GIB_CHUNK2 PROJ_BSOUND -1
defineprojectile P_GIB_CHUNK2 PROJ_BOUNCES 2
defineprojectile P_GIB_CHUNK2 PROJ_VEL 256
defineprojectile P_GIB_CHUNK2 PROJ_DROP -180

defineprojectile P_GIB_HEART PROJ_WORKSLIKE 6154 // 22734
defineprojectile P_GIB_HEART PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_HEART PROJ_SXREPEAT 126
defineprojectile P_GIB_HEART PROJ_SYREPEAT 1
defineprojectile P_GIB_HEART PROJ_XREPEAT 16
defineprojectile P_GIB_HEART PROJ_YREPEAT 16
defineprojectile P_GIB_HEART PROJ_EXTRA 0
defineprojectile P_GIB_HEART PROJ_EXTRA_RAND 0
defineprojectile P_GIB_HEART PROJ_HITRADIUS 0
defineprojectile P_GIB_HEART PROJ_OFFSET 14354
defineprojectile P_GIB_HEART PROJ_PAL 0
defineprojectile P_GIB_HEART PROJ_SHADE 0
defineprojectile P_GIB_HEART PROJ_CSTAT 128
defineprojectile P_GIB_HEART PROJ_TRAIL -1
defineprojectile P_GIB_HEART PROJ_BSOUND -1
defineprojectile P_GIB_HEART PROJ_BOUNCES 2
defineprojectile P_GIB_HEART PROJ_VEL 256
defineprojectile P_GIB_HEART PROJ_DROP -244

defineprojectile P_GIB_EYE PROJ_WORKSLIKE 6158 // 22734
defineprojectile P_GIB_EYE PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_EYE PROJ_SXREPEAT 126
defineprojectile P_GIB_EYE PROJ_SYREPEAT 1
defineprojectile P_GIB_EYE PROJ_XREPEAT 16
defineprojectile P_GIB_EYE PROJ_YREPEAT 16
defineprojectile P_GIB_EYE PROJ_EXTRA 0
defineprojectile P_GIB_EYE PROJ_EXTRA_RAND 0
defineprojectile P_GIB_EYE PROJ_HITRADIUS 0
defineprojectile P_GIB_EYE PROJ_OFFSET 14354
defineprojectile P_GIB_EYE PROJ_PAL 0
defineprojectile P_GIB_EYE PROJ_SHADE 0
defineprojectile P_GIB_EYE PROJ_CSTAT 128
defineprojectile P_GIB_EYE PROJ_TRAIL -1
defineprojectile P_GIB_EYE PROJ_BSOUND -1
defineprojectile P_GIB_EYE PROJ_BOUNCES 2
defineprojectile P_GIB_EYE PROJ_VEL 256
defineprojectile P_GIB_EYE PROJ_DROP -244

defineprojectile P_GIB_ARM PROJ_WORKSLIKE 6154 // 22734
defineprojectile P_GIB_ARM PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_ARM PROJ_SXREPEAT 126
defineprojectile P_GIB_ARM PROJ_SYREPEAT 1
defineprojectile P_GIB_ARM PROJ_XREPEAT 18
defineprojectile P_GIB_ARM PROJ_YREPEAT 16
defineprojectile P_GIB_ARM PROJ_EXTRA 0
defineprojectile P_GIB_ARM PROJ_EXTRA_RAND 0
defineprojectile P_GIB_ARM PROJ_HITRADIUS 0
defineprojectile P_GIB_ARM PROJ_OFFSET 14354
defineprojectile P_GIB_ARM PROJ_PAL 0
defineprojectile P_GIB_ARM PROJ_SHADE 0
defineprojectile P_GIB_ARM PROJ_CSTAT 0
defineprojectile P_GIB_ARM PROJ_TRAIL -1
defineprojectile P_GIB_ARM PROJ_BSOUND -1
defineprojectile P_GIB_ARM PROJ_BOUNCES 2
defineprojectile P_GIB_ARM PROJ_VEL 256
defineprojectile P_GIB_ARM PROJ_DROP -244

defineprojectile P_GIB_LEG_LS PROJ_WORKSLIKE 6158 // 22734
defineprojectile P_GIB_LEG_LS PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_LEG_LS PROJ_SXREPEAT 126
defineprojectile P_GIB_LEG_LS PROJ_SYREPEAT 1
defineprojectile P_GIB_LEG_LS PROJ_XREPEAT 22
defineprojectile P_GIB_LEG_LS PROJ_YREPEAT 21
defineprojectile P_GIB_LEG_LS PROJ_EXTRA 0
defineprojectile P_GIB_LEG_LS PROJ_EXTRA_RAND 0
defineprojectile P_GIB_LEG_LS PROJ_HITRADIUS 0
defineprojectile P_GIB_LEG_LS PROJ_OFFSET 14354
defineprojectile P_GIB_LEG_LS PROJ_PAL 0
defineprojectile P_GIB_LEG_LS PROJ_SHADE 0
defineprojectile P_GIB_LEG_LS PROJ_CSTAT 0
defineprojectile P_GIB_LEG_LS PROJ_TRAIL -1
defineprojectile P_GIB_LEG_LS PROJ_BSOUND -1
defineprojectile P_GIB_LEG_LS PROJ_BOUNCES 2
defineprojectile P_GIB_LEG_LS PROJ_VEL 256
defineprojectile P_GIB_LEG_LS PROJ_DROP -244

defineprojectile P_GIB_LEG_GR PROJ_WORKSLIKE 6158 // 22734
defineprojectile P_GIB_LEG_GR PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_LEG_GR PROJ_SXREPEAT 126
defineprojectile P_GIB_LEG_GR PROJ_SYREPEAT 1
defineprojectile P_GIB_LEG_GR PROJ_XREPEAT 20
defineprojectile P_GIB_LEG_GR PROJ_YREPEAT 16
defineprojectile P_GIB_LEG_GR PROJ_EXTRA 0
defineprojectile P_GIB_LEG_GR PROJ_EXTRA_RAND 0
defineprojectile P_GIB_LEG_GR PROJ_HITRADIUS 0
defineprojectile P_GIB_LEG_GR PROJ_OFFSET 14354
defineprojectile P_GIB_LEG_GR PROJ_PAL 0
defineprojectile P_GIB_LEG_GR PROJ_SHADE 0
defineprojectile P_GIB_LEG_GR PROJ_CSTAT 0
defineprojectile P_GIB_LEG_GR PROJ_TRAIL -1
defineprojectile P_GIB_LEG_GR PROJ_BSOUND -1
defineprojectile P_GIB_LEG_GR PROJ_BOUNCES 2
defineprojectile P_GIB_LEG_GR PROJ_VEL 256
defineprojectile P_GIB_LEG_GR PROJ_DROP -244

defineprojectile P_GIB_LEG_SECT PROJ_WORKSLIKE 6158 // 22734
defineprojectile P_GIB_LEG_SECT PROJ_SPAWNS A_GENERIC_PARTICLE
defineprojectile P_GIB_LEG_SECT PROJ_SXREPEAT 126
defineprojectile P_GIB_LEG_SECT PROJ_SYREPEAT 1
defineprojectile P_GIB_LEG_SECT PROJ_XREPEAT 16
defineprojectile P_GIB_LEG_SECT PROJ_YREPEAT 16
defineprojectile P_GIB_LEG_SECT PROJ_EXTRA 0
defineprojectile P_GIB_LEG_SECT PROJ_EXTRA_RAND 0
defineprojectile P_GIB_LEG_SECT PROJ_HITRADIUS 0
defineprojectile P_GIB_LEG_SECT PROJ_OFFSET 14354
defineprojectile P_GIB_LEG_SECT PROJ_PAL 0
defineprojectile P_GIB_LEG_SECT PROJ_SHADE 0
defineprojectile P_GIB_LEG_SECT PROJ_CSTAT 128
defineprojectile P_GIB_LEG_SECT PROJ_TRAIL -1
defineprojectile P_GIB_LEG_SECT PROJ_BSOUND -1
defineprojectile P_GIB_LEG_SECT PROJ_BOUNCES 2
defineprojectile P_GIB_LEG_SECT PROJ_VEL 256
defineprojectile P_GIB_LEG_SECT PROJ_DROP -244

appendevent EVENT_EGS

    switch sprite[].picnum
        case P_GIB_SPINE
        case P_GIB_SKULL
        case P_GIB_SKULL_LS
        case P_GIB_SKULL_GR
        case P_GIB_CHUNK1
        case P_GIB_INTESTINE
        case P_GIB_MEAT
        case P_GIB_LUNG
        case P_GIB_LIVER
        case P_GIB_CHUNK2
        case P_GIB_HEART
        case P_GIB_EYE
        case P_GIB_ARM
        case P_GIB_LEG_LS
        case P_GIB_LEG_GR
        case P_GIB_LEG_SECT
            geta[].zvel temp
            sub temp 1024
            seta[].zvel temp
            break
    endswitch
endevent

spriteshadow P_GIB_SKULL
spriteshadow P_GIB_SKULL_LS
spriteshadow P_GIB_SKULL_GR
spriteshadow P_GIB_ARM
spriteshadow P_GIB_LEG_LS
spriteshadow P_GIB_LEG_GR

var gib_temp
var gib_temp2
var gib_temp3
var gib_temp4
defstate gib_shared
    rand gib_temp 2048
    ifrnd 127
        inv gib_temp
    add gib_temp sprite[RETURN].zvel
    seta[RETURN].zvel gib_temp
    rand gib_temp 384
    ifrnd 127
        inv gib_temp
    add gib_temp sprite[].htang
    and gib_temp 2047
    seta[RETURN].ang gib_temp
    rand gib_temp 190
    sub gib_temp sprite[RETURN].xvel
    inv gib_temp
    seta[RETURN].xvel gib_temp
ends
defstate gib_spine
        eshoot P_GIB_SPINE
        state gib_shared
ends

action AC_GIB_10 0 10 1 1 4
action AC_GIB_12 0 12 1 1 4
action AC_GIB_8 0 8 1 1 4

defstate gib_idle
    fall
    set actor_gib 1
    ife st_do_once 0
    {
        set queued 1
        insertspriteq
        set st_do_once 1
    }
    ife counter 0
    {
        action AC_GIB_IDLE
        set counter 1
        seta[].xvel 0
    }
    seta[].htg_t 3 gib_saveframe
    switch sprite[].picnum
        case P_GIB_SKULL
        case P_GIB_SKULL_LS
        case P_GIB_SKULL_GR
            break
        default
            changespritestat THISACTOR STAT_STATIC_GIB
            break
    endswitch
ends

appendevent EVENT_WORLD
    for temp7 sprofstat STAT_STATIC_GIB
    {
        setu[].vm_sprite temp7
        
        add counter3 1
        mod counter3 4
        ife counter3 0
        {
            geta .sectnum temp
            updatesector sprite.x sprite.y temp
            ifn temp -1
                seta .sectnum temp
        }
        ife actor_gib 2
        {
            ifand sprite[].cstat 4
                cstat 4
            else
                cstat 0
            fall
        }
        else
            state gib_idle
        ife sprite[].xrepeat 0
            changespritestat THISACTOR STAT_ACTOR
    }
endevent

appendevent EVENT_EGS
    switch sprite.picnum
        case P_GIB_SKULL
        case P_GIB_SKULL_LS
        case P_GIB_SKULL_GR
            geta .owner tp_owner
            break
    endswitch
endevent

defstate gib_skull
    ife tp_owner -1
    {
        sizeat 14 14
        setthisprojectile .workslike 39046
        setthisprojectile .spawns A_GENERIC_PARTICLE
        setthisprojectile .sxrepeat 126
        setthisprojectile .syrepeat 1
        setthisprojectile .xrepeat 14
        setthisprojectile .yrepeat 14
        setthisprojectile .extra 10
        setthisprojectile .extra_rand 5
        setthisprojectile .hitradius 0
        setthisprojectile .offset 0
        setthisprojectile .shade 0
        setthisprojectile .cstat 0
        setthisprojectile .trail A_GENERIC_BLOODSPLAT
        setthisprojectile .txrepeat 2
        setthisprojectile .tyrepeat 2
        setthisprojectile .toffset -4
        setthisprojectile .bsound S_GIBDROP02
        setthisprojectile .bounces 3
        setthisprojectile .vel 256
        setthisprojectile .drop -244
        set tp_owner -2
    }
    set actor_moveable 1
    state gib_idle
    cstator 257
    ife db_once 1
    {
        cstat 32768
        break
    }
    geta[].htmovflag temp
    ifpdistl 800
    {
        set temp3 player[].posxv
        shiftr temp3 16
        ifl temp3 2 ifg temp3 -2
            set temp3 0
        add actor_moveable_xv temp3

        set temp3 player[].posyv
        shiftr temp3 16
        ifl temp3 2 ifg temp3 -2
            set temp3 0
        add actor_moveable_yv temp3
        redefinequote 115 gamestate.bin
        readarrayfromfile gamestate 115
        set temp gamestate[11]
		add temp 1
		setarray gamestate[11] temp
		writearraytofile gamestate 115
		or cheevo_tracker 65536
    }
    set temp actor_moveable_xv
    abs temp
    set temp2 actor_moveable_yv
    abs temp2
    add temp temp2
    ifn temp 0 iffloordistl 1
    {
        set face_target player[].i
        state face_actor
        set temp2 face_return
        action AC_GIB_10
        set actor_moveable_xv 0
        set actor_moveable_yv 0
        add temp2 1024
        and temp2 2047
        seta[].ang temp2
        shiftl temp 3
        seta[].xvel temp
        shiftl temp 4
        inv temp
        seta[].zvel temp
        seta[].yvel 4
        set counter 0
        sound S_SKULLKICK
        setthisprojectile[].trail A_GENERIC_BLOODSPLAT
        changespritestat THISACTOR STAT_PROJECTILE
    }
    else
    {
        geta[].htextra temp
        ifhitweapon
        {
            ifwasweapon EXPLOSION
            {
                ife db_once 0
                {
                    geta[].sectnum db_temp
                    set db_temp tainted[db_temp]
                    ife db_temp 0
                    {
                        espawn A_GENERIC_BLOODSPLATTER
                        getflorzofslope sprite[].sectnum sprite[].x sprite[].y db_temp
                        seta[RETURN].z db_temp
                        set db_temp sector[sprite[].sectnum].floorshade
                        add db_temp 7
                        seta[RETURN].shade db_temp
                        rand db_temp 10
                        clamp db_temp 4 10
                        seta[RETURN].xrepeat db_temp
                        seta[RETURN].yrepeat db_temp
                        seta[RETURN].cstat 160
                        rand db_temp 2047
                        seta[RETURN].ang db_temp
                    }
                    set db_once 1
                    break
                }
            }
            ifg temp 0
            {
                seta[].ang sprite[].htang
                action AC_GIB_10
                strength 0
                set actor_moveable_xv 0
                set actor_moveable_yv 0
                shiftl temp 3
                seta[].xvel temp
                shiftl temp 4
                inv temp
                seta[].zvel temp
                seta[].yvel 4
                set counter 0
                sound S_SKULLKICK
                setthisprojectile[].trail A_GENERIC_BLOODSPLAT
                changespritestat THISACTOR STAT_PROJECTILE
            }
        }
    }
ends
actor P_GIB_SPINE 0 AC_GIB_10 enda

actor P_GIB_SKULL 0 AC_GIB_10
    state gib_skull
enda

actor P_GIB_SKULL_LS 0 AC_GIB_10
    state gib_skull
enda
actor P_GIB_SKULL_GR 0 AC_GIB_10
    state gib_skull
enda

actor P_GIB_CHUNK1 0 AC_GIB_12
    state gib_idle
enda
actor P_GIB_INTESTINE 0 AC_GIB_8 enda
actor P_GIB_MEAT 0 AC_GIB_8
    state gib_idle
enda
actor P_GIB_LUNG 0 AC_GIB_8 enda
actor P_GIB_LIVER 0 AC_GIB_8 enda
actor P_GIB_CHUNK2 0 AC_GIB_8
    state gib_idle
enda
actor P_GIB_HEART 0 AC_GIB_8 enda
actor P_GIB_EYE 0 AC_GIB_8 enda

actor P_GIB_ARM 0 AC_GIB_8
    state gib_idle
enda
actor P_GIB_LEG_LS 0 AC_GIB_8
    state gib_idle
enda
actor P_GIB_LEG_GR 0 AC_GIB_8
    state gib_idle
enda

actor P_GIB_LEG_SECT 0 AC_GIB_8 enda

appendevent EVENT_EGS
    ifactor A_GIBBER
        geta[].owner tp_owner
endevent
useractor notenemy A_GIBBER
    cstat 257
    strength 100
    ifhitweapon
    {
        ifrnd 127
        sound S_GIBSPLODE02
        else
            sound S_GIBSPLODE01
        eshoot P_GIB_SPINE
        state gib_shared
        eshoot P_GIB_SKULL
        state gib_shared
        eshoot P_GIB_CHUNK1
        state gib_shared
        eshoot P_GIB_CHUNK1
        state gib_shared
        eshoot P_GIB_INTESTINE
        state gib_shared
        eshoot P_GIB_MEAT
        state gib_shared
        eshoot P_GIB_MEAT
        state gib_shared
        eshoot P_GIB_LUNG
        state gib_shared
        eshoot P_GIB_LUNG
        state gib_shared
        eshoot P_GIB_LIVER
        state gib_shared
        eshoot P_GIB_CHUNK2
        state gib_shared
        eshoot P_GIB_HEART
        state gib_shared
        eshoot P_GIB_EYE
        state gib_shared
        eshoot P_GIB_EYE
        state gib_shared

        set temp6 0
        for temp6 range 10
        {
            geta[].ang temp2
            rand temp3 2047
            seta[].ang temp3
            rand temp3 2048
            shiftl temp3 1
            ifrnd 127
                inv temp3
            ezshoot temp3 P_BLOOD
            ifvarl sprite [].htg_t 8 5
                ifvarg sprite [].htg_t 8 0
                    seta[RETURN].shade sprite [].htg_t 8
            setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT

            geta[RETURN].z temp3
            sub temp3 2048
            seta[RETURN].z temp3
            seta[RETURN].cstat 130
            seta[RETURN].xrepeat 4
            seta[RETURN].yrepeat 4
            seta[].ang temp2
        }
        set counter 1
    }
    ifg tp_owner -1
        killit
    ifg counter 0
    {
        cstat 32768
        add counter 1
        ifg counter 60
            set counter 0
    }
enda

defstate generic_gibs
    rand gib_temp 4
    add gib_temp S_GIBSPLODE01
    soundvar gib_temp

    eshoot P_GIB_SPINE
    state gib_shared

    switch sprite [].picnum
    {
    case A_CULTIST:
    case A_CULTIST_DEAD:
        ife enemy_headache 0
        {
            eshoot P_GIB_SKULL_LS
            state gib_shared
        }
        eshoot P_GIB_ARM
        state gib_shared
        eshoot P_GIB_ARM
        state gib_shared
        geta[RETURN].cstat gib_temp
        or gib_temp 4
        seta[RETURN].cstat gib_temp

        eshoot P_GIB_LEG_LS
        state gib_shared
        eshoot P_GIB_LEG_LS
        state gib_shared
        geta[RETURN].cstat gib_temp
        or gib_temp 4
        seta[RETURN].cstat gib_temp
        break
    case A_GREATER:
    case A_GREATER_DEAD1:
    case A_GREATER_DEAD2:
        ife enemy_headache 0
        {
            eshoot P_GIB_SKULL_GR
            state gib_shared
        }
        eshoot P_GIB_ARM
        state gib_shared
        eshoot P_GIB_ARM
        state gib_shared
        geta[RETURN].cstat gib_temp
        or gib_temp 4
        seta[RETURN].cstat gib_temp

        eshoot P_GIB_LEG_GR
        state gib_shared
        eshoot P_GIB_LEG_GR
        state gib_shared
        geta[RETURN].cstat gib_temp
        or gib_temp 4
        seta[RETURN].cstat gib_temp
        break
    default:
        eshoot P_GIB_SKULL
        state gib_shared
        break
    }
    endswitch

    ifand tiledata[sprite[].picnum].gameflags 32
    {
        ifge framerate 24
        {
            eshoot P_GIB_CHUNK1
            state gib_shared
            eshoot P_GIB_CHUNK1
            state gib_shared
            eshoot P_GIB_INTESTINE
            state gib_shared
            eshoot P_GIB_MEAT
            state gib_shared
            eshoot P_GIB_MEAT
            state gib_shared
            eshoot P_GIB_LUNG
            state gib_shared
            eshoot P_GIB_LUNG
            state gib_shared
            eshoot P_GIB_LIVER
            state gib_shared
            eshoot P_GIB_CHUNK2
            state gib_shared
            eshoot P_GIB_HEART
            state gib_shared
            eshoot P_GIB_EYE
            state gib_shared
            eshoot P_GIB_EYE
            state gib_shared
        }
    }
    set gib_temp 0
    for gib_temp range 10
    {
        geta[].ang gib_temp2
        rand gib_temp3 2047
        seta[].ang temp3
        rand gib_temp3 2048

        shiftl gib_temp3 1
        ifrnd 127
            inv gib_temp3
        ezshoot gib_temp3 P_BLOOD
        ifvarl sprite [].htg_t 8 5
            ifvarg sprite [].htg_t 8 0
                seta[RETURN].shade sprite [].htg_t 8

        setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT

        geta[RETURN].z gib_temp3
        sub gib_temp3 2048
        seta[RETURN].z gib_temp3

        seta[RETURN].xrepeat 4
        seta[RETURN].yrepeat 4
        seta[].ang gib_temp2

        /* ifl framerate 15 // add back later if we can bail out
            add gib_temp 1 */
    }
ends

defstate skull_gibs
    rand gib_temp 4
    add gib_temp S_GIBSPLODE01
    soundvar gib_temp

    eshoot P_GIB_LUNG
    state gib_shared

    switch sprite[].picnum
    {
        case A_CULTIST:
        case A_CULTIST_DEAD:
            eshoot P_GIB_SKULL_LS
            state gib_shared
            break
        case A_GREATER:
        case A_GREATER_DEAD1:
        case A_GREATER_DEAD2:
            eshoot P_GIB_SKULL_GR
            state gib_shared
            break
        default:
            eshoot P_GIB_SKULL
            state gib_shared
            break
    }
    endswitch

    eshoot P_GIB_MEAT
    state gib_shared
    eshoot P_GIB_MEAT
    state gib_shared

    set gib_temp 0
    for gib_temp range 7
    {
        geta[].ang gib_temp2
        rand gib_temp3 2047
        seta[].ang temp3
        rand gib_temp3 2048

        shiftl gib_temp3 1
        ifrnd 127
            inv gib_temp3
        ezshoot gib_temp3 P_BLOOD
        ifvarl sprite [].htg_t 8 5
            ifvarg sprite [].htg_t 8 0
                seta[RETURN].shade sprite [].htg_t 8

        setthisprojectile[RETURN].trail A_GENERIC_BLOODSPLAT

        geta[RETURN].z gib_temp3
        sub gib_temp3 2048
        seta[RETURN].z gib_temp3

        seta[RETURN].xrepeat 4
        seta[RETURN].yrepeat 4
        seta[].ang gib_temp2

    }
    ifactor A_MECHSECT // for clarity do this here
    {
        set gib_temp2 0
        for gib_temp2 range 6
        {
            eshoot P_GIB_LEG_SECT
            state gib_shared
            ife ms_flashpal 0
                seta[RETURN].pal sprite[].pal
            else
                seta[RETURN].pal ms_flashpal
        }
    }
ends

spritenoshade A_FOOTPRINT_1
spritenoshade A_FOOTPRINT_2
spritenoshade A_FOOTPRINT_3
spritenoshade A_FOOTPRINT_4
appendevent EVENT_SPAWN
    switch sprite[].picnum
        case A_FOOTPRINT_1
        case A_FOOTPRINT_2
        case A_FOOTPRINT_3
        case A_FOOTPRINT_4
            sizeat 8 8
            cstator 34
            set temp 1

            ife temp 1
            {
                ife player[].footprintcount 2
                {
                    seta[].blend 0
                    seta[].shade 27
                    setp[].footprintshade 27
                    setp[].footprintpal p_footpal
                    add temp 63
                    seta[].pal temp
                }
                else ife player[].footprintcount 1
                {
                    seta[].blend 0
                    seta[].shade 27
                    setp[].footprintshade 27
                    setp[].footprintpal p_footpal
                    add temp 63
                    seta[].pal temp
                    cstator 512
                }
                else
                {
                    seta[].blend 130
                    seta[].shade -127
                    setp[].footprintshade -127
                    setp[].footprintpal p_footpal
                }
            }

            set temp3 tilesizx[sprite[].picnum]
            mul temp3 sprite[].xrepeat
            shiftr temp3 2
            set move_v temp3
            state move_actor
            set temp2 0
            set temp6 0

            for temp6 range 5
            {
                set temp3 move_xv
                set temp4 move_yv
                geta[].ang temp5

                set temp7 temp6
                shiftl temp7 9
                add temp7 256
                add temp5 temp7

                and temp5 2047

                cos move_xv temp5
                sin move_yv temp5

                mul move_xv move_v
                mul move_yv move_v

                shiftr move_xv 14
                shiftr move_yv 14

                add move_xv sprite[].x
                add move_yv sprite[].y

                set temp5 sprite[].sectnum
                updatesector move_xv move_yv temp5

                ife temp5 sprite[].sectnum
                    add temp2 1
                else ifn temp5 -1
                {
                    ife sector[temp5].floorz sector[sprite[].sectnum].floorz
                        ife sector[temp5].floorslope sector[sprite[].sectnum].floorslope
                            add temp2 1
                }

                ifge temp6 4
                ifl temp2 4
                {
                    cstat 32768
                }
            }
            geta[].sectnum temp4
            set temp5 tainted[temp4]
            ife temp5 1
                cstator 32768
            break
    endswitch
endevent

