/*
--------------------------------------------------------------------------------
================================================================================
                          +:                                                   
WWW@*WWWWWWW+  *WWWWWWW*  :=@       @WWWWWWWWW*WWW*  =WWW*WWWWWWWWWW@*WWW+  @WW
WWW@*WWWWWWWWW**WWWWWWWWW=   =*     @WWWWWWWWW*WWW*  =WWW*WWWWWWWWWW@*WWW+  @WW
WWW@*WWW+  WWWW*WWW*  @WWW :WWWWWW+ @WWW*    *+WWW*  =WWW*WWW#=#WWWW#*WWWWW@@WW
WWW@*WWW+  @WWW*WWW*  #WWW @WWWWWWW @WWW#WWWW@+WWW*  =WWW*WWW#WWWWW* *WWWWW@@WW
WWW@*WWW@  @WWW*WWW*  #WWW += =# += @WWW      +WWWW: =WWW*WWW=  @WWW@      *WWW
WWW@ *WWWWWWWWW*WWW*  #WWW   =WW@   @WWW       :WWWWWWWWW*WWW=   WWW@:WWWWWWWW@
@@@@   +@@@@@@@+@@@+  #WWW          @WWW         :WWWWWWW+W@@=   @@@@:@@@@@@#  

###############################################################################
Ion Fury
Code by Jonathan Strander, Fox Martins, Richard Gobeille, and Evan Ramos
All code as written belongs to Voidpoint and the respective authors.
(c) 2019 Voidpoint, LLC
--------------------------------------------------------------------------------
While we encourage you to experiment, modifications are allowed WITHOUT any
warranty or guarantee of support. Editing these files is AT YOUR OWN RISK, and
we encourage you to make backups.
--------------------------------------------------------------------------------

NOTES:
This file contains most of the effectors (particularly Sector Effectors), and
some init and display code for the game to function properly.
================================================================================
--------------------------------------------------------------------------------
*/
var se_extra 0 2
var se_shade 0 2
var se_xvel 0 2
var se_yvel 0 2
var se_zvel 0 2
var se_pal 0 2
var se_above 0 2
var se_ang 0 2
var se_rotdir 0 2
var se_rotswitch 0 2
var se_rotamt 0 2
var se_rotno 0 2
var se_ang_off 0 2
var se_abv
var se_swap_sector_hitag
var se_swap_linkid -1 2
var se_newrot_hitag
var current_part
var se_electric_toggle 0 2
var se_electric_hitag -1 0
var light_trigger -1 0
var light_trigger_res -1 0
var se_slope_hitag -1 0
var se_slope_dir 0 2
var se_slope_ceil 0 2
var se_slope_flor 0 2
var se_slope_ceilo 0 2
var se_slope_floro 0 2
var se_31_savez 0 2
var se_31_saved 0 2
var save_noclip -1 131072
var mfx_trigger -1 0
var se_walldrag_tag -1 0
var se_shake_hitag -1 0
var fliptheclip -1 0
var autosave_hitag -1 0
var need_autosave
var gradient_trigger -1 0
var tp_activate -1 0
var tp_bypass -1 0
var tp_activated 0 2
var tp_closed 0 2
var tp_countone 0 2
var tp_owner -1 2
var se_force_ep -1 0
var now_gtfo -1 0
var shoot_me -1 0
var kill_me -1 0
var itsasecret -1 0
var rain_fail

var keepstatssafe 0 131072
var yahahayoufoundme 0 131072
var yahahayoufoundme2 0 GAMEVAR_NORESET GAMEVAR_SERIALIZE

var st_do_once 0 2

var rain_amount 0 2
var rain_counter 0 2
var rain_vel 0 2

var cam_xoff 0 2
var cam_yoff 0 2
var cam_zoff 0 2
var cam_sectoff 0 2
var cam_other 0 2
var cam_id -1 0
var cam_id_source -1 0
var cam_bypass
var cam_force_seen

var pivot_ang 0 2
var pivot_stopped 0 2
var pivot_xoff 0 2
var pivot_yoff 0 2
var pivot_zoff 0 2
var pivot_old_cstat 0 2
var pivot_init 0 2
var pivot_master_id -1 2
var pivot_angdiff 0 2
var pivot_hitag 0 2
var pivot_lotag 0 2
var pivot_xvel 0 2
var pivot_trigger -1 0
var pivot_current_point -1 2
var pivot_current_id -1 2
var pivot_max_points -1 2
var pivot_found_point 0 2
var pivot_turning 0 2

var p_nextlevel -1 131072
var p_nextepisode -1 131072
var p_nextlevel_tag -1 131072
var p_nextlevel_xoff 0 131072
var p_nextlevel_yoff 0 131072
var p_nextlevel_zoff 0 131072
var p_nextlevel_zvel 0 131072
var p_nextlevel_ang 0 131072
var p_nextlevel_horiz 0 131072
var p_nextlevel_look_ang 0 131072
var p_nextlevel_rtc 0 131072
var p_killed 0 131072
var p_killed_left 0 131072
var p_secrets 0 131072
var p_secrets_left 0 131072
var p_access_saved 0 131072
var p_trigger_next 0 131072
var p_actors_killed_last
var p_secrets_transition

var p_needleveltransition 0 131072
var load_tile 0 131072
var load_black 1 131072
var last_ssize 0 131072

var p_ladderid -1 0     // This will store the id of the ladder sprite found
var p_laddermounted // Tells the game to consider that we've "mounted" a ladder
var p_ladder_x      // These cars are necessary to circumvent hardcoded behaviors
var p_ladder_y
var p_ladder_z
var p_ladder_ang
var p_sizzled_count

var p_ladder_horiz 100 0    // Use this var to allow smooth horiz transitions on ladders

var press_forward
var press_backward
var press_left
var press_right
var press_jump
var press_crouch
var press_kick


var p_nextlevel_ladder 0 131072

var p_save_x
var p_save_y
var p_save_z
var p_save_ang
var p_save_horiz
var p_save_sectnum

var p_nl_counter // only use this counter for level transitions!
var fade_amount
var profiler
/*
CUSTOM SPRITE STATS!
33 = rain
35 = waypoints
75 = moving sprite pivot/source
76 = moving sprite slave
*/

var level_text 1

eventloadactor SECTOREFFECTOR
    geta[].owner tp_owner
    geta[].yvel se_yvel
enda
eventloadactor LOCATORS
    geta[].owner tp_owner
enda

var se_ifspawn_once
appendevent EVENT_SPAWN
    ifactor SECTOREFFECTOR
    {
        // We save all of these vars so we
        // can hack settings later in case
        // the game decides to change the
        // original values after load.
        geta .hitag se_hitag
        geta .lotag se_lotag
        geta .extra se_extra
        geta .shade se_shade
        geta .ang se_ang
        geta .xvel se_xvel
        // geta[].yvel se_yvel
        geta[].zvel se_zvel

        switch se_lotag
            case 1
            case 66
            case 70
            case 71
            case 100
                break
            default
                setarray tainted[sprite[].sectnum] 1
                break
        endswitch
        set se_above 0
        
        ife se_ifspawn_once 0
        {
            for temp2 sprofstat STAT_MASTER_MOVER // pivots
            {
                ife sprite[temp2].picnum A_CLIP_BARRIER
                {
                    geta[temp2].cstat temp3
                    or temp3 32768
                    seta[temp2].cstat temp3
                }
                set temp sprite[temp2].hitag
                ifn -temp sprite[temp2].lotag // if not zero sum
                {
                    setav[temp2].pivot_hitag temp // sprite[temp2].hitag
                    setav[temp2].pivot_lotag sprite[temp2].lotag
                    seta[temp2].hitag 0
                    seta[temp2].lotag 0
                }
                ifg sprite[temp2].xvel 0
                {
                    setav[temp2].se_xvel sprite[temp2].xvel
                    seta[temp2].xvel 0
                }
            }

            for temp2 sprofstat STAT_SLAVE_MOVER // bits to move around, this is a fucking dumb hack! so so dumb... I hate this
            {
                ife sprite[temp2].picnum A_CLIP_BARRIER
                {
                    geta[temp2].cstat temp3
                    or temp3 32768
                    seta[temp2].cstat temp3
                }
                set temp sprite[temp2].hitag
                ifn -temp sprite[temp2].lotag // if not zero sum
                {
                    setav[temp2].pivot_hitag temp // sprite[temp2].hitag
                    setav[temp2].pivot_lotag sprite[temp2].lotag
                    seta[temp2].hitag 0
                    seta[temp2].lotag 0
                }
            }
            set se_ifspawn_once 1
        }
    }
    ifactor LOCATORS
    {
        // We save all of these vars so we
        // can hack settings later in case
        // the game decides to change the
        // original values after load.
        geta[].hitag se_hitag
        geta[].lotag se_lotag
        geta[].extra se_extra
        geta[].shade se_shade
        geta[].xvel se_xvel
        geta[].yvel se_yvel
        geta[].zvel se_zvel
        seta[].zvel 0
        seta[].yvel 0
        seta[].xvel 0
        set se_above 0
    }

endevent

action AC_RAIN 0 1 1 1 1
action AC_RAIN_SPLASH 0 6 1 1 1
eventloadactor A_RAINSPRITE
    geta .lotag se_lotag
    geta .hitag se_hitag
    geta .extra se_extra
    seta .lotag 0
    seta .hitag 0
    seta .extra 0
    geta .xvel pivot_xvel
    geta .yvel rain_vel
    ifl rain_vel 0
    {
        set counter3 1
        inv rain_vel
    }
    ifspawnedby SECTOREFFECTOR
        nullop
    else
    {
        seta .xvel 0
        seta .yvel 0
        seta .zvel 0
    }
enda
appendevent EVENT_SPAWN
    ifactor A_RAINSPRITE
        clipdist 2
endevent
useractor notenemy A_RAINSPRITE
    ifspawnedby SECTOREFFECTOR
        nullop
    else
    {
        ifaction 0
        {
            geta .x se_xvel
            geta .y se_yvel
            geta .z se_zvel
            action AC_RAIN
            cstat 32768
            geta .htflags temp
            or temp 4
            seta .htflags temp
        }
        add counter 1
        ifand pivot_xvel 1
        {
            ifrnd 96
            {
                ifl counter se_lotag
                    sub counter 1
            }
        }
        ifg rain_vel 0
            ife activateshit[rain_vel] 1
                xor counter3 1
        ife counter3 1
            ifaction AC_RAIN
            {
                ife counter se_lotag
                    set counter 0
                else ife se_lotag 0
                {
                    ifand sprite.cstat 32768
                        set counter 0
                }
            }
        ifg counter se_lotag
        {
            ife counter 1
                cstat 514
            else
                cstat 2
            fall
            ifg se_extra 0
            {
                seta .zvel se_extra
                seta .xvel 0
                ssp THISACTOR 0
            }
            iffloordistl 1
            {
                ifaction AC_RAIN
                {
                    ifn se_hitag 0
                        soundvar se_hitag
                    action AC_RAIN_SPLASH
                    geta .xrepeat temp
                    shiftr temp 1
                    seta .xrepeat temp
                    geta .yrepeat temp
                    shiftr temp 1
                    seta .yrepeat temp
                }
            }
            ifaction AC_RAIN_SPLASH
            {
                ifactioncount 6
                {
                    seta .x se_xvel
                    seta .y se_yvel
                    seta .z se_zvel
                    geta .xrepeat temp
                    shiftl temp 1
                    seta .xrepeat temp
                    geta .yrepeat temp
                    shiftl temp 1
                    seta .yrepeat temp
                    cstat 32768
                    action AC_RAIN
                    set counter 0
                }
            }
        }

    }
enda

spritenoshade A_RAINRIPPLE
spritenopal A_RAINRIPPLE
eventloadactor A_RAINRIPPLE
    seta[].xrepeat 2
    seta[].yrepeat 2
    seta[].cstat 546
    seta[].pal 0
    seta[].blend 129
    seta[].shade -72
enda
useractor notenemy A_RAINRIPPLE
    fall
    geta[].xrepeat temp
    add temp 4
    ifg temp 32
        killit
    seta[].xrepeat temp
    seta[].yrepeat temp
    cstat 546

enda

/*
New SE effects
------------------------
    SE64 - Warp sprite
    ------------------
    For hub map usage. Transition the player to a new map.

    EXTRA = MAP PART TO WARP TO (start at 0... 1... 2... etc)
    SHADE = VOLUME (Do not use! For testing only)
    HITAG = REFERENCE TAG

    SE65 - Destination Sprite
    -------------------------
    For hub map usage. After a warp the player will start at this location

    HITAG = REFERENCE TAG


    HUBSECTION (sprite 1409)
    ------------------------
    Place this in your map and give it a hitag indicating
    which piece of your level this map is.

    The first part should always be 0!!!!


    SE66 - Rain spawner
    -------------------------
    This will create rain in the current map. The rain itself
    appears in a radius around the player 16 of the largest
    BUILD squares wide, but it can't rain indoors!!!

    HITAG = NUMBER OF RAIN SPRITES (25 or more should produce a good effect)


    SE67/68 Pairs - Sector attribute copy
    -------------------------
    This copies all of the useful properties from one sector
    to another. This in no way effects sprites so watch for
    things like decals or other things that could give off
    an odd appearance. As this is used more there's the
    potential to make the system slightly more robust.

    SE67 gets its new attributes from SE68

    HITAG = REFERENCE TAG (shared among all sectors to be swapped)
    EXTRA = LINKING TAG (match this between SE pairs)


    SE69 - Wall Panning
    -------------------------
    Use this to pan all of the walls in a sector at a set
    rate. Not particularly robust at this time.

    X-VELOCITY = HOW MUCH TO PAN HORIZONTALLY
    Z-VELOCITY = HOW MUCH TO PAN VERTICALLY
    EXTRA = PANNING DELAY (30 = 1 second)


    SE70 - Shocker
    -------------------------
    Damages the player over time and causes the screen
    to flash white and play a "zap" sound.

    HITAG = AMOUNT TO DAMAGE PLAYER
    EXTRA = TIME BETWEEN DAMAGE/HITS


    TOUCHPLATE+ (sprite 5896)
    ------------------------
    When the player enters a sector with this sprite,
    this sprite will operate any ACTIVATORS with LOTAGS
    matching its HITAG (and also trigger custom HITAG
    based effects like sector swapping). This can be used
    to trigger multiple ACTIVATORS in a linear sequence
    with a delay between. The first HITAG will always
    trigger immediately.

    HITAG = REFERENCE/STARTING TAG
    LOTAG = NUMBER OF HITAGS IN THIS SEQUENCE (0-whatever)
    EXTRA = DELAY BETWEEN TRIGGERS.

*/

eventloadactor HUBSECTION_OLD
    geta[].hitag se_hitag
    geta[].extra se_extra
    seta[].cstat 32768
    cactor HUBSECTION
enda

useractor notenemy HUBSECTION_OLD
    // set current_part se_hitag
enda

eventloadactor HUBSECTION
    geta[].hitag se_hitag
    geta[].extra se_extra
    ifand sprite.cstat 512
        set se_above 1
    seta[].cstat 32768
enda

useractor notenemy HUBSECTION
    set current_part se_hitag
    ife se_above 1 ifg se_extra -1
    {
        set temp 0
        ifn userdef.music_level se_extra
            set temp 1
        ifn userdef.music_episode sprite.pal
            set temp 1
        ife temp 1
        {
            setu .volume_number sprite.pal
            setu .level_number se_extra
            starttrackslot sprite.pal sprite.extra
        }
    }
enda

eventloadactor A_MUSICFX_PLUS
    geta[].hitag se_hitag
    seta[].hitag 0
    geta[].lotag se_lotag
    seta[].lotag 0
    geta[].extra se_extra
    ifl se_extra 0
        set se_extra 0
    geta[].xvel se_xvel
    seta[].xvel 0
    geta[].yvel se_yvel
    seta[].yvel 0
    geta[].zvel se_zvel
    seta[].zvel 0
    cstat 32768
    geta[].owner tp_owner
enda

spritenoshade A_MUSICFX_PLUS
var mfx_swap 0 2
var mfx_do 0 2
var mfx_pitch 0 2
var mfx_kill 0 2
useractor notenemy A_MUSICFX_PLUS
    ifspritepal 9
    {
        set mfx_do 1
        spritepal 0
    }
    ife mfx_kill 1
    {
        killit
        break
    }
    ifand se_xvel 64
    {
        ife st_do_once 0
        {
            set st_do_once 1
            abs se_yvel
            ifg se_yvel 0
            {
                for itervar sprofstat STAT_MASTER_MOVER
                {
                    ife actorvar[itervar].pivot_hitag se_yvel
                        set pivot_master_id itervar
                }
                inv se_yvel
            }
        }
        ifn pivot_master_id -1
        {
            seta .x sprite[pivot_master_id].x
            seta .y sprite[pivot_master_id].y
            seta .z sprite[pivot_master_id].z
            seta .sectnum sprite[pivot_master_id].sectnum
        }
    }
    else ifand se_xvel 128
    {
        ife st_do_once 0
        {
            set st_do_once 1
            scalevar mfx_pitch se_yvel SEMITONE_CONSTANT SEMITONE_CONSTANT_DIVISOR
            set se_yvel 0
        }
    }
    ifn mfx_pitch 0
        setp .sound_pitch mfx_pitch
    ifand se_xvel 8
    {

         // triggered
        ifand se_xvel 16
            gets[].ceilingshade temp
        else
            gets[].floorshade temp
        ife temp sprite[].shade
        {
            ifand se_xvel 2 // if [ambient + triggered] bit is set and has been activated
            {
                    set temp 0
                    ifle se_yvel 0
                        set temp 1
                    else ifl userdef[].vm_distance se_yvel
                        set temp 1
                    ifg se_zvel 0
                    {
                        ife temp 1
                        {
                            ife se_zvel counter
                                set counter 0
                            else
                            {
                                add counter 1
                                set temp 0
                            }
                            ifand se_xvel 4 // introduces a randomizer if requested
                                ifrnd 64
                                    set temp 0
                        }
                        else
                        {
                            ife se_zvel counter
                                set counter 0
                            else
                                add counter 1
                        }
                    }
                    ife temp 1 // if we're okay to play a sound
                    {
                        ifand se_xvel 1 // wait until deactivation to play the alternate sound
                            set temp se_lotag
                        else
                        {
                            rand temp se_extra
                            add temp se_lotag
                        }
                        soundvar temp
                    }
            }
            else
            {
                ifand se_xvel 1 // play a different sound on deactivation
                {
                    ife mfx_swap 0
                    {
                        set temp se_lotag
                        set mfx_swap 1
                    }
                }
                else
                {
                    rand temp se_extra
                    add temp se_lotag
                }
                soundvar temp
            }
        }
        else
        {
            ifand se_xvel 1 // play a different sound on deactivation
            {
                ifn mfx_swap 0
                {
                    set temp se_extra
                    set mfx_swap 0
                    soundvar temp
                }
            }
            set counter se_zvel
        }
    }
    else ife se_hitag 0 // ambient
    {
        set temp 0
        ifle se_yvel 0
            set temp 1
        else ifl userdef[].vm_distance se_yvel // cutoff distance!
            set temp 1
        ifg se_zvel 0
        {
            ife temp 1
            {
                ife se_zvel counter
                    set counter 0
                else
                {
                    add counter 1
                    set temp 0
                }
                ifand se_xvel 4 // introduces a randomizer if requested
                    ifrnd 64
                        set temp 0
            }
            else
            {
                ife se_zvel counter
                    set counter 0
                else
                    add counter 1
            }
        }
        ife temp 1 // if we're okay to play a sound
        {
            ifand se_xvel 1 // alternate between two sounds
            {
                ife mfx_swap 0
                {
                    set temp se_lotag
                    set mfx_swap 1
                }
                else
                {
                    set temp se_extra
                    set mfx_swap 0
                }
            }
            else // random sound range
            {
                rand temp se_extra
                add temp se_lotag
            }
            ifn se_extra 0
                soundvar temp
            else
                soundoncevar temp
        }
    }
    else ifn se_hitag 0
    {
        ife activateshit[se_hitag] 1 // triggered
            set mfx_do 1
        ifg tp_owner 0
        {
            ife mfx_swap 1
            {
                ife activateshit[tp_owner] 1 // triggered from another tag to turn off
                {
                    set mfx_do 1
                    ifand se_xvel 512
                        set mfx_kill 1
                }
            }
            else ifand se_xvel 512
                ife activateshit[tp_owner] 1
                    set mfx_kill 1
        }
        ife mfx_do 1
        {
            ifand se_xvel 1 // play a different sound on deactivation
            {
                ife mfx_swap 0
                {
                    set temp se_lotag
                    set mfx_swap 1
                }
                else
                {
                    set temp se_extra
                    set mfx_swap 0
                }
                soundvar temp
            }
            else
            {
                rand temp se_extra
                add temp se_lotag
                ife mfx_swap 0
                    set mfx_swap 1
                else
                    set mfx_swap 0
                ifand se_xvel 2
                {
                    ife mfx_swap 1
                        soundvar temp
                    else
                    {
                        set temp2 se_lotag
                        add temp2 se_extra
                        add temp2 1
                        set temp se_lotag
                        whilen temp temp2
                        {
                            stopactorsound THISACTOR temp
                            add temp 1
                        }
                    }
                }
                else
                    soundvar temp
                ifand se_xvel 32
                {
                    ife mfx_swap 0
                    {
                        ifand se_xvel 1
                        {
                            stopactorsound THISACTOR se_lotag
                        }
                        else
                        {
                            set temp2 se_lotag
                            add temp2 se_extra
                            add temp2 1
                            set temp se_lotag
                            whilen temp temp2
                            {
                                stopactorsound THISACTOR temp
                                add temp 1
                            }
                        }
                    }
                    else ifand se_xvel 1
                        stopactorsound THISACTOR se_extra
                    
                }
            }
            set mfx_do 0
        }
        else ifand se_xvel 2 // if [ambient + triggered] bit is set and has been activated
        {
            ife mfx_swap 1 // if turned on
            {
                set temp 0
                ife se_yvel 0
                    set temp 1
                else ifl userdef[].vm_distance se_yvel
                    set temp 1
                ifg se_zvel 0
                {
                    ife temp 1
                    {
                        ife se_zvel counter
                            set counter 0
                        else
                        {
                            add counter 1
                            set temp 0
                        }
                        ifand se_xvel 4 // introduces a randomizer if requested
                            ifrnd 64
                                set temp 0
                    }
                    else
                    {
                        ife se_zvel counter
                            set counter 0
                        else
                            add counter 1
                    }
                }
                ife temp 1 // if we're okay to play a sound
                {
                    ifand se_xvel 1 // wait until deactivation to play the alternate sound
                        set temp se_lotag
                    else
                    {
                        rand temp se_extra
                        add temp se_lotag
                    }
                    ifand se_xvel 256
                        soundvar temp
                    else
                        soundoncevar temp
                }
            }
        }
    }
    setp .sound_pitch 0
enda

eventloadactor A_TOUCHPLATE_PLUS
    geta[].hitag se_hitag
    geta[].lotag se_lotag
    geta[].extra se_extra
    geta[].xvel se_xvel
    geta[].yvel se_yvel
    geta[].zvel se_zvel
    seta[].hitag 0
    seta[].lotag 0
    seta[].xvel 0
    seta[].yvel 0
    seta[].zvel 0
    geta[].owner tp_owner
enda

var tp_num 0 2

useractor notenemy A_TOUCHPLATE_PLUS
    sleeptime 300
    cstat 32768
    ife st_do_once 0
    {
        set st_do_once 1
        ifn sector[].floorz sector[].ceilingz
            set tp_countone 1
    }
    ifl se_extra 0
        set se_extra 0
    ifg se_zvel 0
    {
        ifand se_xvel 128
            nullop
        else ifn counter 0
        {
            for temp2 range tp_total
            {
                set temp tp_list[temp2]
                ifn temp THISACTOR
                    ife actorvar[temp].se_zvel se_zvel
                        seta[temp].xrepeat 0
            }
            set se_zvel 0
        }
    }

    ifg tp_owner 0
    {
        set temp 0
        ifand se_xvel 512
            ifg se_yvel 0
                set temp 1
        ife temp 0
        {
            ifand se_xvel 256
            {
                set tp_activated 1
                xor se_xvel 256
            }
            ife activateshit[tp_owner] 1
                set tp_activated 1
        }
    }
    ifg se_yvel 0
    {
        ife activateshit[se_yvel] 1
        {
            ifand se_xvel 32
                nullop
            else
                inv se_yvel
        }
        ife counter 0
            break
    }
    else ifl se_yvel 0
    {
        ifand se_xvel 16 // reverse
        {
            set temp se_yvel
            abs temp
            ife activateshit[temp] 1
                inv se_yvel
        }
    }
    ife se_lotag 0
    {
        ife counter 0
        {
            ifand se_xvel 8
                nullop
            else ife player[].cursectnum sprite[].sectnum
            {
                operateactivators se_hitag THISACTOR
                operatemasterswitches se_hitag
                operaterespawns se_hitag
                setarray preloadactivations[se_hitag] 1
                set counter 1
            }
            ife sector[].floorz sector[].ceilingz
            {
                ifand se_xvel 4
                    xor se_xvel 4
                else
                {
                    operateactivators se_hitag THISACTOR
                    operatemasterswitches se_hitag
                    operaterespawns se_hitag
                    setarray preloadactivations[se_hitag] 1
                }
                set counter 2
            }
            ife tp_activated 1
            {
                operateactivators se_hitag THISACTOR
                operatemasterswitches se_hitag
                operaterespawns se_hitag
                setarray preloadactivations[se_hitag] 1
                set counter 1
                set tp_activated 0
            }
        }
        else
        {
            ife counter 2
            {
                ifn sector[].floorz sector[].ceilingz
                {
                    ifspritepal 9
                        set counter 0
                    else
                    {
                        operateactivators se_hitag THISACTOR
                        operatemasterswitches se_hitag
                        operaterespawns se_hitag
                        setarray preloadactivations[se_hitag] 1
                        set counter 0
                    }
                }
            }
            else ifn player[].cursectnum sprite[].sectnum ife sector[].lotag 0 ifspritepal 9
                    set counter 0
        }
    }
    else
    {
        ife tp_closed 1
        {
            ifand se_xvel 4
                nullop
            else ifn sector[].floorz sector[].ceilingz
            {
                ifand se_xvel 64
                {
                    ifle counter se_extra
                        add counter 1
                    else ifg counter se_extra
                    {
                        set counter tp_countone
                        set tp_num 0
                        set tp_closed 0
                    }
                }
                else
                    set tp_closed 0
            }
        }      
        ifand se_xvel 8
            set temp7 -2
        else
            set temp7 sprite.sectnum
        ife player[].cursectnum temp7 ife counter 0
            set counter 1
        else ife sector[].floorz sector[].ceilingz ife counter 0
                set counter 1
        else ife tp_activated 1 ife counter 0
        {
            set counter 1
            set tp_activated 0
        }
        else ifn player[].cursectnum temp7 ifn counter 0 ifg se_lotag 0 ifg tp_num se_lotag ifspritepal 9
        {
            ife tp_activated 1
            {
                set counter 0
                set tp_num 0
            }
            else ife sector[].floorz sector[].ceilingz
                nullop
            else
            {
                set counter 0
                set tp_num 0
            }
        }
        ifn player.cursectnum temp7 ife sector.floorz sector.ceilingz // this is stupid
            set tp_closed 1
        
        ifg se_lotag 0
        {
            ifle tp_num se_lotag
            {

                ife counter 1
                {
                    set temp tp_num
                    ifand se_xvel 1
                    {
                        sub temp se_hitag
                        abs temp
                    }
                    else
                        add temp se_hitag
                    ifand se_xvel 4
                        nullop
                    else
                    {
                        operateactivators temp THISACTOR
                        operatemasterswitches temp
                        operaterespawns temp
                        setarray preloadactivations[temp] 1
                    }
                    add tp_num 1
                }
                ifle counter se_extra ifg counter 0
                    add counter 1
                else ifg counter se_extra
                    set counter 1
            }
            else
            {
                ifand se_xvel 4
                    xor se_xvel 4
                ifand se_xvel 2
                {
                    ifle counter se_extra
                        add counter 1
                    else ifg counter se_extra
                    {
                        set counter 1
                        set tp_num 0
                    }
                }
            }
        }
    }
enda

eventloadactor A_EOL
    geta .hitag se_hitag
    geta .lotag se_lotag
    geta .extra se_extra
    geta .yvel se_yvel
    seta .yvel 0
    seta .hitag 0
    seta .lotag 0
enda

var eol_type


appendevent EVENT_WORLD
    ife outro_screen_do 1
    {
        set curr_screen_totalclock totalclock
        set curr_screen_count 0
        set curr_screen_o_count -1
        set curr_screen_fade_count 0
        stopallmusic
        stopallsounds
        starttrackslot 0 30
        set curr_screen SCREEN_OUTRO
        startscreen
        stopallsounds
        ife outro_screen_do 3
            nullop
        else
            set outro_screen_do 0
        set eol_stage 5
        set p_eol 30
        stopallmusic
        setp[myconnectindex].sound_pitch 256
        globalsound S_SWITCH_CARDUNLOCK
        globalsound S_CORKPULL
        setp[myconnectindex].sound_pitch 0
        set load_black 0
        /* setu .vm_player myconnectindex
        set load_black 1
        set g_playtics 0
        setp .gm 3 */
    }
endevent
appendevent EVENT_USE
    ifg p_eol 0
        ifl p_eol 90
            set RETURN -1
endevent
defstate eol_clear_131072
    set load_text 0
    set keepstatssafe 0
    set p_nextlevel -1
    set p_nextepisode -1
    set p_nextlevel_tag -1
    set p_nextlevel_xoff 0
    set p_nextlevel_yoff 0
    set p_nextlevel_zoff 0
    set p_nextlevel_zvel 0
    set p_nextlevel_ang 0
    set p_nextlevel_horiz 0
    set p_nextlevel_look_ang 0
    set p_nextlevel_rtc 0
    set p_killed 0
    set p_killed_left 0
    set p_secrets 0
    set p_secrets_left 0
    set p_access_saved 0
    set p_secrets_area 0
    set p_secrets_area_got 0
    set p_airleft 390
    set fly 0
    set skip_see 0
    set footloose 0
    set pause_ai 0
    set see_breadcrumbs 0
    set last_see_breadcrumbs 0

    set p_hazard_amount 0
    set p_firstgrenade 0
    set p_idle_timer 0
    ifg p_pup_bomb_time 0
    {
        setp .curr_weapon p_pup_bomb_before
        getp .ammo_amount p_pup_bomb_before hud_ammo
        setp .kickback_pic p_pup_old_kickback
        set p_pup_reset_fire 8
        setp .weapon_pos 9
        setp .ammo_amount WEAPON_BOWLINGBOMB p_pup_bomb_ammo
        setp .gotweapon WEAPON_BOWLINGBOMB p_pup_bomb_got
    }
    set p_pup_bomb_time 0
    set p_pup_bomb_before 0
    set p_pup_bomb_ammo 0
    set p_pup_bomb_got 0
    set p_pup_old_kickback 0
    set p_pup_reset_fire 0
    set p_pup_radar_time 0
    set p_pup_damage_time 0
    set p_pup_jump_time 0

    set p_needleveltransition 0
    set load_tile 0
    set load_black 1
    set last_ssize 0
    set p_nextlevel_ladder 0

    set g_playtics 0
    set yahahayoufoundme 0
ends

defstate calc_game_stat
    set temp3 game_session_stat
    set temp4 game_session_stat
    shiftr temp3 16
    and temp4 0xFFFF
    
    ife p_killed 0
        set temp 100
    else
    {
        set temp p_killed_left
        mul temp 100
        div temp p_killed
    }
    ife p_secrets 0
        set temp2 100
    else
    {
        set temp2 p_secrets_left
        mul temp2 100
        div temp2 p_secrets
    }
    add temp3 temp
    add temp4 temp2
    shiftl temp3 16
    set game_session_stat temp3
    or game_session_stat temp4
ends
useractor notenemy A_EOL
    sleeptime 300
    cstat 32768
    ifg se_yvel 0
    {
        ife counter2 0
            ife activateshit[se_yvel] 1
                set counter2 1
    }
    ife player.cursectnum sprite.sectnum
        set counter2 1
    ife counter2 1 ife counter 0
    {
        set counter 1 // 8
        stopallsounds
        state calc_game_stat
    }
    ifn counter 0
    {
        ifn p_eol 0 ifl p_eol 65536
        {
            ife p_eol 1
            {
                switch LEVEL
                    case EP_MAIN_ZONE_1_END
                        or cheevo_tracker 2
                        break
                    case EP_MAIN_ZONE_2_END
                        break
                    case EP_MAIN_ZONE_3_END
                        break
                    case EP_MAIN_ZONE_4_END
                        break
                    case EP_MAIN_ZONE_5_END
                        break
                    case EP_MAIN_ZONE_6_END
                        break
                    case EP_MAIN_ZONE_7_END
                        ifge userdef.player_skill 4
                            or cheevo_tracker 134217728
                        break
                    case EP_MAIN_ZONE_S_END
                        break
                    default
                        break
                endswitch
                stopallsounds
                ifspritepal 8
                {
                    set counter 127
                    palfrom 63 0 0 0
                    setvar load_black 1
                    set outro_screen_do 1
                }
                else
                    starttrackslot -1 1
            }
            ifl p_eol 3
                stopallsounds              

            add p_eol 1
        }
        ife outro_screen_do 3
        {
            set counter3 63
            set outro_screen_do 0
        }
        ifg counter3 0
        {
            setp .pals 0 counter3
            setp .pals 1 counter3
            setp .pals 2 counter3
            setp .pals_time counter3
            sub counter3 1
        }
        
        ifg counter 127
            set counter 127

        lockplayer 10
        ifspritepal 8
        {
            setp .poszv 0
            setp .posxv 0
            setp .posyv 0
            setp .on_ground 0
            setp .falling_counter 0
            set temp3 game_session_stat
            set temp4 game_session_stat
            shiftr temp3 16
            and temp4 0xFFFF
            div temp3 EP_MAIN_NUMZONES
            div temp4 EP_MAIN_NUMZONES
            ifge temp3 100 ifge temp4 100 ifg p_eol 40
                ife p_eol 41
                globalsound S_SHELLY_KISSY
            ife p_eol 450
                starttrackslot 0 14
        }
        set fade_amount counter
        setp[].jumping_counter 1

        for temp allsprites
        {
            ifand tiledata[sprite[temp].picnum].gameflags 32 ifg sprite[temp].extra 0
            {
                changespritestat temp STAT_ZOMBIEACTOR
                seta[temp].httimetosleep 32767
            }
        }
        setp[].weapon_pos 1
        setp[].jumping_counter 0
        ife p_eol 0
            set p_eol 1
        ifspritepal 8
            set eol_type 2
        else ifspritepal 9
            set eol_type 0
        else
            set eol_type 1

        ife counter 127
        {
            set temp6 0
            for temp6 range NUMWALLS
            {
                setarray walls_x[temp6] 0
                setarray walls_y[temp6] 0
            }
        }
        add counter 1
        ife sprite[].pal 9
                nullop
        else ifg eol_relay 0
        {
            ife eol_relay 1
            {
                set eol_relay 0
                set eol_stage 0
                for temp range 64
                    clearmapstate temp
                state eol_clear_131072
                setarray sectpal[8192] 0
                set load_black 1
                ife sprite[].pal 8
                {
                    set load_black 1
                    set g_playtics 0
                    set eol_type 0
                    setp .gm 3
                }
                else
                    startlevel se_hitag se_lotag
            }
            else
            {
                sub eol_relay 1
                ifspritepal 8
                {
                    sub eol_relay 2
                    clamp eol_relay 1 65536
                }
            }
        }
    }

enda

appendevent EVENT_CHANGEMENU
    switch RETURN
        case 50
            ife eol_type 2
            {
                getp[].gm temp
                ifand temp 1
                    xor temp 1
                set RETURN -2
            }
            break
    endswitch
endevent

appendevent EVENT_OPENMENUSOUND
    ife eol_type 2
        set RETURN -1
endevent

eventloadactor A_AUTOSAVE
    geta[].hitag se_hitag
    geta[].lotag se_lotag
    geta[].extra se_extra
    seta[].hitag 0
    seta[].lotag 0
enda
useractor notenemy A_AUTOSAVE
    sleeptime 300
    cstat 32768
    ife se_hitag 0
    {
        ife player[].cursectnum sprite[].sectnum
        {
            ifn userdef[].autosave 0
                setvar need_autosave 1
            killit
        }
    }
    else ife activateshit[se_hitag] 1
    {
        ifn userdef[].autosave 0
            setvar need_autosave 1
        // set autosave_hitag -1
        ife se_lotag 1
            nullop
        else
            killit
    }
enda
/*
start all = z N (-76160) pal 80 stat 12 tile 9800 slope 0 shade 11 pan 205 42
0=  +2048   0   110 7508    -1024   18  111 201
1=  +256    1   76  7507    0       12  205 42
2= -4224    80  94  6316    6144    14  219 17
3= -4224    80  126 6316    -1536   16  219 41
4= -4224    80  94  6316    -1536   17  219 17
5= -4224    80  110 6316    6144    16  30  63
9268 idle
5925 flush
*/
eventloadactor A_TOILET_FX
    geta .hitag se_hitag
    geta .lotag se_lotag
    seta .hitag 0
    seta .lotag 0
    ifand sprite.cstat 512
        or se_above 512
enda
var toilet_flush 0 2
state do_flush_pic
    ifg toilet_flush 279
    {
        for temp4 wallsofsector sprite[temp6].sectnum
           ife wall[temp4].picnum 9268
                setw[temp4].picnum 5925
    }
    else ife toilet_flush 279
    {
        for temp4 wallsofsector sprite[temp6].sectnum
            ife wall[temp4].picnum 5925
                setw[temp4].picnum 9268
    }
ends
useractor notenemy A_TOILET_FX 0 // this "hard codes" the toilet effect so there is much less setup cost
    ife st_do_once 0
    {
        setarray tainted[sprite[].sectnum] 1
        switch se_lotag
            case 0
                cstat 32768
                cstator 512
                set actor_switch 1
                ifspritepal 9
                {
                    gets[].floorz se_zvel
                    sub se_zvel 2048
                    gets[].floorshade se_shade
                    sub se_shade 7
                    for temp6 sprofstat STAT_ACTOR
                    {
                        ife sprite[temp6].picnum A_TOILET_FX
                        {
                            ife actorvar[temp6].se_hitag se_hitag
                                seta[temp6].pal 9
                        }
                    }
                }
                else
                {
                    gets[].floorz se_zvel
                    gets[].floorshade se_shade
                    cstator 32
                }
                sizeat 64 64
                break
            case 6
                cstat 32768
                cstator 16
                cstator 512
                set actor_switch 1
                break
            default
                cstat 32768
                break
        endswitch
        set st_do_once 1
    }
    ife se_lotag 6
    {
        ifhitspace
        {
            ifpdistl 1536 ife actor_switch_usable 1
            {
                ife counter 0
                {
                    ife toilet_flush 0
                    {
                        set toilet_flush 285
                        sound 2861
                    }
                }
            }
            set counter 1
        }
        else
            set counter 0
        ifn toilet_flush 0
        {
            sub toilet_flush 1
            for temp6 sprofstat STAT_ACTOR
            {
                ife sprite[temp6].picnum A_TOILET_FX
                {
                    ife actorvar[temp6].se_hitag se_hitag
                    {
                        switch actorvar[temp6].se_lotag
                            case 0
                                geta[temp6].sectnum temp3
                                setav[temp6].toilet_flush toilet_flush
                                ife sprite[temp6].pal 9
                                {
                                    ife toilet_flush 0
                                    {
                                        sets[temp3].floorpicnum 7508
                                        ifand se_above 512
                                            nullop
                                        else
                                            sets[temp3].floorpal 0
                                        sets[temp3].floorstat 110
                                        sets[temp3].floorslope -1024
                                        sets[temp3].floorxpanning 111
                                        sets[temp3].floorypanning 201
                                        getav[temp6].se_shade temp
                                        add temp 7
                                        sets[temp3].floorshade temp
                                    }
                                    else
                                    {
                                        sets[temp3].floorpicnum 6288
                                        ifand se_above 512
                                            nullop
                                        else
                                            sets[temp3].floorpal 0
                                        sets[temp3].floorstat 122
                                        sets[temp3].floorslope -1024
                                        sets[temp3].floorxpanning 111
                                        sets[temp3].floorypanning 201
                                        getav[temp6].se_shade temp
                                        add temp 2
                                        sets[temp3].floorshade temp
                                    }
                                }
                                else
                                {
                                    sets[temp3].floorpicnum 9800
                                    ifand se_above 512
                                        nullop
                                    else
                                        sets[temp3].floorpal 80
                                    sets[temp3].floorstat 12
                                    sets[temp3].floorslope 0
                                    sets[temp3].floorxpanning 205
                                    sets[temp3].floorypanning 42
                                    sets[temp3].floorshade actorvar[temp6].se_shade
                                }
                                // 6288 122 111 201 2shade 0pal
                                break
                            case 2
                            case 3
                            case 4
                            case 5
                                state do_flush_pic
                                break
                        endswitch
                    }
                }
            }
        }
        set actor_switch_usable 0
        break
    }

    ife se_lotag 0
    {
        ifspritepal 0
        {
            cstator 32
            sizeat 64 64
        }
        else
        {
            ifand sprite[].cstat 32
            {
                geta[].cstat temp
                xor temp 32
                seta[].cstat temp
            }
            sizeat 80 64
        }
        ifhitspace
        {
            ifpdistl 1536 ife actor_switch_usable 1
            {
                ife counter 0
                {
                    ifspritepal 0
                        sound 2862
                    else
                        sound 2863
                    for temp6 sprofstat STAT_ACTOR
                    {
                        ife sprite[temp6].picnum A_TOILET_FX
                        {
                            ife actorvar[temp6].se_hitag se_hitag
                            {
                                geta[temp6].sectnum temp3
                                ife sprite[temp6].pal 0
                                {
                                    seta[temp6].pal 9
                                    switch actorvar[temp6].se_lotag
                                        case 0
                                            ife toilet_flush 0
                                            {
                                                sets[temp3].floorpicnum 7508
                                                ifand se_above 512
                                                    nullop
                                                else
                                                    sets[temp3].floorpal 0
                                                sets[temp3].floorstat 110
                                                sets[temp3].floorslope -1024
                                                sets[temp3].floorxpanning 111
                                                sets[temp3].floorypanning 201
                                                set temp se_zvel
                                                add temp 2048
                                                sets[temp3].floorz temp
                                                set temp se_shade
                                                add temp 7
                                                sets[temp3].floorshade temp
                                            }
                                            else
                                            {
                                                sets[temp3].floorpicnum 6288
                                                ifand se_above 512
                                                    nullop
                                                else
                                                    sets[temp3].floorpal 0
                                                sets[temp3].floorstat 122
                                                sets[temp3].floorslope -1024
                                                sets[temp3].floorxpanning 111
                                                sets[temp3].floorypanning 201
                                                set temp se_zvel
                                                add temp 2048
                                                sets[temp3].floorz temp
                                                set temp se_shade
                                                add temp 2
                                                sets[temp3].floorshade temp
                                            }
                                            break
                                        case 1
                                            sets[temp3].floorpicnum 7507
                                            ifand se_above 512
                                                nullop
                                            else
                                                sets[temp3].floorpal 1
                                            sets[temp3].floorstat 76
                                            sets[temp3].floorslope 0
                                            sets[temp3].floorxpanning 205
                                            sets[temp3].floorypanning 42
                                            set temp se_zvel
                                            add temp 256
                                            sets[temp3].floorz temp
                                            set temp se_shade
                                            add temp 1
                                            sets[temp3].floorshade temp
                                            break
                                        case 2
                                            sets[temp3].floorpicnum 6316
                                            ifand se_above 512
                                                nullop
                                            else
                                                sets[temp3].floorpal 80
                                            sets[temp3].floorstat 94
                                            sets[temp3].floorslope 6144
                                            sets[temp3].floorxpanning 219
                                            sets[temp3].floorypanning 17
                                            set temp se_zvel
                                            add temp -4224
                                            sets[temp3].floorz temp
                                            set temp se_shade
                                            add temp 3
                                            sets[temp3].floorshade temp
                                            break
                                        case 3
                                            sets[temp3].floorpicnum 6316
                                            ifand se_above 512
                                                nullop
                                            else
                                                sets[temp3].floorpal 80
                                            sets[temp3].floorstat 126
                                            sets[temp3].floorslope -1536
                                            sets[temp3].floorxpanning 219
                                            sets[temp3].floorypanning 41
                                            set temp se_zvel
                                            add temp -4224
                                            sets[temp3].floorz temp
                                            set temp se_shade
                                            add temp 5
                                            sets[temp3].floorshade temp
                                            break
                                        case 4
                                            sets[temp3].floorpicnum 6316
                                            ifand se_above 512
                                                nullop
                                            else
                                                sets[temp3].floorpal 80
                                            sets[temp3].floorstat 94
                                            sets[temp3].floorslope -1536
                                            sets[temp3].floorxpanning 219
                                            sets[temp3].floorypanning 17
                                            set temp se_zvel
                                            add temp -4224
                                            sets[temp3].floorz temp
                                            set temp se_shade
                                            add temp 6
                                            sets[temp3].floorshade temp
                                            break
                                        case 5
                                            sets[temp3].floorpicnum 6316
                                            ifand se_above 512
                                                nullop
                                            else
                                                sets[temp3].floorpal 80
                                            sets[temp3].floorstat 110
                                            sets[temp3].floorslope 6144
                                            sets[temp3].floorxpanning 30
                                            sets[temp3].floorypanning 63
                                            set temp se_zvel
                                            add temp -4224
                                            sets[temp3].floorz temp
                                            set temp se_shade
                                            add temp 5
                                            sets[temp3].floorshade temp
                                            break
                                    endswitch
                                }
                                else
                                {
                                    seta[temp6].pal 0
                                    switch actorvar[temp6].se_lotag
                                        case 0
                                        case 1
                                        case 2
                                        case 3
                                        case 4
                                        case 5
                                            sets[temp3].floorpicnum 9800
                                            ifand se_above 512
                                                nullop
                                            else
                                                sets[temp3].floorpal 80
                                            sets[temp3].floorstat 12
                                            sets[temp3].floorslope 0
                                            sets[temp3].floorxpanning 205
                                            sets[temp3].floorypanning 42
                                            sets[temp3].floorz se_zvel
                                            sets[temp3].floorshade se_shade
                                            break
                                    endswitch
                                }
                            }
                        }
                    }
                }
            }
            set counter 1
        }
        else
            set counter 0
        set actor_switch_usable 0
    }
enda

action AC_URINAL_IDLE 0 1 1 1 1
action AC_URINAL_FLUSH -3352 7 1 1 12
action AC_URINAL_WATER -3347 2 1 1 8
useractor notenemy A_URINAL 0 AC_URINAL_IDLE
    set actor_switch 1
    cstator 257
    ifhitspace
    {
        ifpdistl 1536 ife actor_switch_usable 1
        {
            ife counter 0
            {
                ifaction AC_URINAL_IDLE
                {
                    action AC_URINAL_FLUSH
                    setp[].sound_pitch 640
                    sound S_TOILET_FLUSH
                    setp[].sound_pitch 0
                    set toilet_flush 285
                }
            }
        }
        set counter 1
    }
    else
        set counter 0
    ifaction AC_URINAL_FLUSH
    {
        ifactioncount 7
            action AC_URINAL_WATER
    }
    else ifaction AC_URINAL_WATER
    {
        ifactioncount 2
            action AC_URINAL_IDLE
    }
    ifn toilet_flush 0
    {
        sub toilet_flush 1
        ife toilet_flush 0
            stopactorsound THISACTOR S_TOILET_FLUSH
    }
    set actor_switch_usable 0
enda


eventloadactor A_BOX_FX
    geta[].hitag se_hitag
    geta[].lotag se_lotag
    geta[].extra se_extra
    geta[].yvel se_yvel
    clamp se_extra 0 65536
    clamp se_yvel 0 65536
    seta[].hitag 0
    seta[].lotag 0
    seta[].yvel 0
enda

useractor notenemy A_BOX_FX
    cstat 32768
	geta[].yrepeat temp9
    ife se_lotag 0
    {
        cstator 544
        set actor_switch 1
    }
    set temp8 0
    ifhitspace
        ifpdistl 1536
            ife actor_switch_usable 1
                set temp8 1
    ifg se_yvel 0
        ife activateshit[se_yvel] 1
            set temp8 1
    ife temp8 1
    {
        ife se_lotag 0
        {
            geta .sectnum temp
            gets[temp].floorz temp2
            add temp2 2816
            sets[temp].floorz temp2
            sets[temp].floorpicnum 5663
            sets[temp].floorstat 92
            sets[temp].floorxpanning 254
            sets[temp].floorypanning 14
            gets[temp].floorshade temp2
            sub temp2 2
            clamp temp2 -127 127
            sets[temp].floorshade temp2
            ifg se_extra 0
            {
                sound S_PICKUP03
                espawn se_extra
                seta[RETURN].z temp2
            }
            sound S_DOOR_METAL_2_OPEN
        }
        for temp6 sprofstat STAT_ACTOR
        {
            ife sprite[temp6].picnum A_BOX_FX
            {
                ife actorvar[temp6].se_hitag se_hitag
                {
                    switch actorvar[temp6].se_lotag
                        case 1
                            geta[temp6].sectnum temp
                            gets[temp].floorz temp2
                            sub temp2 2816
                            sets[temp].floorz temp2
                            sets[temp].floorstat 88
							ifg temp9 150
							{
								sets[temp].floorxpanning 4
								sets[temp].floorpicnum 7643
							} else {
								sets[temp].floorxpanning 252
								sets[temp].floorpicnum 7642
							}
                            sets[temp].floorypanning 10
                            gets[temp].floorshade temp2
                            sub temp2 2
                            clamp temp2 -127 127
                            sets[temp].floorshade temp2
                            break
                        case 2
                            geta[temp6].sectnum temp
                            gets[temp].floorz temp2
                            add temp2 768
                            sets[temp].floorz temp2
                            sets[temp].floorstat 120
							ifg temp9 150
							{
								sets[temp].floorxpanning 252
								sets[temp].floorpicnum 7643
							} else {
								sets[temp].floorxpanning 240
								sets[temp].floorpicnum 7642
							}
                            sets[temp].floorypanning 64
                            gets[temp].floorshade temp2
                            sub temp2 2
                            clamp temp2 -127 127
                            sets[temp].floorshade temp2
                            break
                        case 3
                            ifg actorvar[temp6].se_extra 0
                            {
                                geta[temp6].sectnum temp
                                gets[temp].floorz temp2
                                espawn actorvar[temp6].se_extra
                                seta[RETURN].z temp2
                                seta[RETURN].x sprite[temp6].x
                                seta[RETURN].y sprite[temp6].y
                                seta[RETURN].sectnum temp
                                ifactorsound THISACTOR S_PICKUP03
                                    nullop
                                else
                                    sound S_PICKUP03
                            }
                            break
                    endswitch
                    seta[temp6].xrepeat 0
                }
            }
        }
    }
    set actor_switch_usable 0
enda

eventloadactor A_SHOOTER
    geta[].hitag se_hitag
    geta[].lotag se_lotag
    geta[].extra se_extra
    ifl se_extra 0
        set se_extra 0
    geta[].xvel se_xvel
    geta[].yvel se_yvel
    geta[].zvel se_zvel
    geta[].shade se_shade
    seta[].hitag 0
    seta[].lotag 0
    seta[].xvel 0
    seta[].yvel 0
    seta[].zvel 0
    geta[].owner tp_owner
    cstat 32768
enda
var shooter_num 0 2

defstate shot_picnum
    switch se_lotag
        case 0 set se_lotag P_LOVERBOY break
        case 1 set se_lotag P_FIREBALL break
        case 2 set se_lotag P_PLASMA_BOLT break
        case 3 set se_lotag P_MINIGUN break
        case 4 set se_lotag P_SMG break
        case 5 set se_lotag P_TURRET break
        case 6 set se_lotag P_BOMBETTE break
        case 7 set se_lotag P_SHOTGUN break
        case 8 set se_lotag P_GRENADE break
        case 9 set se_lotag P_SHOCKER break
        case 10 set se_lotag P_SMOKE2 break
        case 11 set se_lotag P_BLOOD break
        case 12 set se_lotag P_GIB_SPINE break
        case 13 set se_lotag P_GIB_SKULL break
        case 14 set se_lotag P_GIB_SKULL_LS break
        case 15 set se_lotag P_GIB_SKULL_GR break
        case 16 set se_lotag P_GIB_CHUNK1 break
        case 17 set se_lotag P_GIB_INTESTINE break
        case 18 set se_lotag P_GIB_MEAT break
        case 19 set se_lotag P_GIB_LUNG break
        case 20 set se_lotag P_GIB_LIVER break
        case 21 set se_lotag P_GIB_CHUNK2 break
        case 22 set se_lotag P_GIB_HEART break
        case 23 set se_lotag P_GIB_EYE break
        case 24 set se_lotag P_GIB_ARM break
        case 25 set se_lotag P_GIB_LEG_LS break
        case 26 set se_lotag P_GIB_LEG_GR break
        case 27 set se_lotag P_GIB_LEG_SECT break
        case 28 set se_lotag P_SMG2 break
        case 29 set se_lotag A_SHELL1 break
        case 30 set se_lotag P_NAPALM_BALL break
        case 31 set se_lotag P_FLAMINGSKULL break
        case 32 set se_lotag P_DANCINGQUEEN break
        case 33 set se_lotag P_ACIDYSPIT break
        case 34 set se_lotag P_MINIMISSILE break
        case 35 set se_lotag P_MINIMISSILE set se_above 1 break
        default set se_lotag P_LOVERBOY break
    endswitch
ends
useractor notenemy A_SHOOTER
    ife st_do_once 0
    {
        set st_do_once 1
        ifand se_yvel 1
            nullop
        else
            state shot_picnum
        ife se_shade 0
            set h_zvel 0
        else
        {
            set htzvel se_shade
            scalevar htzvel htzvel 157 100 // (htzvel * 157)/100
            shiftl htzvel 7
            inv htzvel
        }
    }
    ifspritepal 9
    {
        set counter 1
        spritepal 0
    }
    sleeptime 300

    set temp THISACTOR
    ife activateshit[se_hitag] 1
    {
        ife actorvar[temp].counter 0
        {
            setav[temp].counter 1
            setav[temp].shooter_num 0
        }
        else
            setav[temp].counter 0
    }
    ifg tp_owner 0
    {
        ife activateshit[tp_owner] 1
            killit
    }
    ifn counter 0
    {
        ife counter 1
        {
            ifg se_lotag 0
            {
                getprojectile[se_lotag].workslike temp9
                ifand se_yvel 2
                {
                    set temp2 temp9
                    or temp2 4096
                    setprojectile[se_lotag].workslike temp2
                }
                ife se_lotag P_MINIMISSILE
                {
                    ifand se_yvel 2
                        ezshoot htzvel P_MINIMISSILE
                    else
                        eshoot P_MINIMISSILE
                    ife se_above 1
                    {
                        geta[RETURN].xrepeat temp3
                        shiftl temp3 1
                        seta[RETURN].xrepeat temp3
                        geta[RETURN].yrepeat temp3
                        shiftl temp3 1
                        seta[RETURN].yrepeat temp3
                        getthisprojectile[RETURN].extra_rand temp3
                        mul temp3 3
                        shiftr temp3 1
                        setthisprojectile[RETURN].extra_rand temp3
                        geta[RETURN].extra temp3
                        shiftl temp3 1
                        seta[RETURN].extra temp3
                        getthisprojectile[RETURN].extra temp3
                        shiftl temp3 1
                        setthisprojectile[RETURN].extra temp3
                    }
                }
                else
                    ezshoot htzvel se_lotag
                setprojectile[se_lotag].workslike temp9
            }

        }
        ifn se_extra 0
        {
            add counter 1
            ifg counter se_extra
            {
                set counter 1
                ifg se_zvel 0
                {
                    add shooter_num 1
                    ifge shooter_num se_zvel
                    {
                        set counter 0
                    }
                }
            }
        }
        else
            set counter 0
    }
enda

eventloadactor A_KILLEMALL
    cstat 32768
    geta[].lotag se_lotag
    geta[].hitag se_hitag
    geta[].extra se_extra
    geta[].xvel se_xvel
    geta[].yvel se_yvel
    clamp se_extra 0 65536
    clamp se_hitag 0 65536
    seta[].lotag 0
    seta[].hitag 0
    seta[].extra 0
    seta[].xvel 0
    seta[].yvel 0
enda

useractor notenemy A_KILLEMALL
    sleeptime 300
    ifspritepal 9
    {
        set counter 1
        spritepal 0
    }
    set temp THISACTOR
    ifn actorvar[temp].se_lotag 0
        ife activateshit[actorvar[temp].se_lotag] 1
        {
            ife actorvar[temp].counter 0
                setav[temp].counter 1
            else
            {
                ifand actorvar[temp].se_extra 8
                    setav[temp].counter 1
                else
                    setav[temp].counter 0
            }
        }

    ifn counter 0
    {
        ifand se_extra 64
            set temp9 0
        for temp spritesofsector sprite[].sectnum
        {
            ifand tiledata[sprite[temp].picnum].gameflags 32
            {
                ifg sprite[temp].extra 0
                {
                    ifand se_extra 64
                        set temp9 1
                    set temp2 0
                    ifand se_extra 2
                    {
                        ifg sprite[temp].z sprite[].z
                            set temp2 1
                    }
                    else ifand se_extra 4
                    {
                        ifl sprite[temp].z sprite[].z
                            set temp2 1
                    }
                    else
                        set temp2 1
                    ifand se_extra 16
                    {
                        ifg se_xvel 0
                        {
                            ife temp2 1
                            {
                                ldist temp3 temp THISACTOR
                                ifg temp3 se_xvel
                                   set temp2 0 
                            }
                        }
                    }
                    ife temp2 1
                    {
                        ife sprite[temp].statnum STAT_ZOMBIEACTOR
                            changespritestat temp STAT_ACTOR
                        setav[temp].enemy_init 1
                        setav[temp].se_hitag 0
                        seta[temp].htextra sprite[temp].extra
                    }
                }
                ifand se_extra 1
                    setav[temp].enemy_gibbed 1
            }
            ifand se_extra 32
            {
                ife temp player[].i
                {
                    ifg sprite[temp].extra 0
                    {
                        set temp2 0
                        ifand se_extra 2
                        {
                            ifg sprite[temp].z sprite[].z
                                set temp2 1
                        }
                        else ifand se_extra 4
                        {
                            ifl sprite[temp].z sprite[].z
                                set temp2 1
                        }
                        else
                            set temp2 1
                        ifand se_extra 16
                        {
                            ifg se_xvel 0
                            {
                                ife temp2 1
                                {
                                    ldist temp3 temp THISACTOR
                                    ifg temp3 se_xvel
                                       set temp2 0
                                }
                            }
                        }
                        ife temp2 1
                        {
                            ife userdef[].god 1
                            {
                                ifrnd 16 ife player[].pals_time 0
                                    palfrom 10 20 0 0
                            }
                            else
                            {
                                seta[temp].htextra sprite[temp].extra
                                globalsound S_GIBSPLODE03
                                globalsound S_IMPACT_HEADSHOT
                                ifand se_extra 64
                                    set temp9 1
                            }
                        }
                    }
                }
            }
        }
        ifn se_hitag 0
        {
            add counter 1
            ifg counter se_hitag
                set counter 0
        }
        ifand se_extra 64
            ife temp9 1
            {
                ifg se_yvel 0
                {
                    operateactivators se_yvel THISACTOR
                    operatemasterswitches se_yvel
                    operaterespawns se_yvel
                    setarray preloadactivations[se_yvel] 1
                    ifand se_extra 128
                        xor se_extra 64
                }
            }
    }
enda

eventloadactor A_SECRET
    cstat 32768
    geta[].lotag se_lotag
    geta[].hitag se_hitag
    geta[].extra se_extra
    clamp se_extra 0 65536
    clamp se_hitag 0 65536
    seta[].lotag 0
    seta[].hitag 0
    seta[].extra 0
    set counter -1
enda

useractor notenemy A_SECRET
    sleeptime 300
    ife st_do_once 0
    {
        ifn sprite[].pal 9
        {
            getp[].max_secret_rooms temp
            add temp 1
            setp[].max_secret_rooms temp
        }
        set st_do_once 1
    }
    ifg se_lotag 0
    {
        ife counter -1
        {
            ife activateshit[se_lotag] 1
            {
                set temp2 0
                ifand se_extra 1
                {
                    ifg sprite[player[].i].z sprite[].z
                        set temp2 1
                }
                else ifand se_extra 2
                {
                    ifl sprite[player[].i].z sprite[].z
                        set temp2 1
                }
                else
                    set temp2 1
                ife temp2 1
                    set counter se_hitag
            }
        }
    }
    else ife se_lotag 0 ife player[].cursectnum sprite[].sectnum ife counter -1
    {
        set temp2 0
        ifand se_extra 1
        {
            ifg sprite[player[].i].z sprite[].z
                set temp2 1
        }
        else ifand se_extra 2
        {
            ifl sprite[player[].i].z sprite[].z
                set temp2 1
        }
        else
            set temp2 1
        ife temp2 1
            set counter se_hitag
    }
    ifg counter -1
    {
        sub counter 1
        ifle counter 0
        {
            ifspritepal 9
            {
                set p_secret_quote 360
                set yahahayoufoundme 1
                ife LEVEL LV_X
                    ife VOLUME EP_MAIN
                        set yahahayoufoundme2 1
                actorsound player[].i S_SUPER_SECRET
                    ife VOLUME EP_MAIN
                    {
                        switch LEVEL
                            case 3
                                or cheevo_tracker 1048576
                                break
                            case 8
                                or cheevo_tracker 2097152
                                break
                            case 16
                                or cheevo_tracker 8388608
                                break
                            case 22
                                or cheevo_tracker 16777216
                                break
                            case 24
                                or cheevo_tracker 33554432
                                break
                        endswitch
                    }
            }
            else
            {
                getp[].secret_rooms temp
                add temp 1
                setp[].secret_rooms temp
                set p_secret_quote 9
            }
            killit
        }
    }
enda

eventloadactor A_SHELLYSOUND
    cstat 32768
    geta[].lotag se_lotag
    geta[].hitag se_hitag
    geta[].extra se_extra
    geta[].xvel se_xvel
    clamp se_extra 0 65536
    clamp se_hitag 0 65536
    seta[].lotag 0
    seta[].hitag 0
    seta[].extra 0
enda

useractor notenemy A_SHELLYSOUND
    sleeptime 300
    ife counter 0
    {
        ife activateshit[se_lotag] 1
        {
            set counter 1
            ife se_lotag 5460
            {
                ife VOLUME EP_MAIN
                    ife LEVEL 0
                        or cheevo_tracker 131072
            }
        }
    }
    else ifn counter 0
    {
        ifg counter se_extra
        {
            stopactorsound player[].i S_SHELLY_SEARCHTALK1
            stopactorsound player[].i S_SHELLY_SEARCHTALK2
            stopactorsound player[].i p_lastline
            setarray sound_playback[p_lastline] 0
            ifg se_xvel 0
            {
                ifrnd 127
                    set p_lastline se_xvel
                else
                    set p_lastline se_hitag
            }
            else
                set p_lastline se_hitag
            actorsound player[].i p_lastline
            ifspritepal 9 // multi-use like TP+
            {
                set counter 0
                break
            }
            else
                killit
        }
        add counter 1
    }
enda

var o_picnum 0 2
var redcast 0 2
var o_pal 0 2
eventloadactor A_HESKELCAST
    cstat 32768
    geta[].lotag se_lotag
    geta[].hitag se_hitag
    ifle se_hitag 0
        set se_hitag S_HES_X_JUMBOTRON
    geta[].extra se_extra
    geta[].xvel se_xvel
    seta[].xvel 0
    clamp se_xvel 0 65536
    ifle se_extra 0
        set se_extra 140
    clamp se_extra 30 65536
    clamp se_hitag 0 65536
    seta[].lotag 0
    seta[].hitag 0
    seta[].extra 0
    geta[].yvel se_yvel
    seta[].yvel 0
    clamp se_yvel 7 30
enda

defstate verify_monitor_1
    switch sprite[temp].picnum
        case A_MONITOR_2
        case A_MONITOR_3
        case A_MONITOR_5
        case A_MONITOR_6
        case A_MONITOR_7
        case A_MONITOR_9
        case A_MONITOR_8
        case A_MONITOR_10
        case A_MONITOR_11
        case A_MONITOR_12
        case A_MONITOR_13
        case A_MONITOR_14
        case A_MONITOR_17
            ldist temp2 player.i temp
            ifand actorvar[temp].se_hitag 16
                nullop            
            else ife temp3 -1
            {
                set temp3 temp2
                set temp4 temp
            }
            else ifl temp2 temp3
            {
                set temp3 temp2
                set temp4 temp
            }
            break
        case A_MONITOR_2_LG
        case A_MONITOR_3_LG
        case A_MONITOR_17_LG
            ldist temp2 player.i temp
            ifand actorvar[temp].se_hitag 16
                nullop
            else ife temp3 -1
            {
                set temp3 temp2
                set temp4 temp
            }
            else ifl temp2 temp3
            {
                set temp3 temp2
                set temp4 temp
            }
            break
        case A_MONITOR_STATIC
        case A_MONITOR_STATIC_LG
            ifand actorvar[temp].se_hitag 16
                nullop
            else ife actorvar[temp].counter2 0
            {
                ldist temp2 player.i temp
                ife temp3 -1
                {
                    set temp3 temp2
                    set temp4 temp
                }
                else ifl temp2 temp3
                {
                    set temp3 temp2
                    set temp4 temp
                }
            }
            break
    endswitch
ends

defstate wakeupyoungmonitor
    switch sprite[temp].picnum
        case A_MONITOR_2
        case A_MONITOR_3
        case A_MONITOR_5
        case A_MONITOR_6
        case A_MONITOR_7
        case A_MONITOR_9
        case A_MONITOR_8
        case A_MONITOR_10
        case A_MONITOR_11
        case A_MONITOR_12
        case A_MONITOR_13
        case A_MONITOR_14
        case A_MONITOR_17
        case A_MONITOR_2_LG
        case A_MONITOR_3_LG
        case A_MONITOR_17_LG
        case A_MONITOR_STATIC
        case A_MONITOR_STATIC_LG
            seta[temp].httimetosleep 300
            changespritestat temp STAT_ACTOR
            break
    endswitch
ends

var static_rot 0 2
var static_sound 0 2
var static_2 -1 2
var static_3 -1 2
var last_cast
appendevent EVENT_ENTERLEVEL
    set last_cast 0
endevent
appendevent EVENT_WORLD
    ifg last_cast 0
        sub last_cast 1
endevent
useractor notenemy A_HESKELCAST
    sleeptime 300
    cstat 32768
    ife counter 0
    {
        set counter3 0
        ife activateshit[se_lotag] 1
        {
            set counter 1
            ife VOLUME 0
                ife LEVEL 0
                    or cheevo_tracker 1
        }
    }
    ifg counter 0
    {
        ifl counter se_yvel
        {
            set temp3 -1
            set temp4 -1
            for temp sprofstat STAT_ZOMBIEACTOR
                state wakeupyoungmonitor
            for temp sprofstat STAT_ACTOR
                state verify_monitor_1

            ifn temp4 -1
            {
                ifg tilesizy[sprite[temp4].picnum] 64
                    seta[temp4].picnum A_MONITOR_STATIC_LG
                else
                    seta[temp4].picnum A_MONITOR_STATIC
                setav[temp4].counter2 se_hitag
                setav[temp4].counter3 counter3
                ifn last_cast 0
                    setav[temp4].static_sound -2
                setav[temp4].o_pal sprite[temp4].pal
                seta[temp4].pal 0
                ifspritepal 9
                    setav[temp4].redcast 1
                setav[temp4].tp_owner THISACTOR
                setav[temp4].db_odd -1
            }
            ife db_odd 0
                add counter3 1
            xor db_odd 1
        }
        ifand se_xvel 1
        {
            ife counter 1
                actorsound player.i S_HESKEL_STATIC
            else ife counter 30
            {
                stopactorsound player.i S_HESKEL_STATIC
                actorsound player.i se_hitag
            }
        }
        add counter 1
        ifg counter se_extra
        {
            for temp sprofstat STAT_ZOMBIEACTOR
            {
                switch sprite[temp].picnum
                    case A_MONITOR_HESKEL_LG
                    case A_MONITOR_HESKEL_R_LG
                    case A_MONITOR_HESKEL
                    case A_MONITOR_HESKEL_R
                        seta[temp].httimetosleep 300
                        changespritestat temp STAT_ACTOR
                        break
                endswitch
            }
            for temp sprofstat STAT_ACTOR
            {
                switch sprite[temp].picnum
                    case A_MONITOR_HESKEL
                    case A_MONITOR_HESKEL_R
                        seta[temp].picnum A_MONITOR_STATIC
                        setav[temp].counter2 -1
                        setav[temp].db_temp se_hitag
                        seta[temp].pal actorvar[temp].o_pal
                        break
                    case A_MONITOR_HESKEL_LG
                    case A_MONITOR_HESKEL_R_LG
                        seta[temp].picnum A_MONITOR_STATIC_LG
                        setav[temp].counter2 -1
                        setav[temp].db_temp se_hitag
                        seta[temp].pal actorvar[temp].o_pal
                        break
                endswitch
                
            }
            ifand se_xvel 1
            {
                stopactorsound player.i se_hitag
                actorsound player.i S_HESKEL_STATIC
                set p_terminate_hs 1
            }
            set last_cast 30
            killit
        }
    }
enda

defstate invisible_monitor
    ifand se_hitag 2
    {
        cstat 32768
        geta .picnum temp
        add temp sprite.htg_t 3
        ifand se_hitag 4
        {
            switch sector.floorpicnum
                case A_MONITOR_2_3_BROKE
                case A_MONITOR_2_3_BROKE_LG
                    seta .htextra 100
                    set temp sector.floorpicnum
                 break
            endswitch
            sets .floorpicnum temp
            ifand se_hitag 8
            {
                switch sector.ceilingpicnum
                    case A_MONITOR_2_3_BROKE
                    case A_MONITOR_2_3_BROKE_LG
                        seta .htextra 100
                        set temp sector.ceilingpicnum
                     break
                endswitch
                sets .ceilingpicnum temp
            }
        }
        else
        {
            switch sector.ceilingpicnum
                case A_MONITOR_2_3_BROKE
                case A_MONITOR_2_3_BROKE_LG
                    seta .htextra 100
                    set temp sector.ceilingpicnum
                 break
            endswitch
            sets .ceilingpicnum temp
        }
        ifand se_hitag 1
            seta .htextra -1
    }
ends

action AC_MONITOR_H 0 1 1 1 1
useractor notenemy A_MONITOR_HESKEL 1 AC_MONITOR_H
    cstator 257
    ifaction AC_MONITOR_H
    {
        seta .htg_t 2 db_once
        seta .htg_t 3 db_once
        add db_odd 1
        ife db_odd 5
        {
            set temp db_once
            ifn tp_owner -1
            {
                getav[tp_owner].counter2 db_once
                mod db_once 9
            }
            else
                rand db_once 8
            ife db_once temp
            {
                add db_once 1
                mod db_once 9
                set db_odd 2
            }
            else
                set db_odd 0
        }
    }
    else
        action AC_MONITOR_H
    ifand se_hitag 1
        seta .htextra -1
    state invisible_monitor
    ifg sprite.htextra 0
    {
        action AC_MONITOR_H
        stopactorsound THISACTOR counter2
        cactor A_MONITOR_3
    }
enda

useractor notenemy A_MONITOR_HESKEL_LG 1 AC_MONITOR_H
    cstator 257
    ifaction AC_MONITOR_H
    {
        seta .htg_t 2 db_once
        seta .htg_t 3 db_once
        add db_odd 1
        ife db_odd 5
        {
            set temp db_once
            ifn tp_owner -1
            {
                getav[tp_owner].counter2 db_once
                mod db_once 9
            }
            else
                rand db_once 8
            ife db_once temp
            {
                add db_once 1
                mod db_once 9
                set db_odd 2
            }
            else
                set db_odd 0
        }
    }
    else
        action AC_MONITOR_H
    ifand se_hitag 1
        seta .htextra -1
    state invisible_monitor
    ifg sprite.htextra 0
    {
        action AC_MONITOR_H
        stopactorsound THISACTOR counter2
        cactor A_MONITOR_3_LG
    }
enda

useractor notenemy A_MONITOR_HESKEL_R 1 AC_MONITOR_H
    set temp 0
    seta .htg_t 2 temp
    getav[tp_owner].counter2 db_once
    ifl db_once 32
    {
        set temp db_once
        mod temp 4
        add temp 244
        sound S_HESKEL_STATIC
    }
    else
        stopactorsound THISACTOR S_HESKEL_STATIC
    seta .htg_t 3 temp
    
    
    ifand se_hitag 1
        seta .htextra -1
    state invisible_monitor
    ifg sprite.htextra 0
    {
        action AC_MONITOR_H
        stopactorsound THISACTOR counter2
        cactor A_MONITOR_3
    }
enda

useractor notenemy A_MONITOR_HESKEL_R_LG 1 AC_MONITOR_H
    set temp 0
    seta .htg_t 2 temp
    getav[tp_owner].counter2 db_once
    ifl db_once 32
    {
        set temp db_once
        mod temp 4
        add temp 1
        inv temp
        sound S_HESKEL_STATIC
    }
    else
        stopactorsound THISACTOR S_HESKEL_STATIC
    seta .htg_t 3 temp
    
    
    ifand se_hitag 1
        seta .htextra -1
    state invisible_monitor
    ifg sprite.htextra 0
    {
        action AC_MONITOR_H
        stopactorsound THISACTOR counter2
        cactor A_MONITOR_3_LG
    }
enda

useractor notenemy A_MONITOR_17 1 AC_MONITOR_H
    cstator 257
    ifand se_hitag 1
        seta .htextra -1
    state invisible_monitor
    ifg sprite.htextra 0
        cactor A_MONITOR_3
enda

useractor notenemy A_MONITOR_17_LG 1 AC_MONITOR_H
    cstator 257
    ifand se_hitag 1
        seta .htextra -1
    state invisible_monitor
    ifg sprite.htextra 0
        cactor A_MONITOR_3_LG
enda

useractor notenemy A_MONITOR_STATIC 1 AC_MONITOR_H
    cstator 257    
    ifaction AC_MONITOR_H
        nullop
    else
        action AC_MONITOR_H
    ifg counter2 0
    {
        ife redcast 0
        {
            add static_rot 1
            mod static_rot 8
            ifn static_2 -1
            {
                seta .htg_t 2 static_2
                seta .htg_t 3 static_3
            }
            ifrnd 64
            {
                set temp static_rot
                sub temp 268
                ife static_2 -1
                {
                    set static_2 sprite.htg_t 2
                    set static_3 sprite.htg_t 3
                }
                seta .htg_t 2 temp
                seta .htg_t 3 temp
            }
            ife static_sound 0
                sound S_HESKEL_TONE
        }
        ifle static_sound 0
            sound S_HESKEL_STATIC
        set static_sound 1
        add counter3 1
        ifg counter3 30
        {
            action AC_MONITOR_H
            stopactorsound THISACTOR S_HESKEL_STATIC
            soundvar counter2
            set counter3 0
            ife redcast 1
                cactor A_MONITOR_HESKEL_R
            else
                cactor A_MONITOR_HESKEL
        }
    }
    else ifl counter2 0
    {
        ife redcast 0
        {
            add static_rot 1
            mod static_rot 8
            ifn static_2 -1
            {
                seta .htg_t 2 static_2
                seta .htg_t 3 static_3
            }
            ifrnd 64
            {
                set temp static_rot
                sub temp 268
                ife static_2 -1
                {
                    set static_2 sprite.htg_t 2
                    set static_3 sprite.htg_t 3
                }
                seta .htg_t 2 temp
                seta .htg_t 3 temp
            }
        }
        ife counter3 0
            sound S_HESKEL_STATIC
        add counter3 1
        ifg counter3 15
        {
            stopactorsound THISACTOR S_HESKEL_STATIC
            seta .htg_t 2 0
            seta .htg_t 3 0
            action AC_MONITOR_H
            set counter3 0
            cactor A_MONITOR_3
        }
    }
    ifand se_hitag 1
        seta .htextra -1
    state invisible_monitor
    ifg sprite.htextra 0
    {
        stopactorsound THISACTOR S_HESKEL_STATIC
        ifg db_temp 0
            stopactorsound THISACTOR db_temp
        seta .htg_t 2 0
        seta .htg_t 3 0
        action AC_MONITOR_H
        cactor A_MONITOR_3
    }
enda

useractor notenemy A_MONITOR_STATIC_LG 1 AC_MONITOR_H
    cstator 257    
    ifaction AC_MONITOR_H
        nullop
    else
        action AC_MONITOR_H
    ifg counter2 0
    {
        ife redcast 0
        {
            add static_rot 1
            mod static_rot 8
            ifn static_2 -1
            {
                seta .htg_t 2 static_2
                seta .htg_t 3 static_3
            }
            ifrnd 64
            {
                set temp static_rot
                add temp 16
                ife static_2 -1
                {
                    set static_2 sprite.htg_t 2
                    set static_3 sprite.htg_t 3
                }
                seta .htg_t 2 temp
                seta .htg_t 3 temp
            }
            ife static_sound 0
                sound S_HESKEL_TONE
        }
        ifle static_sound 0
            sound S_HESKEL_STATIC
        set static_sound 1
        add counter3 1
        ifg counter3 30
        {
            action AC_MONITOR_H
            stopactorsound THISACTOR S_HESKEL_STATIC
            soundvar counter2
            set counter3 0
            ife redcast 1
                cactor A_MONITOR_HESKEL_R_LG
            else
                cactor A_MONITOR_HESKEL_LG
        }
    }
    else ifl counter2 0
    {
        add static_rot 1
        mod static_rot 8
        ife redcast 0 
        {
            add static_rot 1
            mod static_rot 8
            ifn static_2 -1
            {
                seta .htg_t 2 static_2
                seta .htg_t 3 static_3
            }
            ifrnd 64
            {
                set temp static_rot
                add temp 16
                ife static_2 -1
                {
                    set static_2 sprite.htg_t 2
                    set static_3 sprite.htg_t 3
                }
                seta .htg_t 2 temp
                seta .htg_t 3 temp
            }
        }
        ife counter3 0
            sound S_HESKEL_STATIC
        add counter3 1
        ifg counter3 15
        {
            stopactorsound THISACTOR S_HESKEL_STATIC
            set counter3 0
            seta .htg_t 2 0
            seta .htg_t 3 0
            action AC_MONITOR_H
            cactor A_MONITOR_3_LG
        }
    }
    ifand se_hitag 1
        seta .htextra -1
    state invisible_monitor
    ifg sprite.htextra 0
    {
        stopactorsound THISACTOR S_HESKEL_STATIC
        ifg db_temp 0
            stopactorsound THISACTOR db_temp
        seta .htg_t 2 0
        seta .htg_t 3 0
        action AC_MONITOR_H
        cactor A_MONITOR_3_LG
    }
enda


var fuck
var fuck2
var fuck3
var fuck4
var fuck5
var fuck6

defstate swapwalls
    for temp5 wallsofsector temp3
    {
        ifg wall[temp5].hitag 1
        {
            for temp7 wallsofsector temp4
            {
                ife wall[temp7].hitag wall[temp5].hitag
                {
                    ifand se_xvel 2
                    {
                        setw[temp5].picnum wall[temp7].picnum
                        setw[temp5].xrepeat wall[temp7].xrepeat
                        setw[temp5].yrepeat wall[temp7].yrepeat
                        setw[temp5].xpanning wall[temp7].xpanning
                        setw[temp5].ypanning wall[temp7].ypanning
                    }
                    else
                    {
                        setw[temp5].cstat wall[temp7].cstat
                        setw[temp5].picnum wall[temp7].picnum
                        ifand wall[temp5].cstat 16
                            setw[temp5].overpicnum wall[temp7].overpicnum
                        else ifand wall[temp5].cstat 32
                            setw[temp5].overpicnum wall[temp7].overpicnum
                        setw[temp5].shade wall[temp7].shade
                        setw[temp5].pal wall[temp7].pal
                        setw[temp5].extra wall[temp7].extra
                        setw[temp5].xrepeat wall[temp7].xrepeat
                        setw[temp5].yrepeat wall[temp7].yrepeat
                        setw[temp5].xpanning wall[temp7].xpanning
                        setw[temp5].ypanning wall[temp7].ypanning
                    }
                }
            }
        }
    }
ends

defstate divide_ru_camera
    mul temp3 10
    div temp3 se_xvel
    set temp4 temp3
    abs temp4
    mod temp4 10
    ifge temp4 5
    {
        ifl temp3 0
            sub temp3 10
        else
            add temp3 10
    }
    div temp3 10
ends

var se_game_run
//var timediff
//var lastdiff
//var lastdiffcount
// array topicalcream 15
appendevent EVENT_WORLD

    /* for temp sprofstat STAT_ACTIVATOR
    {
        ife sprite[temp].picnum ACTIVATORLOCKED
        {
            setu[].vm_sprite temp
            setu[].vm_player myconnectindex
            redefinequote 11 %ld %ld %ld %ld %ld %ld
            qsprintf 11 11 sprite[].hitag sprite[].extra sprite[].xvel sprite[].yvel sprite[].zvel sector[sprite[].sectnum].lotag
            setp[].fta 99
            setp[].ftq 11
        }
    } */
   /* set temp 0
    whilen temp 15
    {
        setarray topicalcream[temp] 0
        add temp 1
    } */
    //getticks timediff
    for se_game_run range se_game_num
    {
        set temp se_game[se_game_run]
        switch actorvar[temp].se_lotag
            case 64
                /* set temp5 topicalcream[0]
                add temp5 1
                setarray topicalcream[0] temp5 */
                set temp2 myconnectindex // this is dumb, but preserving this for properness later
                getav[temp].se_above se_abv
                setu[].vm_sprite temp // these didn't exist when originally coded
                setu[].vm_player myconnectindex
                set temp4 0
                
                ife counter 0
                {
                    ifg se_xvel 0
                        ife activateshit[se_xvel] 1
                            set counter 1
                    ife player[temp2].cursectnum sprite[temp].sectnum
                        set counter 1
                }
                ife counter 1 ife p_nextlevel -1
                {
                    ife se_abv 1
                    {
                        ifl sprite[temp].z player[temp2].posz
                            set se_abv 2
                        else ifg sprite[temp].z player[temp2].posz
                            set se_abv 3

                        setav[temp].se_above se_abv
                    }
                    else ife se_abv 0
                        setav[temp].se_above 1
                    getflorzofslope sprite[temp].sectnum sprite[temp].x sprite[temp].y temp3

                    set temp4 0
                    ifn temp3 sprite[temp].z
                    {
                        ife se_abv 2 ifl player[temp2].posz sprite[temp].z
                            set temp4 1
                         else ife se_abv 3 ifg player[temp2].posz sprite[temp].z
                            set temp4 1
                    }
                    else
                        set temp4 1

                    ife temp4 1 ifp palive
                    {
                        set counter 0
                        getav[temp].se_hitag p_nextlevel_tag
                        getav[temp].se_extra p_nextlevel
                        getav[temp].se_shade temp3
                        abs temp3
                        set p_nextepisode temp3

                        getp[temp2].posx p_nextlevel_xoff
                        sub p_nextlevel_xoff sprite[temp].x
                        getp[temp2].posy p_nextlevel_yoff
                        sub p_nextlevel_yoff sprite[temp].y
                        getp[temp2].posz p_nextlevel_zoff
                        sub p_nextlevel_zoff sprite[temp].z
                        
                        getp .poszv p_nextlevel_zvel
                        // sub p_nextlevel_zoff 482

                        // if the player is on a ladder adjust the offset to avoid
                        // getting shoved into the wrong sector at map load

                        // note: this gives us a one frame visual where you are
                        // away from the ladder, but technically it's less buggy
                        // hope to find a better solution later
                        ife p_laddermounted 1
                        {
                            div p_nextlevel_xoff 3
                            div p_nextlevel_yoff 3
                            setp[].posxv 0
                            setp[].posyv 0
                            setp[].poszv 0
                        }

                        getp[temp2].ang p_nextlevel_ang
                        getp[temp2].horiz p_nextlevel_horiz
                        getp[temp2].look_ang p_nextlevel_look_ang
                        getp[temp2].return_to_center p_nextlevel_rtc
                        setp[temp2].pyoff 0
                        setp[temp2].opyoff 0
                        ifn player[temp2].got_access 0
                            getp[temp2].got_access p_access_saved

                        setav[temp].se_above 0
                        setp[temp2].movement_lock 15
                        getp[temp2].actors_killed p_actors_killed_last
                        getp[temp2].secret_rooms p_secrets_transition
                        savemapstate
                        getu[].clipping save_noclip
                        setu[].clipping 0
                        set p_actors_killed_last 0
                        set p_secrets_transition 0
                        set num_flag32 0
                        set se_game_num 0
                        set se_displayrooms_num 0
                        set keepstatssafe 2
                        set intro_screen_do 2
                        set temp6 0
                        ifand se_zvel 1
                            set skip_autosave 1
                        for temp6 range NUMWALLS
                        {
                            setarray walls_x[temp6] 0
                            setarray walls_y[temp6] 0
                            // add temp6 1
                        }
                        for temp6 range NUMSECTORS
                            setarray tainted[temp6] 0
                        setarray sectpal[8192] 0
                        set temp2 LEVEL
                        sub temp2 current_part
                        add p_nextlevel temp2
                        // use a var that is guaranteed to keep value between map loads
                        ife p_laddermounted 1
                            set p_nextlevel_ladder 1

                        ife se_force_ep -1
                            getu[].volume_number p_nextepisode
                        
                        ifl p_secrets_area 0
                        {
                            ifg p_nextlevel LEVEL
                            {
                                for temp6 range 64
                                    clearmapstate temp6
                            }
                            else
                                inv p_secrets_area
                        }
                            
                        startlevel p_nextepisode p_nextlevel

                        set load_tile 0
                    }
                }
                else
                    setav[temp].se_above 0
                set counter 0
                break
            case 66
                /* set temp5 topicalcream[1]
                add temp5 1
                setarray topicalcream[1] temp5 */
                // do rain shit
                getav[temp].rain_amount temp2
                getav[temp].se_hitag temp3
                ifn temp2 temp3
                {
                    setav[temp].rain_amount temp3

                    set temp4 myconnectindex
                    getp[temp4].i temp4
                    setav[temp4].rain_amount temp3
                }
                ifn temp2 0
                {
                    set rain_fail 0
                    for temp2 sprofstat STAT_RAIN
                    {
                        setu[].vm_sprite temp
                        getav[temp].se_xvel temp5
                        setav[temp2].se_xvel temp5
                        getav[temp2].rain_counter temp5 // this will be our control var (rain_counter)
                        ifle temp5 -1
                        {
                            seta[temp2].x sprite[temp].x
                            seta[temp2].y sprite[temp].y
                            seta[temp2].z sprite[temp].z
                            seta[temp2].sectnum sprite[temp].sectnum
                            seta[temp2].picnum A_RAINSPRITE
                            add temp5 1
                            clamp temp5 -3 0
                            setav[temp2].rain_counter temp5
                            seta[temp2].cstat 32768
                            set temp5 -1 // marker to not execute code later
                        }
                        ifge rain_fail 3
                        {
                            seta[temp2].x sprite[temp].x
                            seta[temp2].y sprite[temp].y
                            seta[temp2].z sprite[temp].z
                            seta[temp2].sectnum sprite[temp].sectnum
                            seta[temp2].picnum A_RAINSPRITE
                            setav[temp2].rain_counter 0
                            seta[temp2].cstat 32768
                            set temp5 -1
                            add rain_fail 1
                            ifg rain_fail 6
                                set rain_fail 0
                        }
                        else ife temp5 0
                        {
                            set temp3 myconnectindex // change later?
                            // rain x
                            getp[temp3].posx temp4
                            ifand se_xvel 4
                                rand temp5 24575
                            else
                                rand temp5 12287

                            ifrnd 127
                                inv temp5
                            set temp7 temp5
                            add temp4 temp5
                            seta[temp2].x temp4

                            // rain y
                            getp[temp3].posy temp4
                            ifand se_xvel 4
                                rand temp5 24575
                            else
                                rand temp5 12287

                            ifrnd 127
                                inv temp5
                            set temp9 temp5
                            add temp4 temp5
                            seta[temp2].y temp4


                            seta[temp2].z player[temp3].posz

                            set temp5 player[temp3].cursectnum
                            updatesectorz sprite[temp2].x sprite[temp2].y sprite[temp2].z temp5
                            ife temp5 -1
                            {
                                add rain_fail 1
                                setav[temp2].rain_counter -4
                            }
                            ifn temp5 -1
                            {
                                gets[temp5].ceilingstat temp4
                                setu[].vm_sprite temp
                                set temp6 0
                                ifl counter 30
                                {
                                    set temp6 1
                                    ifrnd 64
                                        set temp6 0
                                    add counter 1
                                }
                                set temp8 0
                                ifand se_xvel 128
                                {
                                    ifn cam_id -1
                                    {
                                        getav[cam_id].se_extra cam_xoff
                                        ifn cam_xoff 1
                                            shiftr temp7 3
                                        geta[cam_id].x cam_xoff
                                        add cam_xoff temp7
                                        
                                        getav[cam_id].se_extra cam_yoff
                                        ifn cam_yoff 1
                                            shiftr temp9 3
                                        geta[cam_id].y cam_yoff
                                        add cam_yoff temp9
                                        
                                        set temp9 sprite[cam_id].sectnum
                                         // we aren't checking adjacent sectors - cam sectors
                                        updatesectorz cam_xoff cam_yoff sprite[cam_id].z temp9
                                        ifn temp9 -1
                                            ifand temp4 1
                                                ifand sector[temp9].ceilingstat 1
                                                    set temp8 1
                                        
                                    }
                                    else ifand temp4 1
                                        set temp8 1
                                }
                                else ifand temp4 1
                                    set temp8 1
                                ife temp8 1 ife temp6 0
                                {
                                    setav[temp2].rain_counter 1

                                    // new feature
                                    getav[temp].se_extra temp4
                                    ifg temp4 0
                                    {
                                        rand temp6 temp4
                                        div temp6 3
                                        add temp4 temp6
                                        setav[temp2].rain_vel temp4
                                    }
                                    else
                                    {
                                        rand temp4 1023 // set velocity
                                        add temp4 3072
                                        setav[temp2].rain_vel temp4
                                    }
                                    ifand se_xvel 2
                                    {
                                        getceilzofslope temp5 sprite[temp].x sprite[temp].y temp3
                                        add temp3 1024
                                        rand temp4 8192
                                        add temp3 temp4
                                    }
                                    else
                                    {
                                        getp[temp3].posz temp3 // place the sprite above the player
                                        ifand se_xvel 1
                                            sub temp3 245760
                                        else
                                            sub temp3 65536 // 46080
                                        rand temp4 32767 // 16383
                                        ifl counter 30
                                        {
                                            ifrnd 127
                                                inv temp4
                                        }
                                        sub temp3 temp4
                                        // this is dumb but otherwise they get stuck in the ceiling sometimes
                                        getceilzofslope temp5 sprite[temp].x sprite[temp].y temp4
                                        ifl temp3 temp4
                                            set temp3 temp4
                                    }

                                    seta[temp2].z temp3
                                    seta[temp2].sectnum temp5
                                }
                                else
                                    set temp5 -1
                            }
                            else
                            {
                                // reset
                                seta[temp2].x sprite[temp].x
                                seta[temp2].y sprite[temp].y
                                seta[temp2].z sprite[temp].z
                                seta[temp2].sectnum sprite[temp].sectnum
                                set temp5 -1
                            }
                            ife temp5 -1
                            {
                                ife actorvar[temp2].rain_counter 0
                                    setav[temp2].rain_counter -4
                            }
                        }
                        ifge temp5 0
                        {
                            setu[].vm_sprite temp2
                            fall
                            getav[temp2].rain_counter temp5
                            getav[temp2].rain_vel temp4
                            ife temp5 1
                                movesprite temp2 0 0 temp4 CLIPMASK0 temp3
                            else // we need to keep moving downward while splashing
                            {
                                set temp3 temp4
                                ifn temp3 0
                                {
                                    shiftr temp3 4
                                    sub temp4 temp3
                                }
                                ifl temp4 0
                                    set temp4 0
                                movesprite temp2 0 0 temp4 CLIPMASK0 temp3
                            }
                            sub temp4 512
                            div temp4 24
                            ifand actorvar[temp].se_xvel 8
                                shiftr temp4 1
                            ifand actorvar[temp].se_xvel 16
                                shiftr temp4 2
                            clamp temp4 4 255
                            ifand actorvar[temp].se_xvel 32
                                seta[temp2].shade 12
                            else
                                seta[temp2].shade -12
                            seta[temp2].cstat 2
                            seta[temp2].blend 129
                            seta[temp2].xrepeat 64
                            seta[temp2].yrepeat temp4

                            // if it contacts the floor or otherwise "hits"
                            //  something we should move to the next step
                            getflorzofslope sprite[temp2].sectnum sprite[temp2].x sprite[temp2].y temp4
                            sub temp4 1024
                            ifg sprite[temp2].z temp4
                            {
                                ife temp5 1
                                {
                                    setav[temp2].rain_counter 2
                                    ldist temp3 THISACTOR player[myconnectindex].i
                                    ifl temp3 8192 ifg temp3 1024
                                    {
                                        spawn A_RAINRIPPLE
                                        ifand actorvar[temp].se_xvel 64
                                            ifrnd 127
                                                spawn A_SMOKE2
                                    }
                                    else ifl temp3 800
                                    {
                                        seta[temp2].picnum A_RAINSPRITE
                                        setav[temp2].rain_counter 0
                                        seta[temp2].cstat 32768
                                    }
                                }
                                seta[temp2].z temp4
                            }
                            else ifn temp3 0
                            {
                                ife temp5 1
                                {
                                    setav[temp2].rain_counter 2
                                    ldist temp3 THISACTOR player[myconnectindex].i
                                    ifl temp3 8192 ifg temp3 1024
                                        spawn A_RAINRIPPLE
                                    else ifl temp3 800
                                    {
                                        seta[temp2].picnum A_RAINSPRITE
                                        setav[temp2].rain_counter 0
                                        seta[temp2].cstat 32768
                                    }
                                }
                            }
                            ifg temp5 1 // cycle through splash animation
                            {
                                seta[temp2].xrepeat 24
                                seta[temp2].yrepeat 24
                                add temp5 1
                                ifg temp5 1
                                {
                                    geta[temp2].picnum temp3
                                    add temp3 1
                                    seta[temp2].picnum temp3

                                    set temp4 A_RAINSPRITE
                                    add temp4 6
                                    ifg temp3 temp4
                                    {
                                        seta[temp2].picnum A_RAINSPRITE
                                        setav[temp2].rain_counter 0
                                        seta[temp2].cstat 32768
                                     }
                                    else
                                        setav[temp2].rain_counter 2
                                }
                                else
                                    setav[temp2].rain_counter temp5
                            }
                        }
                    }
                }
                break
            case 67
                /* set temp5 topicalcream[2]
                add temp5 1
                setarray topicalcream[2] temp5 */
                setu[].vm_sprite temp
                ife st_do_once 0 // link pairs at start and only reference saved partner in the future
                {
                    for itervar range se_game_num
                    {
                        set temp6 se_game[itervar]
                        setu[].vm_sprite temp6

                        ife sprite[temp6].picnum SECTOREFFECTOR
                            ife se_lotag 67
                            {
                                for itervar range se_game_num
                                {
                                    set temp2 se_game[itervar]
                                    ife sprite[temp2].picnum SECTOREFFECTOR
                                    {
                                        ife se_hitag actorvar[temp2].se_hitag
                                            ife se_extra actorvar[temp2].se_extra
                                                ife actorvar[temp2].se_lotag 68
                                                    set se_swap_linkid temp2
                                    }
                                }
                                set st_do_once 1
                            }
                    }
                }
                ife activateshit[se_hitag] 1
                {
                    set temp2 se_swap_linkid
                    ifn se_swap_linkid -1
                    {
                        ife sprite[temp2].picnum SECTOREFFECTOR
                            ife se_hitag actorvar[temp2].se_hitag ife se_extra actorvar[temp2].se_extra ife actorvar[temp2].se_lotag 68
                            {
                                getactor[temp].sectnum temp3
                                getactor[temp2].sectnum temp4
                                ifand se_xvel 1
                                    nullop
                                else
                                {
                                    ifand se_xvel 2
                                    {
                                        ifand se_xvel 32
                                        {
                                            sets[temp3].lotag sector[temp4].lotag
                                            sets[temp3].hitag sector[temp4].hitag
                                            sets[temp3].extra sector[temp4].extra
                                        }
                                        ifand se_xvel 4
                                            nullop
                                        else
                                        {
                                            sets[temp3].ceilingpicnum sector[temp4].ceilingpicnum
                                            sets[temp3].ceilingxpanning sector[temp4].ceilingxpanning
                                            sets[temp3].ceilingypanning sector[temp4].ceilingypanning
											ifand se_xvel 16
											{
												sets[temp3].ceilingpal sector[temp4].ceilingpal
												sets[temp3].ceilingstat sector[temp4].ceilingstat
											}
											ifand actorvar[temp2].se_xvel 1
											{
											    set temp9 128
                                                or temp9 sector[temp4].ceilingstat
                                                ifand actorvar[temp2].se_xvel 4
                                                    or temp9 2560
                                                sets[temp3].ceilingstat temp9
											}
                                        }
                                        
                                        ifand se_xvel 8
                                            nullop
                                        else
                                        {
                                            sets[temp3].floorpicnum sector[temp4].floorpicnum
                                            sets[temp3].floorxpanning sector[temp4].floorxpanning
                                            sets[temp3].floorypanning sector[temp4].floorypanning
											ifand se_xvel 16
											{
												sets[temp3].floorpal sector[temp4].floorpal
												sets[temp3].floorstat sector[temp4].floorstat
											}
											ifand actorvar[temp2].se_xvel 2
											{
											    set temp9 128
                                                or temp9 sector[temp4].floorstat
                                                ifand actorvar[temp2].se_xvel 8
                                                    or temp9 2560
                                                sets[temp3].floorstat temp9
											}
                                        }
                                    }
                                    else
                                    {
                                        sets[temp3].ceilingz sector[temp4].ceilingz
                                        sets[temp3].floorz sector[temp4].floorz
                                        sets[temp3].ceilingstat sector[temp4].ceilingstat
                                        sets[temp3].floorstat sector[temp4].floorstat
                                        sets[temp3].ceilingpicnum sector[temp4].ceilingpicnum
                                        sets[temp3].ceilingslope sector[temp4].ceilingslope
                                        sets[temp3].ceilingshade sector[temp4].ceilingshade
                                        sets[temp3].ceilingpal sector[temp4].ceilingpal
                                        sets[temp3].ceilingxpanning sector[temp4].ceilingxpanning
                                        sets[temp3].ceilingypanning sector[temp4].ceilingypanning
                                        sets[temp3].floorpicnum sector[temp4].floorpicnum
                                        sets[temp3].floorslope sector[temp4].floorslope
                                        sets[temp3].floorshade sector[temp4].floorshade
                                        sets[temp3].floorpal sector[temp4].floorpal
                                        sets[temp3].floorxpanning sector[temp4].floorxpanning
                                        sets[temp3].floorypanning sector[temp4].floorypanning
                                        sets[temp3].visibility sector[temp4].visibility
                                        sets[temp3].fogpal sector[temp4].fogpal
                                        sets[temp3].lotag sector[temp4].lotag
                                        sets[temp3].hitag sector[temp4].hitag
                                        sets[temp3].extra sector[temp4].extra
                                        ifand actorvar[temp2].se_xvel 1
										{
										    set temp9 128
                                            or temp9 sector[temp4].ceilingstat
                                            ifand actorvar[temp2].se_xvel 4
                                                    or temp9 2560
                                            sets[temp3].ceilingstat temp9
										}
										ifand actorvar[temp2].se_xvel 2
										{
										    set temp9 128
                                            or temp9 sector[temp4].floorstat
                                            ifand actorvar[temp2].se_xvel 8
                                                    or temp9 2560
                                            sets[temp3].floorstat temp9
										}
                                    }
                                }
                                state swapwalls
                            }
                    }
                }
                break
            case 69
            /* set temp5 topicalcream[3]
                add temp5 1
                setarray topicalcream[3] temp5 */
                setu .vm_sprite temp
                ifand sprite.pal 8
                {
                    ifg se_hitag 0
                        inv se_hitag
                    geta .pal temp3
                    xor temp3 8
                    seta .pal temp3
                }
                ifn se_hitag 0
                {
                    set temp3 se_hitag
                    abs temp3
                    ife activateshit[temp3] 1
                        inv se_hitag
                }
                ifge se_hitag 0
                {
                    ifl se_extra 0
                        set se_extra 0
                    ife counter se_extra
                    {
                        geta .sectnum temp2
                        geta .pal se_pal
                        ifand se_pal 4
                            nullop
                        else
                        {
                            for temp3 wallsofsector temp2
                            {
                                getwall[temp3].xpanning temp4
                                add temp4 se_xvel
                                setwall[temp3].xpanning temp4

                                getwall[temp3].ypanning temp4
                                add temp4 sprite[].zvel
                                setwall[temp3].ypanning temp4
                            }
                        }

                        ifand se_pal 1
                        {
                            gets[temp2].floorxpanning temp4
                            add temp4 se_xvel
                            sets[temp2].floorxpanning temp4

                            gets[temp2].floorypanning temp4
                            add temp4 sprite[].zvel
                            sets[temp2].floorypanning temp4
                        }
                        ifand se_pal 2
                        {
                            gets[temp2].ceilingxpanning temp4
                            add temp4 se_xvel
                            sets[temp2].ceilingxpanning temp4

                            gets[temp2].ceilingypanning temp4
                            add temp4 sprite[].zvel
                            sets[temp2].ceilingypanning temp4
                        }
                        set counter 0
                    }
                    else
                        add counter 1
                }
                break
        endswitch

        switch actorvar[temp].se_lotag
            case 70
            /* set temp5 topicalcream[4]
                add temp5 1
                setarray topicalcream[4] temp5 */
                setu[].vm_sprite temp
                setu[].vm_player myconnectindex
                ifl se_extra 0
                    set se_extra 0
                getp[myconnectindex].i temp2
                // fingers crossed not a perf drain
                getzrange player[].posx player[].posy player[].posz sprite[temp2].sectnum temp2 temp3 temp4 temp5 player[].clipdist 0
                ifl temp5 49152
                    sub temp5 16384
                else
                    set temp5 -1

                ife sprite[].sectnum temp5 ife se_electric_toggle 0
                {
                    ife sprite[].pal 9
                    {
                        getflorzofslope sprite[temp].sectnum player.posx player.posy temp3
                        sub temp3 1024
                        getp[myconnectindex].i temp2
                        ifl sprite[temp2].z temp3
                        {
                            ife counter 0
                                set counter -1
                        }
                        else ife counter -1
                            set counter 0
                    }
                    ifn counter -1
                    {
                        ife counter 0 ifp palive
                        {
                            set temp2 0
                            
                            ifand se_zvel 8
                                ifg p_hazard_amount 0
                                    set temp2 1
                            ife temp2 0
                            {
                                getp .i temp2
                                geta[temp2].extra temp3
                                sub temp3 se_hitag
                                ifl temp3 0
                                    set temp3 0
                                seta[temp2].extra temp3
                                ifand se_zvel 1
                                    palfrom 28 63 16 0
                                else ifand se_zvel 2
                                {
                                    sub temp3 MAXPLAYERHEALTH
                                    abs temp3
                                    shiftr temp3 1
                                    ifl temp3 10
                                        set temp3 10
                                    setp .pals 0 30
                                    setp .pals 1 0
                                    setp .pals 2 0
                                    setp .pals_time temp3
                                }
                                else ifand se_zvel 8
                                {
                                    sub temp3 MAXPLAYERHEALTH
                                    abs temp3
                                    shiftr temp3 1
                                    ifl temp3 10
                                        set temp3 10
                                    setp .pals 0 5
                                    setp .pals 1 20
                                    setp .pals 2 0
                                    setp .pals_time temp3
                                    seta .htpicnum P_ACIDYSPIT
                                }
                                else
                                    palfrom 28 63 63 63
                            }
                            else
                                actorsound player.i S_ITEM_HAZMAT_GEIGER
                            
                        }
                        add counter 1
                        ifg counter se_extra
                            set counter 0
                        ifp palive
                        {
                            ifand se_zvel 1
                                set p_sizzled_count -15
                            else ifand se_zvel 2
                                set p_sizzled_count 0
                            else ifand se_zvel 8
                                nullop
                            else
                                set p_sizzled_count 15
                        }
                    }
                }
                else
                    set counter 0
                ifand se_zvel 4
                {
                    ife se_electric_toggle 0
                    {
                        ife counter2 0 for temp2 spritesofsector sprite.sectnum
                        {
                            ifand tiledata[sprite[temp2].picnum].gameflags 32
                            {
                                ifspritepal 9
                                {
                                    getflorzofslope sprite[temp2].sectnum sprite[temp2].x sprite[temp2].y temp3
                                    sub temp3 1024
                                    ifg sprite[temp2].z temp3
                                    {
                                        geta[temp2].htextra temp3
                                        clamp temp3 0 131072
                                        add temp3 se_hitag
                                        seta[temp2].htextra temp3
                                        seta[temp2].htpicnum P_SHOCKER
                                    }
                                }
                                else
                                {
                                    geta[temp2].htextra temp3
                                    clamp temp3 0 131072
                                    add temp3 se_hitag
                                    seta[temp2].htextra temp3
                                    seta[temp2].htpicnum P_SHOCKER
                                }
                            }
                        }
                        add counter2 1
                        ifg counter2 se_extra
                            set counter2 0
                    }
                }
                ifand se_zvel 1
                    nullop
                else
                {
                    set temp3 0
                    ife activateshit[se_xvel] 1
                        set temp3 1
                    else ifspritepal 10
                    {
                        spritepal 9
                        set temp3 1
                    }
                    else ifspritepal 11
                    {
                        spritepal 0
                        set temp3 1
                    }
                    ife temp3 1
                    {
                        ife se_electric_toggle 0
                        {
                            set se_electric_toggle 1
                            geta[].sectnum temp3
                            for temp2 spritesofsector temp3
                            {
                                switch sprite[temp2].picnum
                                    case 5260
                                    case 7042
                                    case 7053
                                    case 11359
                                        geta[temp2].cstat temp4
                                        or temp4 32768
                                        seta[temp2].cstat temp4
                                        break
                                endswitch
                            }
                        }
                        else
                        {
                            set se_electric_toggle 0
                            geta[].sectnum temp3
                            for temp2 spritesofsector temp3
                            {
                                switch sprite[temp2].picnum
                                    case 5260
                                    case 7042
                                    case 7053
                                    case 11359
                                        geta[temp2].cstat temp4
                                        ifand temp4 32768
                                            xor temp4 32768
                                        seta[temp2].cstat temp4
                                        break
                                endswitch
                            }
                        }
                    }
                }
                break
            case 71 // commented for posterity due to complexity
            /* set temp5 topicalcream[5]
                add temp5 1
                setarray topicalcream[5] temp5 */
                setu[].vm_sprite temp

                ifl se_extra 0
                    set se_extra 0
                ifand se_extra 1 // allow us enable continuous movement from the start if bit is set
                    set se_rotno 1
                ife activateshit[se_hitag] 1
                {
                    ife se_rotno 0
                        set se_rotno 1
                    else
                    {
                        ife sprite[].pal 9 // pal 9 is either reverse or stop, pal 0 is go
                        {
                            seta[].pal 0
                            // delay mechanism to prevent changing so quickly we can't see the shift
                            set se_rotswitch 1
                        }
                        else
                            seta[].pal 9
                    }
                    // set se_newrot_hitag 0
                }

                ifspritepal 9 // step through a counter to determine acceleration values later
                {
                    ifg counter 0
                    {
                        sub counter 1
                        ifand se_extra 4 // allows reversal of continuous movement
                        {
                            ife counter 0
                            {
                                spritepal 0
                                ife se_rotdir 0
                                    set se_rotdir 1
                                 else
                                    set se_rotdir 0
                            }
                        }
                        else // otherwise we should reverse course and reset position
                        {
                            ifand se_extra 1
                                nullop
                            else ife counter 0 // if in motion then wait for deceleration
                            {
                                spritepal 0
                                ife se_rotdir 0
                                    set se_rotdir 1
                                 else
                                    set se_rotdir 0
                                set counter 1
                            }
                            else ifge counter 15 // if at the end in either case then don't bother waiting
                            {
                                spritepal 0
                                ife se_rotdir 0
                                    set se_rotdir 1
                                 else
                                    set se_rotdir 0
                                set counter 1
                            }
                        }
                    }
                    else ifand se_extra 4 ife counter 0 // if we had pal 9 to start then start reverse course
                    {
                        spritepal 0
                        ife se_rotdir 0
                            set se_rotdir 1
                         else
                            set se_rotdir 0
                    }
                }
                else
                {
                    ife se_rotswitch 1
                    {
                        ifg counter 0
                        {
                            sub counter 1
                            ifand se_extra 4
                            {
                                ife counter 0
                                {
                                    ife se_rotdir 0
                                        set se_rotdir 1
                                     else
                                        set se_rotdir 0
                                }
                            }
                        }
                        set se_rotswitch 0
                    }
                    else
                        ifl counter 16
                            add counter 1
                }
                ife se_rotno 0
                    set counter 0
                ifn counter 0 // if we're at any stage of acceleration then start moving stuff!
                {
                    for itervar range se_game_num
                    {
                        set temp2 se_game[itervar]
                        // setu[].vm_sprite temp
                        ife sprite[temp2].picnum SECTOREFFECTOR
                        {
                            ife sprite[temp2].lotag 72
                                ife actorvar[temp].se_hitag actorvar[temp2].se_hitag
                            {
                                setu[].vm_sprite temp2
                                set se_rotdir actorvar[temp].se_rotdir

                                // basic math here is to take the value of counter
                                // offset it, and then use that to divide the
                                // speed setting and get smoothish movement to start

                                getav[temp].counter temp6
                                getav[temp].se_extra temp3
                                ifand temp3 1
                                    sub temp6 16
                                else
                                {
                                    // with some adjustments built in for default
                                    // setting, check if we're near the beginning
                                    // or end of the range to determine offsets
                                    set temp5 se_xvel
                                    shiftr temp5 3
                                    set temp4 se_xvel
                                    sub temp4 temp5
                                    set temp5 se_ang_off
                                    abs temp5 // use abs because se_ang_off is negative sometimes!
                                    ifg temp5 temp4
                                        sub temp6 24
                                    else
                                    {
                                        set temp5 se_xvel
                                        shiftr temp5 1
                                        set temp4 se_xvel
                                        sub temp4 temp5
                                        shiftr temp5 1
                                        sub temp4 temp5
                                        set temp5 se_ang_off
                                        abs temp5
                                        ife se_rotdir 1 ifl temp5 temp4
                                            sub temp6 24
                                        else
                                            sub temp6 16
                                    }
                                }
                                abs temp6
                                shiftr temp6 2
                                clamp temp6 1 16
                                set temp4 se_extra
                                div temp4 temp6 // actual division of speed here
                                ife se_rotdir 1 // if we're reversing then reverse the math results
                                {
                                    ifand temp3 2 // SE71 extra 2 is generic "reverse all"
                                        nullop
                                    else
                                        inv temp4
                                }
                                else ifand temp3 2
                                    inv temp4
                                add se_ang_off temp4
                                ifand temp3 1
                                    nullop
                                else
                                {
                                    ifand temp3 2
                                    {
                                        set temp5 -se_xvel
                                        ife se_rotdir 1
                                        {
                                            set temp6 se_extra
                                            getav[temp].counter temp7
                                            sub temp7 16
                                            inv temp7
                                            shiftr temp7 2
                                            clamp temp7 1 16
                                            div temp6 temp7
                                            add temp5 temp6
                                        }
                                        ifl se_ang_off temp5
                                            set se_ang_off temp5 // se_extra
                                        ifg se_ang_off 0
                                            set se_ang_off 0
                                    }
                                    else
                                    {
                                        set temp5 se_xvel
                                        ife se_rotdir 1
                                        {
                                            set temp6 se_extra
                                            getav[temp].counter temp7
                                            sub temp7 16
                                            inv temp7
                                            shiftr temp7 2
                                            clamp temp7 1 16
                                            div temp6 temp7
                                            sub temp5 temp6
                                        }
                                        ifg se_ang_off temp5
                                            set se_ang_off temp5 // se_extra
                                        ifl se_ang_off 0
                                            set se_ang_off 0
                                    }
                                }
                                // andvar se_ang_off 2047
                                set temp3 0
                                add temp3 se_ang_off
                                andvar temp3 2047

                                geta[temp2].sectnum temp4
                                for temp6 wallsofsector temp4
                                {
                                    // we use our stored wall values to always offset from the origin!
                                    rotatepoint sprite[temp].x sprite[temp].y walls_x[temp6] walls_y[temp6] temp3 temp4 temp5
                                    dragpoint temp6 temp4 temp5
                                }
                                ifn se_ang_off 0 ifn se_ang_off se_xvel ifn se_ang_off -se_xvel
                                {
                                    // now we can handle sprites
                                    geta[temp2].sectnum temp4
                                    setu[].vm_sprite temp2
                                    for temp5 spritesofsector temp4
                                    {
                                        geta[temp2].sectnum temp4

                                        // but only if they are touching the floor or ceiling and
                                        // the texture has bit 64 so it moves with the sector
                                        set temp3 0
                                        ifand sector[temp4].floorstat 64
                                        {
                                            gets[temp4].floorz temp4
                                            sub temp4 1024
                                            ifg sprite[temp5].z temp4
                                                set temp3 1
                                        }
                                        geta[temp2].sectnum temp4
                                        ifand sector[temp4].ceilingstat 64
                                        {
                                            gets[temp4].ceilingz temp4
                                            add temp4 4096
                                            ifl sprite[temp5].z temp4
                                                set temp3 1
                                        }
                                        ifand actorvar[temp].se_extra 8 // ignore SECTOREFFECTOR sprites
                                            ife sprite[temp5].picnum SECTOREFFECTOR
                                                set temp3 0
                                        ife temp3 1
                                        {
                                            // a rougher duplicate of the math above
                                            // this is better at dealing with the fact
                                            // that we don't have constant origins to offset from
                                            // however can build cumulative errors.
                                            // hence why decals have to be disallowed!
                                            getav[temp].counter temp6
                                            getav[temp].se_extra temp3
                                            ifand temp3 1
                                                sub temp6 16
                                            else
                                            {
                                                // with some adjustments built in for default
                                                // setting, check if we're near the beginning
                                                // or end of the range to determine offsets
                                                set temp7 se_xvel
                                                shiftr temp7 3
                                                set temp4 se_xvel
                                                sub temp4 temp7
                                                set temp7 se_ang_off
                                                abs temp7 // use abs because se_ang_off is negative sometimes!
                                                ifg temp7 temp4
                                                    sub temp6 24
                                                else
                                                {
                                                    set temp7 se_xvel
                                                    shiftr temp7 1
                                                    set temp4 se_xvel
                                                    sub temp4 temp7
                                                    shiftr temp7 1
                                                    sub temp4 temp7
                                                    set temp7 se_ang_off
                                                    abs temp7
                                                    ife se_rotdir 1 ifl temp7 temp4
                                                        sub temp6 24
                                                    else
                                                        sub temp6 16
                                                }
                                            }
                                            abs temp6
                                            shiftr temp6 2
                                            clamp temp6 1 16
                                            set temp4 se_extra
                                            div temp4 temp6 // actual division of speed here
                                            ife se_rotdir 1 // if we're reversing then reverse the math results
                                            {
                                                ifand temp3 2 // SE71 extra 2 is generic "reverse all"
                                                    nullop
                                                else
                                                    inv temp4
                                            }
                                            else ifand temp3 2
                                                inv temp4
                                            rotatepoint sprite[temp].x sprite[temp].y sprite[temp5].x sprite[temp5].y temp4 temp7 temp6
                                            ife temp5 player[myconnectindex].i
                                            {
                                                setp[myconnectindex].posx temp7
                                                setp[myconnectindex].posy temp6
                                                getp[myconnectindex].ang temp6
                                                add temp6 temp4
                                                setp[myconnectindex].ang temp6
                                            }
                                            else ifn temp5 THISACTOR
                                            {
                                                // non-actors will have severe visual glitches
                                                // so it's a no-no
                                                ife sprite[temp5].statnum 0
                                                    changespritestat temp5 1
                                                seta[temp5].x temp7

                                                seta[temp5].y temp6
                                                geta[temp5].ang temp6
                                                add temp6 temp4
                                                seta[temp5].ang temp6
                                                geta[temp2].sectnum temp7
                                                ifg sprite[temp5].z sector[temp7].floorz
                                                    seta[temp5].z sector[temp7].floorz
                                                else ifl sprite[temp5].z sector[temp7].ceilingz
                                                    seta[temp5].z sector[temp7].ceilingz
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                }
                break
            case 100
                /* set temp5 topicalcream[6]
                add temp5 1
                setarray topicalcream[6] temp5 */
                setu[].vm_sprite temp
                setu[].vm_player myconnectindex
                ifg se_zvel 0
                {
                    ifand se_zvel 1
                    {
                        getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp3
                        ife st_do_once 0
                        {
                            sub temp3 sprite[].z
                            set se_above temp3
                            set st_do_once 1
                        }
                        else
                        {
                            sub temp3 se_above
                            seta[].z temp3
                            ifspritepal 1
                            {
                                ifn cam_id -1
                                {
                                    ife se_hitag actorvar[cam_id].se_hitag
                                    {
                                        setav[cam_id].cam_xoff sprite[].x
                                        setav[cam_id].cam_yoff sprite[].y
                                        setav[cam_id].cam_zoff sprite[].z
                                    }
                                }
                            }
                        }
                    }
                }
                
                ife sprite[].pal 0
                {
                    ife st_do_once 0
                    {
                        set temp8 0
                        for itervar range se_game_num
                        {
                            set temp2 se_game[itervar]
                            ife sprite[temp2].lotag 100
                            {
                                ifg tp_owner 0
                                    ife temp8 0
                                    {
                                        ife sprite[temp2].pal 0
                                            ife actorvar[temp2].se_hitag tp_owner
                                            {
                                                set tp_owner temp2
                                                add tp_owner 65536
                                                set temp8 1
                                            }
                                    }
                                    ife sprite[temp2].pal 1
                                    {
                                        set temp3 0
                                        getav[temp2].se_hitag temp4
                                        ife temp4 se_hitag
                                        {
                                            set cam_xoff sprite[temp2].x
                                            set cam_yoff sprite[temp2].y
                                            set cam_zoff sprite[temp2].z
                                        }
                                    }
                            }
                        }
                        set st_do_once 1
                    }
                    set temp2 0
                    ife se_hitag cam_id_source
                    {
                        set temp2 1
                        set counter 0
                    }
                    else ife se_hitag 0 ife counter 0
                        set temp2 1
                    ife temp2 1
                    {
                        ife counter 0
                        {
                            for itervar range se_game_num
                            {
                                set temp2 se_game[itervar]
                                ife sprite[temp2].picnum SECTOREFFECTOR
                                {
                                    ife sprite[temp2].lotag 100
                                    {
                                        ife sprite[temp2].pal 1
                                        {
                                            set temp3 0
                                            getav[temp2].se_hitag temp4
                                            ife temp4 se_hitag
                                                set temp3 1
                                            else ife temp4 0 ifl cam_id_source 1
                                                set temp3 1
                                            ife temp3 1
                                            {
                                                set cam_xoff sprite[temp2].x
                                                set cam_yoff sprite[temp2].y
                                                set cam_zoff sprite[temp2].z
                                                set counter 1
                                            }
                                        }
                                    }
                                }
                            }
                           
                            ifn counter 1
                            {
                                getp[].posx cam_xoff
                                getp[].posy cam_yoff
                                getp[].posz cam_zoff
                            }
                            set temp2 0
                            for temp2 range NUMSECTORS
                            {
                                gets[temp2].ceilingpicnum temp3
                                ife temp3 6143 ifand sector[temp2].ceilingstat 1
                                {
                                    sets[temp2].ceilingpicnum 6135
                                }
                                gets[temp2].floorpicnum temp3
                                ife temp3 6143 ifand sector[temp2].floorstat 1
                                {
                                    sets[temp2].floorpicnum 6135
                                }
                            }
                            set counter 1
                        }
                        set cam_id temp
                        set cam_id_source -1
                    }
                    ifg se_yvel 0
                    {
                        ife activateshit[se_yvel] 1
                            set cam_id_source se_hitag
                    }
                }
                else
                {
                    set temp3 0
                    
                    ife player[].cursectnum sprite[].sectnum
                        set temp3 1
                    ifg se_yvel 0
                        ife activateshit[se_yvel] 1
                            set temp3 2
                    ifspritepal 10
                    {
                        set temp3 2
                        spritepal 11
                    }
                    ifn temp3 0
                    {
                        ife sprite[].pal 5
                            set cam_bypass 0
                        else ife sprite[].pal 9
                            set cam_bypass 1
                        else ife sprite[].pal 8
                            set cam_id_source se_hitag
                        else ife sprite[].pal 11 ife temp3 2
                            xor cam_force_seen 1
                    }
                }
                break
            default
                break
        endswitch

        switch actorvar[temp].se_lotag
            case 73
            /* set temp5 topicalcream[7]
                add temp5 1
                setarray topicalcream[7] temp5 */
                setu[].vm_sprite temp
                setu[].vm_player myconnectindex
                geta[].sectnum temp6
                ife counter 0
                {
                    set counter 1
                    gets[temp6].floorstat temp5
                    or temp5 2
                    sets[temp6].floorstat temp5
                    set se_slope_flor sector[temp6].floorslope
                    set se_slope_floro se_slope_flor
                    sub se_slope_flor se_extra
                    inv se_slope_flor
                    ife se_xvel 0
                        set se_xvel 1
                    ifl se_slope_flor 0
                    {
                        div se_slope_flor se_xvel
                        ife se_slope_flor 0
                            set se_slope_flor -1
                    }
                    else
                    {
                        div se_slope_flor se_xvel
                        ife se_slope_flor 0
                            set se_slope_flor 1
                    }
                }
                ife activateshit[se_hitag] 1
                {
                    // sets[temp6].floorslope se_extra
                    ife se_slope_dir 0
                        set se_slope_dir 1
                    else
                        set se_slope_dir 0
                }
                set temp5 0
                ifl se_slope_floro 0
                        ifg se_slope_flor 0
                            ifle se_extra 0
                                set temp5 1
                ife temp5 1
                {
                    ife se_slope_dir 1
                    {
                        gets[temp6].floorslope temp5
                        add temp5 se_slope_flor
                        ifle se_extra 0
                        {
                            ifg temp5 se_extra
                                sets[temp6].floorslope se_extra
                            else
                                sets[temp6].floorslope temp5
                        }
                        else ifge se_extra 0
                        {
                            ifl temp5 se_extra
                                sets[temp6].floorslope se_extra
                            else
                                sets[temp6].floorslope temp5
                        }
                        else
                            sets[temp6].floorslope temp5
                    }
                    else
                    {
                        gets[temp6].floorslope temp5
                        sub temp5 se_slope_flor
                        ifle se_extra 0
                        {
                            ifl temp5 se_slope_floro
                                sets[temp6].floorslope se_slope_floro
                            else
                                sets[temp6].floorslope temp5
                        }
                        else ifge se_extra 0
                        {
                            ifg temp5 se_slope_floro
                                sets[temp6].floorslope se_slope_floro
                            else
                                sets[temp6].floorslope temp5
                        }
                        else
                            sets[temp6].floorslope temp5
                    }
                }
                else
                {
                    ife se_slope_dir 1
                    {
                        gets[temp6].floorslope temp5
                        add temp5 se_slope_flor
                        ifle se_extra 0
                        {
                            ifl temp5 se_extra
                                sets[temp6].floorslope se_extra
                            else
                                sets[temp6].floorslope temp5
                        }
                        else ifge se_extra 0
                        {
                            ifg temp5 se_extra
                                sets[temp6].floorslope se_extra
                            else
                                sets[temp6].floorslope temp5
                        }
                        else
                            sets[temp6].floorslope temp5
                    }
                    else
                    {
                        gets[temp6].floorslope temp5
                        sub temp5 se_slope_flor
                        ifle se_extra 0
                        {
                            ifg temp5 se_slope_floro
                                sets[temp6].floorslope se_slope_floro
                            else
                                sets[temp6].floorslope temp5
                        }
                        else ifge se_extra 0
                        {
                            ifl temp5 se_slope_floro
                                sets[temp6].floorslope se_slope_floro
                            else
                                sets[temp6].floorslope temp5
                        }
                        else
                            sets[temp6].floorslope temp5
                    }
                }
                break
            case 74
            /* set temp5 topicalcream[8]
                add temp5 1
                setarray topicalcream[8] temp5 */
                setu[].vm_sprite temp
                setu[].vm_player myconnectindex
                geta[].sectnum temp6
                ife counter 0
                {
                    set counter 1
                    gets[temp6].ceilingstat temp5
                    or temp5 2
                    sets[temp6].ceilingstat temp5
                    set se_slope_ceil sector[temp6].ceilingslope
                    set se_slope_ceilo se_slope_ceil
                    sub se_slope_ceil se_extra
                    inv se_slope_ceil
                    ife se_xvel 0
                        set se_xvel 1
                    ifl se_slope_ceil 0
                    {
                        div se_slope_ceil se_xvel
                        ife se_slope_ceil 0
                            set se_slope_ceil -1
                    }
                    else
                    {
                        div se_slope_ceil se_xvel
                        ife se_slope_ceil 0
                            set se_slope_ceil 1
                    }
                }
                ife activateshit[se_hitag] 1
                {
                    // sets[temp6].ceilingslope se_extra
                    ife se_slope_dir 0
                        set se_slope_dir 1
                    else
                        set se_slope_dir 0
                }
                set temp5 0
                ifl se_slope_ceilo 0
                        ifg se_slope_ceil 0
                            ifle se_extra 0
                                set temp5 1
                ife temp5 1
                {
                    ife se_slope_dir 1
                    {
                        gets[temp6].ceilingslope temp5
                        add temp5 se_slope_ceil
                        ifle se_extra 0
                        {
                            ifg temp5 se_extra
                                sets[temp6].ceilingslope se_extra
                            else
                                sets[temp6].ceilingslope temp5
                        }
                        else ifge se_extra 0
                        {
                            ifl temp5 se_extra
                                sets[temp6].ceilingslope se_extra
                            else
                                sets[temp6].ceilingslope temp5
                        }
                        else
                            sets[temp6].ceilingslope temp5
                    }
                    else
                    {
                        gets[temp6].ceilingslope temp5
                        sub temp5 se_slope_ceil
                        ifle se_extra 0
                        {
                            ifl temp5 se_slope_ceilo
                                sets[temp6].ceilingslope se_slope_ceilo
                            else
                                sets[temp6].ceilingslope temp5
                        }
                        else ifge se_extra 0
                        {
                            ifg temp5 se_slope_ceilo
                                sets[temp6].ceilingslope se_slope_ceilo
                            else
                                sets[temp6].ceilingslope temp5
                        }
                        else
                            sets[temp6].ceilingslope temp5
                    }
                }
                else
                {
                    ife se_slope_dir 1
                    {
                        gets[temp6].ceilingslope temp5
                        add temp5 se_slope_ceil
                        ifle se_extra 0
                        {
                            ifl temp5 se_extra
                                sets[temp6].ceilingslope se_extra
                            else
                                sets[temp6].ceilingslope temp5
                        }
                        else ifge se_extra 0
                        {
                            ifg temp5 se_extra
                                sets[temp6].ceilingslope se_extra
                            else
                                sets[temp6].ceilingslope temp5
                        }
                        else
                            sets[temp6].ceilingslope temp5
                    }
                    else
                    {
                        gets[temp6].ceilingslope temp5
                        sub temp5 se_slope_ceil
                        ifle se_extra 0
                        {
                            ifg temp5 se_slope_ceilo
                                sets[temp6].ceilingslope se_slope_ceilo
                            else
                                sets[temp6].ceilingslope temp5
                        }
                        else ifge se_extra 0
                        {
                            ifl temp5 se_slope_ceilo
                                sets[temp6].ceilingslope se_slope_ceilo
                            else
                                sets[temp6].ceilingslope temp5
                        }
                        else
                            sets[temp6].ceilingslope temp5
                    }
                }
                break
            case 75
            /* set temp5 topicalcream[9]
                add temp5 1
                setarray topicalcream[9] temp5 */
                setu[].vm_sprite temp
                setu[].vm_player myconnectindex
                ifg se_hitag 1
                {

                    ife st_do_once 0
                    {
                        set temp5 se_extra
                        ifl se_xvel 1
                            set se_xvel 1
                        div temp5 se_xvel
                        ifge se_extra 1
                        {
                            ife temp5 0
                                set temp5 1
                        }
                        else ifle se_extra 0
                        {
                            ife temp5 0
                                set temp5 -1
                        }
                        set se_extra temp5
                        set st_do_once 1
                    }
                    set temp5 0
                    ife counter 0
                    {
                        ife activateshit[se_hitag] 1
                        {
                            set counter 1
                            set temp5 1
                        }
                    }
                    else ifg counter se_xvel
                    {
                        ife activateshit[se_hitag] 1
                        {
                            sub counter 1
                            set temp5 1
                        }
                    }
                    else
                    {
                        ifle counter se_xvel
                        {
                            ife temp5 0
                            {
                                ife activateshit[se_hitag] 1
                                {
                                    ife se_rotdir 0
                                        set se_rotdir 1
                                    else
                                        set se_rotdir 0
                                }
                            }
                            for temp6 allwalls
                            {
                                ife wall[temp6].hitag se_hitag
                                {
                                    set move_v se_extra
                                    mul move_v counter
                                    state move_actor
                                    set temp5 walls_x[temp6]
                                    add temp5 move_xv
                                    set temp4 walls_y[temp6]
                                    add temp4 move_yv
                                    dragpoint temp6 temp5 temp4
                                }
                            }
                            ife se_rotdir 0
                            {
                                add counter 1
                                ifg counter se_xvel
                                    set se_rotdir 1
                            }
                            else
                            {
                                sub counter 1
                                ife counter 0
                                {
                                    set se_rotdir 0
                                    for temp6 allwalls
                                    {
                                        ife wall[temp6].hitag se_hitag
                                        {
                                            set temp5 walls_x[temp6]
                                            set temp4 walls_y[temp6]
                                            dragpoint temp6 temp5 temp4
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                break
        endswitch

        switch actorvar[temp].se_lotag
            case 76
            /* set temp5 topicalcream[10]
                add temp5 1
                setarray topicalcream[10] temp5 */
                setu[].vm_sprite temp
                setu[].vm_player myconnectindex
                ife se_extra 0
                    set se_extra 1
                else ifl se_extra 0
                    inv se_extra
                ife activateshit[se_hitag] 1
                    set counter se_extra
                ifg counter 0
                {
                    ifg counter 29
                    {
                        ifand se_xvel 1
                        {
                            ifl shakeitbabysm 3
                                set shakeitbabysm 30
                        }
                        else ifand se_xvel 2
                        {
                            ifl shakeitbabymed 3
                                set shakeitbabymed 30
                        }
                        else ifand se_xvel 4
                        {
                            ifl shakeitbabylow 3
                                set shakeitbabylow 30
                        }
                        else ifand se_xvel 8
                        {
                            ifl shakeitbabysm_fu 3
                                set shakeitbabysm_fu 30
                        }
                        else
                        {
                            ifl shakeitbaby 3
                                set shakeitbaby 30
                        }
                    }
                    else
                    {
                        ifand se_xvel 1
                        {
                            ifl shakeitbabysm counter
                                set shakeitbabysm counter
                            else ifg shakeitbabysm counter
                                set shakeitbabysm counter
                        }
                        else ifand se_xvel 2
                        {
                            ifl shakeitbabymed counter
                                set shakeitbabymed counter
                            else ifg shakeitbabymed counter
                                set shakeitbabymed counter
                        }
                        else ifand se_xvel 4
                        {
                            ifl shakeitbabylow counter
                                set shakeitbabylow counter
                            else ifg shakeitbabylow counter
                                set shakeitbabylow counter
                        }
                        else ifand se_xvel 8
                        {
                            ifl shakeitbabysm_fu counter
                                set shakeitbabysm_fu counter
                            else ifg shakeitbabysm_fu counter
                                set shakeitbabysm_fu counter
                        }
                        else
                        {
                            ifl shakeitbaby counter
                                set shakeitbaby counter
                            else ifg shakeitbaby counter
                                set shakeitbaby counter
                        }
                    }
                    ifand se_xvel 8
                    {
                        ife player.cursectnum sprite.sectnum
                            add shakeitbabysm_fu_c 1
                    }
                    ifand se_xvel 16
                    {
                        ifn player.cursectnum sprite.sectnum
                            add shakeitbaby_killer 2
                    }
                    sub counter 1
                }
                break
            case 77
            /* set temp5 topicalcream[11]
                add temp5 1
                setarray topicalcream[11] temp5 */
                setu[].vm_sprite temp
                ife st_do_once 0
                {
                    for itervar range se_game_num
                    {
                        set temp6 se_game[itervar]
                        setu[].vm_sprite temp6
                        geta[temp6].picnum temp4

                        ife temp4 SECTOREFFECTOR
                        {
                            ife se_lotag 77
                            {
                                for itervar range se_game_num
                                {
                                    set temp2 se_game[itervar]
                                    geta[temp2].picnum temp4
                                    ife temp4 SECTOREFFECTOR
                                    {
                                        ife se_hitag actorvar[temp2].se_hitag
                                            ife se_extra actorvar[temp2].se_extra
                                                ife actorvar[temp2].se_lotag 77 ifn temp2 THISACTOR
                                                    set se_swap_linkid temp2
                                    }
                                }
                                set st_do_once 1
                            }
                        }
                    }
                    setu[].vm_sprite temp
                    set st_do_once 1
                }
                setu[].vm_sprite temp
                setu[].vm_player myconnectindex
                ife counter 0
                {
                    set temp6 0
                    ife activateshit[se_hitag] 1
                    {
                        ifand se_xvel 8
                        {
                            ifspritepal 9
                                spritepal 0
                            else
                                spritepal 9
                        }
                        else
                            set temp6 1
                    }
                    ifand se_xvel 8
                    {
                        ifspritepal 0
                            set temp6 1
                    }

                    ife player[].cursectnum sprite[].sectnum
                    {
                        ife temp6 1
                        {
                            getp[].i temp4
                            getav[temp4].se_swap_linkid temp3
                            ifn temp3 temp
                            {
                                getp[].posx temp3
                                sub temp3 sprite[].x
                                geta[se_swap_linkid].x temp2
                                add temp2 temp3
                                setp[].posx temp2
                                setp[].oposx temp2
                                setp[].bobposx temp2
                                
                                getp[].posy temp3
                                sub temp3 sprite[].y
                                geta[se_swap_linkid].y temp2
                                add temp2 temp3
                                setp[].posy temp2
                                setp[].oposy temp2
                                setp[].bobposy temp2
                                
                                getp[].posz temp3
                                sub temp3 sprite[].z
                                geta[se_swap_linkid].z temp2
                                add temp2 temp3
                                setp[].posz temp2
                                setp[].oposz temp2
                                
                               // setav[se_swap_linkid].counter 1
                                setp[].cursectnum sprite[se_swap_linkid].sectnum
                                getp[].i temp4
                                setav[temp4].se_swap_linkid se_swap_linkid
                            }
                            else
                            {
                                getp[].i temp4
                                setav[temp4].se_swap_linkid -1
                            }
                        }
                        else
                        {
                            getp[].i temp4
                            getav[temp4].se_swap_linkid temp3
                            ife temp3 temp
                                setav[temp4].se_swap_linkid -1
                        }
                    }
                    ifand se_xvel 1
                    {
                        for temp7 spritesofsector sprite[].sectnum
                        {
                            set temp3 0
                            ifand tiledata[sprite[temp7].picnum].gameflags 32
                                set temp3 1
                            else ife sprite[temp7].statnum STAT_ACTOR
                            {
                                getav[temp7].actor_switch temp4
                                ife temp4 1
                                {
                                    ifand se_xvel 4
                                        set temp3 1
                                }
                                else
                                    set temp3 1
                            }
                            else ife sprite[temp7].statnum STAT_ZOMBIEACTOR
                                set temp3 1
                            else ife sprite[temp7].statnum STAT_ARMORSHARD
                                set temp3 1
                            else ife sprite[temp7].statnum STAT_GENERIC_PARTICLE
                                set temp3 1
                            else ife sprite[temp7].statnum STAT_SMOKE2
                                set temp3 1
                            else ife sprite[temp7].statnum STAT_GENERIC_DEBRIS
                                set temp3 1
                            else ife sprite[temp7].statnum STAT_FALLER
                                set temp3 1
                            else ife sprite[temp7].statnum STAT_PROJECTILE
                                set temp3 1
                            else ifand se_xvel 2
                            {
                                ife sprite[temp7].statnum STAT_MASTER_MOVER
                                    set temp3 1
                                else ife sprite[temp7].statnum STAT_BLOODSPLATHOST
                                    set temp3 1
                                else ife sprite[temp7].statnum STAT_BLOODSPLAT
                                    set temp3 1
                                else ife sprite[temp7].statnum STAT_BULLETHOLE
                                    set temp3 1
                                else ifand se_xvel 4
                                    ife sprite[temp7].statnum STAT_DEFAULT
                                        set temp3 1
                            }
                            ife sprite[temp7].picnum APLAYER
                                set temp3 0

                            ifand se_xvel 16
                            {
                                ifl sprite[temp7].z sprite.z
                                    set temp3 0
                            }
                            else ifand se_xvel 32
                            {
                                ifg sprite[temp7].z sprite.z
                                    set temp3 0
                            }
                            ife temp3 1
                            {
                                ife temp6 1
                                {
                                    getav[temp7].se_swap_linkid temp3
                                    ifn temp3 temp
                                    {
                                        geta[temp7].x temp4
                                        sub temp4 sprite[].x
                                        geta[se_swap_linkid].x temp2
                                        add temp2 temp4
                                        seta[temp7].x temp2
                                        seta[temp7].htbposx temp2

                                        geta[temp7].y temp4
                                        sub temp4 sprite[].y
                                        geta[se_swap_linkid].y temp2
                                        add temp2 temp4
                                        seta[temp7].y temp2
                                        seta[temp7].htbposy temp2

                                        geta[temp7].z temp4
                                        sub temp4 sprite[].z
                                        geta[se_swap_linkid].z temp2
                                        add temp2 temp4
                                        seta[temp7].z temp2
                                        seta[temp7].htbposz temp2


                                        seta[temp7].sectnum sprite[se_swap_linkid].sectnum
                                      //  setav[se_swap_linkid].counter 1
                                        setav[temp7].se_swap_linkid se_swap_linkid
                                    }
                                    else
                                        setav[temp7].se_swap_linkid -1
                                }
                                else
                                {
                                    getav[temp7].se_swap_linkid temp3
                                    ife temp3 temp
                                        setav[temp7].se_swap_linkid -1
                                }
                            }
                        }
                    }
                }
                ife counter 1
                    set counter 0
                break
            case 78
            /* set temp5 topicalcream[12]
                add temp5 1
                setarray topicalcream[12] temp5 */
                setu[].vm_sprite temp
                ifl se_extra 0
                    set se_extra 0
                ifle tp_owner 0
                    set tp_owner 1
                set temp6 0
                ife activateshit[se_hitag] 1
                {
                    ifand se_zvel 1
                    {
                        ifspritepal 9
                            spritepal 0
                        else
                            spritepal 9
                    }
                    else
                        set temp6 1
                }
                ifspritepal 9
                    set se_rotamt 0
                else
                {
                    ifand se_zvel 1
                    {
                        add se_rotamt 1
                        ifge se_rotamt tp_owner
                        {
                           set temp6 1
                           set se_rotamt 0 
                        }
                    }
                }
                ife temp6 1
                {
                    set temp6 sprite[].sectnum
                    ife counter 0
                        set temp5 se_hitag
                    else ife counter 1
                        set temp5 se_extra
                    else ife counter 2
                        set temp5 se_xvel
                    else ife counter 3
                        set temp5 se_yvel
                    set temp3 counter
                    for temp7 wallsofsector temp6
                    {
                        ife temp3 counter ife wall[temp7].hitag temp5
                        {
                            sets[temp6].wallptr temp7
                            add counter 1
                        }
                    }
                    ife counter 1
                    {
                        ife se_extra 0
                            set counter 0
                    }
                    else ife counter 2
                    {
                        ife se_xvel 0
                            set counter 0
                    }
                    else ife counter 3
                    {
                        ife se_yvel 0
                            set counter 0
                    }
                    else ifge counter 4
                        set counter 0
                }
                break
            case 79
            /* set temp5 topicalcream[13]
                add temp5 1
                setarray topicalcream[13] temp5 */
                setu[].vm_sprite temp
                geta[].sectnum temp2
                ifn temp2 -1
                {
                    ife st_do_once 0
                    {
                        seta[].hitag 0
                        seta[].yvel sector[temp2].extra
                        ifl se_extra 0
                            set se_extra 0
                        set st_do_once 1
                    }
                    geta[].hitag temp3
                    add temp3 64
                    and temp3 2047
                    seta[].hitag temp3
                    
                    sin temp3 temp3
                    mulscale temp3 sprite[].yvel temp3 12
                    add temp3 sprite[].z
                    sets[temp2].ceilingz temp3
                }
                break
            case 80
                    setu[].vm_sprite temp
                    setu[].vm_player myconnectindex
                    ife activateshit[se_hitag] 1
                        ifle counter 0
                        {
                            set counter 1
                            ife VOLUME EP_MAIN
                            {
                                ife LEVEL 13
                                    ife se_hitag 666
                                        or cheevo_tracker 524288
                            }
                        }
                    ifg counter 0
                    {
                        ifge counter2 2
                        {
                            add counter 1
                            set counter2 0
                        }
                        else
                            add counter2 1

                        set fade_amount counter
                        clamp counter 0 63
                        ifge counter 63 ifp palive
                        {
                            getav[temp].se_hitag p_nextlevel_tag
                            getav[temp].se_extra p_nextlevel
                            getav[temp].se_shade temp3
                            abs temp3
                            set p_nextepisode temp3

                            getp .posx p_nextlevel_xoff
                            
                            ifand se_xvel 1
                            {
                                getp .posx p_nextlevel_xoff
                                sub p_nextlevel_xoff sprite.x
                                getp .posy p_nextlevel_yoff
                                sub p_nextlevel_yoff sprite.y
                                getp .posz p_nextlevel_zoff
                                sub p_nextlevel_zoff sprite.z
                                getp .poszv p_nextlevel_zvel
                            }
                            else
                            {
                                set p_nextlevel_xoff 0
                                set p_nextlevel_yoff 0
                                set p_nextlevel_zoff 0
                                set p_nextlevel_zvel 0
                            }
                            // sub p_nextlevel_zoff 482

                            // if the player is on a ladder adjust the offset to avoid
                            // getting shoved into the wrong sector at map load

                            // note: this gives us a one frame visual where you are
                            // away from the ladder, but technically it's less buggy
                            // hope to find a better solution later
                            ife p_laddermounted 1
                            {
                                div p_nextlevel_xoff 3
                                div p_nextlevel_yoff 3
                                setp[].posxv 0
                                setp[].posyv 0
                                setp[].poszv 0
                            }

                            geta .ang p_nextlevel_ang
                            getp .horiz p_nextlevel_horiz
                            getp .look_ang p_nextlevel_look_ang
                            getp .return_to_center p_nextlevel_rtc
                            setp .pyoff 0
                            setp .opyoff 0
                            ifn player.got_access 0
                                getp .got_access p_access_saved

                            setav .se_above 0
                            setp .movement_lock 15
                            getp .actors_killed p_actors_killed_last
                            getp .secret_rooms p_secrets_transition
                            set counter 0
                            set counter2 0
                            set fade_amount 0
                            savemapstate
                            getu[].clipping save_noclip
                            setu[].clipping 0
                            set p_actors_killed_last 0
                            set p_secrets_transition 0
                            set keepstatssafe 2
                            set num_flag32 0
                            set se_game_num 0
                            set se_displayrooms_num 0
                            set temp6 0
                            ifand se_zvel 1
                                set skip_autosave 1
                            for temp6 range NUMWALLS
                            {
                                setarray walls_x[temp6] 0
                                setarray walls_y[temp6] 0
                            }
                            for temp6 range NUMSECTORS
                                setarray tainted[temp6] 0
                            setarray sectpal[8192] 0
                            set temp2 LEVEL
                            sub temp2 current_part
                            add p_nextlevel temp2

                            ife p_laddermounted 1
                                set p_nextlevel_ladder 1

                            ife se_force_ep -1
                                getu[].volume_number p_nextepisode
                            ifl p_secrets_area 0
                            {
                                ifg p_nextlevel LEVEL
                                {
                                    for temp6 range 64
                                        clearmapstate temp6
                                }
                                else
                                    inv p_secrets_area
                            }
                            startlevel p_nextepisode p_nextlevel

                            set load_tile 0
                            set load_black 1
                        }
                    }
                break
            case 101
            /* set temp5 topicalcream[14]
                add temp5 1
                setarray topicalcream[14] temp5 */
                setu[].vm_sprite temp
                ife st_do_once 0
                {
                    ifl se_extra 0
                        set se_extra 0
                    ifl se_xvel 1
                        set se_xvel 1
                    for itervar range se_game_num
                    {
                        set temp3 se_game[itervar]
                        ife sprite[temp3].picnum SECTOREFFECTOR
                        {
                            ife actorvar[temp3].se_lotag 100
                            {
                                ife sprite[temp3].pal 0
                                {
                                    ife actorvar[temp3].se_hitag se_hitag
                                    {
                                        geta[temp3].x cam_xoff
                                        geta[temp3].y cam_yoff
                                        geta[temp3].z cam_zoff
                                        geta[temp3].sectnum cam_sectoff
                                        set cam_other temp3
                                    }
                                }
                            }
                        }
                    }
                    set st_do_once 1
                }
                set temp3 0
                ife activateshit[se_extra] 1
                    set temp3 1
                ifspritepal 9
                {
                    set temp3 1
                    spritepal 0
                }
                ife temp3 1
                {
                    ifn counter 0
                        inv counter
                    else
                        set counter 1
                }
                ifn counter 0
                {
                    ife counter se_xvel
                    {
                        ifand se_yvel 1
                        {
                            seta[cam_other].x cam_xoff
                            seta[cam_other].y cam_yoff
                            seta[cam_other].z cam_zoff
                            seta[cam_other].sectnum cam_sectoff
                            ifand se_yvel 2
                                set counter 1
                            else
                                set counter 0
                        }
                        else
                        {
                            seta[cam_other].x sprite[].x
                            seta[cam_other].y sprite[].y
                            seta[cam_other].z sprite[].z
                            seta[cam_other].sectnum sprite[].sectnum
                            ifand se_yvel 4
                                inv counter
                        }
                        
                    }
                    else
                    {
                        ifg counter 0
                        {
                            geta[].x temp3
                            sub temp3 cam_xoff
                            state divide_ru_camera
                            add temp3 sprite[cam_other].x
                            seta[cam_other].x temp3
                            
                            geta[].y temp3
                            sub temp3 cam_yoff
                            state divide_ru_camera
                            add temp3 sprite[cam_other].y
                            seta[cam_other].y temp3
                            
                            geta[].z temp3
                            sub temp3 cam_zoff
                            state divide_ru_camera
                            add temp3 sprite[cam_other].z
                            seta[cam_other].z temp3
                            
                            geta[cam_other].sectnum temp5
                            updatesectorz sprite[cam_other].x sprite[cam_other].y sprite[cam_other].z temp5
                            ifn temp5 -1
                                seta[cam_other].sectnum temp5
                        }
                        else
                        {
                            set temp3 cam_xoff
                            sub temp3 sprite[].x
                            state divide_ru_camera
                            add temp3 sprite[cam_other].x
                            seta[cam_other].x temp3
                            
                            set temp3 cam_yoff
                            sub temp3 sprite[].y
                            state divide_ru_camera
                            add temp3 sprite[cam_other].y
                            seta[cam_other].y temp3
                            
                            set temp3 cam_zoff
                            sub temp3 sprite[].z
                            state divide_ru_camera
                            add temp3 sprite[cam_other].z
                            seta[cam_other].z temp3
                            
                            geta[cam_other].sectnum temp5
                            updatesectorz sprite[cam_other].x sprite[cam_other].y sprite[cam_other].z temp5
                            ifn temp5 -1
                                seta[cam_other].sectnum temp5
                        }
                        add counter 1
                        ife counter 0
                        {
                            ifand se_yvel 8
                            {
                                seta[cam_other].x cam_xoff
                                seta[cam_other].y cam_yoff
                                seta[cam_other].z cam_zoff
                                seta[cam_other].sectnum cam_sectoff
                                set counter 1
                            }
                        }
                        else ife counter se_xvel
                        {
                            ifand se_yvel 4
                            {
                                seta[cam_other].x sprite[].x
                                seta[cam_other].y sprite[].y
                                seta[cam_other].z sprite[].z
                                seta[cam_other].sectnum sprite[].sectnum
                                inv counter
                                add counter 1
                            }
                        }
                    }
                }
                else
                {
                    seta[cam_other].x cam_xoff
                    seta[cam_other].y cam_yoff
                    seta[cam_other].z cam_zoff
                    seta[cam_other].sectnum cam_sectoff
                }
                break
            case 102
                setu .vm_sprite temp
                ifl se_extra 0
                    set se_extra 0
                ifg se_hitag 0
                {
                    ife activateshit[se_hitag] 1
                    {
                        ifspritepal 9
                            spritepal 0
                        else
                            spritepal 9
                    }
                }
                ifspritepal 9
                    set counter 0
                add counter 1
                ifg counter 2
                {
                    getflorzofslope sprite.sectnum sprite.x sprite.y temp3
                    for temp2 spritesofsector sprite.sectnum
                    {
                        ifn temp2 THISACTOR
                        {
                            set temp3 sprite[temp2].z
                            set temp4 sprite[temp2].zvel
                            ifg temp4 0
                            {
                                shiftl temp4 2
                                add temp3 temp4
                            }
                            ifand se_extra 4
                            {
                                set temp3 sprite.z
                                add temp3 1
                            }
                            ifg temp3 sprite.z
                            {
                                ife temp2 player[myconnectindex].i
                                {
                                    ifand se_extra 1
                                    {
                                        setp[myconnectindex].posx 524288
                                        setp[myconnectindex].posy 524288
                                        setp[myconnectindex].posz temp3
                                    }
                                }
                                else
                                {
                                    ife sprite[temp2].statnum STAT_RAIN
                                        seta[temp2].z sprite[temp2].htfloorz
                                    else ifand se_extra 2
                                        nullop
                                    else
                                    {
                                        seta[temp2].x 524288
                                        seta[temp2].y 524288
                                        seta[temp2].z temp3
                                        seta[temp2].htextra 65536
                                        seta[temp2].sectnum -1
                                        ife sprite[temp2].statnum STAT_PROJECTILE
                                        {
                                            getthisprojectile[temp2].workslike temp3
                                            ifand temp3 2
                                            {
                                                ifg sprite[temp2].yvel 1
                                                    seta[temp2].yvel 1
                                            }
                                        }
                                        ifand tiledata[sprite[temp2].picnum].gameflags 32
                                        {
                                            seta[temp2].httimetosleep 300
                                            changespritestat temp2 STAT_ACTOR
                                            ife sprite[temp].picnum A_MECHSECT
                                            {
                                                setav[temp].enemy_init 1
                                                setav[temp].ms_faller 0
                                            }
                                            else
                                                setav[temp].enemy_init 1
                                            setav[temp].e_us_count -1
                                        }
                                        else ife actorvar[temp2].queued 0
                                        {
                                            seta[temp2].xrepeat 0
                                            changespritestat temp2 STAT_ACTOR
                                        }
                                    }
                                }
                            }
                        }
                    }
                    set counter 0
                }
                break
            case 200
                setu .vm_sprite temp
                clamp se_extra 0 262144
                ifspritepal 1
                {
                    ifand p_trigger_next se_extra
                    {
                        xor p_trigger_next se_extra
                        setarray preloadactivations[se_hitag] 1
                    }
                }
                else
                {
                    ife activateshit[se_hitag] 1
                        or p_trigger_next se_extra
                }
                break
            case 201
                setu .vm_sprite temp
                ife activateshit[se_hitag] 1
                    set counter 1
                ife counter 1
                {
                    set p_dontdie 1
                    add counter2 1
                    ifg se_xvel 0
                    {
                        ifl se_xvel 63
                            set se_xvel 63
                        set p_end_game_time se_xvel
                    }
                    ifge counter2 se_extra
                    {
                        ifl p_whitefade p_end_game_time
                            add p_whitefade 1
                        else
                        {
                            add counter3 1
                            ife counter3 30
                            {
                                set p_whitefade 0
                                set counter 0
                                set counter2 0
                                set counter3 0
                            }
                        }
                    }
                }
                break
            case 420
                setu .vm_sprite temp
                ife activateshit[se_hitag] 1
                    set fryall 1
                break
        endswitch
    }
    // getticks temp
    // sub temp timediff
    // qputs 11 %ld %ld 
    /* | %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld */
    // qsprintf 11 11 temp lastdiff 
    /* topicalcream[0] topicalcream[1] topicalcream[2] topicalcream[3] topicalcream[4] topicalcream[5] topicalcream[6] topicalcream[7] topicalcream[8] topicalcream[9] topicalcream[10] topicalcream[11] topicalcream[12] topicalcream[13] topicalcream[14] */
    // setp[myconnectindex].ftq 11
    // setp[myconnectindex].fta 99
    /* ifn temp 0
    {
        set lastdiff temp
        set lastdiffcount 5
    }
    sub lastdiffcount 1
    ife lastdiffcount 0
        set lastdiff 0 */
    // pivots
    for temp3 sprofstat STAT_LOCATOR // find first locator
    {
        ifg actorvar[temp3].se_xvel 0
        {
            ife activateshit[actorvar[temp3].se_xvel] 1
            {       
                getav[temp3].se_extra temp4
                ifg temp4 2
                {
                    ifand temp4 4
                    {
                        or temp4 8
                        xor temp4 4
                        setav[temp3].se_extra temp4
                    }
                    else ifand temp4 8
                    {
                        xor temp4 8
                        or temp4 4
                        setav[temp3].se_extra temp4
                    }
                    else
                    {
                        ife sprite[temp3].pal 9
                            seta[temp3].pal 0
                        else
                            seta[temp3].pal 9
                    }
                }
                else
                {
                    ife sprite[temp3].pal 9
                        seta[temp3].pal 0
                    else
                        seta[temp3].pal 9
                }
            }
        }
    }
    for temp sprofstat STAT_MASTER_MOVER
    {
        setu .vm_sprite temp // now we can do thisactor and other nice stuff
        setu .vm_player myconnectindex
        ifg ps_flash 0
            sub ps_flash 1
        // some things we should only do once!

        // ldist temp4 THISACTOR player[myconnectindex].i
        // ifl temp4 1024
        ife sprite.picnum T_BALLOON ifspritepal 15
        {
            cstator 256
            ife st_do_once 0
                set actor_switch 1
            ife actor_switch_usable 1
            {
                dist temp3 THISACTOR player.i
                ifl temp3 6144
                {
                    ifn p_lastline -1
                    {
                        stopactorsound player[].i S_SHELLY_SEARCHTALK1
                        stopactorsound player[].i S_SHELLY_SEARCHTALK2
                        stopactorsound player[].i p_lastline
                        setarray sound_playback[p_lastline] 0
                        set p_lastline S_SHELLYVO_5_13
                        actorsound player[].i p_lastline
                        set actor_switch 0
                    }
                }
                set actor_switch_usable 0
            }
        }
        ife player[myconnectindex].sbs THISACTOR ife player[myconnectindex].on_ground 1
        {
            geta[].xvel move_v
            mul move_v 5
            state move_actor
            shiftl move_xv 9
            shiftl move_yv 9
            getp[myconnectindex].posxv temp4
            add temp4 move_xv
            setp[myconnectindex].posxv temp4
            getp[myconnectindex].posyv temp4
            add temp4 move_yv
            setp[myconnectindex].posyv temp4
        }
        ife st_do_once 0
        {
            set st_do_once 1
            geta .zvel se_zvel
        }
        ifg se_zvel 0
            ife activateshit[se_zvel] 1
                set ps_flash -1

        ife pivot_init 0
        {
            // using "fall" should prevent some potential weirdness
            fall
            seta[temp].zvel 0
            set pivot_ang sprite[temp].ang // we need to save the original angle

            for temp3 sprofstat STAT_LOCATOR // find first locator
            {
                ife actorvar[temp3].se_hitag pivot_lotag
                {
                    set pivot_current_point sprite[].yvel
                    ife sprite[temp3].lotag sprite[].yvel
                        set pivot_current_id temp3
                    add pivot_max_points 1
                    ife sprite[temp3].ang 0
                        set pivot_turning 1
                }
            }
            for temp2 sprofstat STAT_SLAVE_MOVER // bits to move around
            {
                ife actorvar[temp].pivot_hitag actorvar[temp2].pivot_hitag
                {
                    setav[temp2].pivot_master_id temp
                    getav[temp].pivot_init temp3
                    ife temp3 0     // only get the offsets once!
                    {
                        geta[temp].x temp3
                        sub temp3 sprite[temp2].x
                        setav[temp2].pivot_xoff temp3

                        geta[temp].y temp3
                        sub temp3 sprite[temp2].y
                        setav[temp2].pivot_yoff temp3
                        setav[temp2].pivot_ang sprite[temp2].ang
                        
                        geta[temp].z temp3
                        sub temp3 sprite[temp2].z
                        setav[temp2].pivot_zoff temp3
                    }
                    seta[temp2].sectnum sprite[temp].sectnum
                }
            }

        }
        else
        {
            ifn pivot_turning 1
            {
                ife pivot_stopped 0
                    seta[].xvel sprite[].extra  // move the fucker
                else
                    seta[].xvel 0
                ifn pivot_current_id -1 ifand actorvar[pivot_current_id].se_yvel 1
                {
                    ifand actorvar[pivot_current_id].se_yvel 2
                    {
                        geta[pivot_current_id].z temp4
                        sub temp4 sprite.z
                        set temp5 temp4
                        set temp6 temp5
                        abs temp6
                        shiftr temp4 3
                        ifand actorvar[pivot_current_id].se_yvel 4
                        {
                            ifl temp6 1024
                                shiftr temp4 1
                            else
                                shiftr temp4 2
                        }
                        ifand actorvar[pivot_current_id].se_yvel 8
                        {
                            ifl temp6 1024
                                shiftr temp4 1
                            else
                                shiftr temp4 2
                        }
                        set temp7 temp4
                        abs temp7
                        ifl temp6 128
                            seta .z sprite[pivot_current_id].z
                        else ifl temp7 32
                            seta .z sprite[pivot_current_id].z
                        else ife temp4 0
                            seta .z sprite[pivot_current_id].z
                        else ife temp4 temp5
                            seta .z sprite[pivot_current_id].z
                        else
                        {
                            geta .z temp3
                            add temp3 temp4
                            seta .z temp3
                        }
                    }
                    else
                    {
                        ldist temp3 THISACTOR pivot_current_id
                        geta[pivot_current_id].z temp4
                        sub temp4 sprite.z
                        set temp5 temp4
                        shiftl temp4 8
                        ife temp4 0
                            set temp4 1
                        ife temp3 0
                            set temp4 0
                        else
                            div temp4 temp3
                        ife temp4 0
                            ifn temp5 0
                                set temp4 temp5
                        ife temp4 0
                            seta .z sprite[pivot_current_id].z
                        else ife temp4 temp5
                            seta .z sprite[pivot_current_id].z
                        else
                        {
                            geta .z temp3
                            add temp3 temp4
                            seta .z temp3
                        }
                    }
                }
                ifand se_xvel 1
                    ssp THISACTOR 0
                else
                    ssp THISACTOR CLIPMASK0
            }

            ifn pivot_current_point -1 ifn pivot_current_id -1
            {
                ife pivot_current_point sprite[pivot_current_id].lotag
                {
                    ifand se_xvel 2
                    {
                        ife sprite[pivot_current_id].pal 9
                        {
                            ifand se_xvel 32768
                                nullop
                            else
                            {
                                geta .cstat pivot_old_cstat
                                or se_xvel 32768
                                cstat 32768
                            }
                        }
                        else ifand se_xvel 32768
                        {
                            xor se_xvel 32768
                            seta .cstat pivot_old_cstat
                        }
                    }
                    set temp3 pivot_current_id
                    ife sprite[temp3].ang 0
                    {
                        geta[].ang temp4
                        set pivot_turning 1
                        add temp4 sprite[].extra
                        and temp4 2047
                        seta[].ang temp4
                        // after rotation we need to get the diff between that and the original ang
                        sub temp4 actorvar[temp].pivot_ang

                        ifg temp4 1023
                            sub temp4 2047
                        ifl temp4 -1023
                            add temp4 2047

                        setav[temp].pivot_angdiff temp4
                    }
                    set temp3 pivot_current_id
                    ldist temp4 THISACTOR temp3
                    set temp5 sprite[].extra
                    ife sprite[temp3].ang 512
                        shiftl temp5 3
                    else
                        shiftr temp5 1
                        
                    ifl temp4 temp5
                    {
                        set temp5 0
                        set pivot_stopped 0
                        ifand actorvar[pivot_current_id].se_yvel 2
                        {
                            set pivot_stopped 1
                            geta .z temp6
                            sub temp6 sprite[pivot_current_id].z
                            abs temp6
                            ifg temp6 128
                                set temp5 1
                            else
                                seta .z sprite[pivot_current_id].z
                        }
                        ife sprite[pivot_current_id].pal 9
                        {
                            set pivot_stopped 1
                        }
                        else ife temp5 0
                        {
                            getav[pivot_current_id].se_zvel temp3
                            ifn temp3 0
                                seta[].extra temp3
                            add pivot_current_point 1
                            ifg pivot_current_point pivot_max_points
                                    set pivot_current_point 0
                            set pivot_stopped 0
                            getav[pivot_current_id].tp_owner temp3
                            ifg temp3 -1
                                set pivot_current_point temp3
                            ifn pivot_max_points 0
                            {
                                for temp3 sprofstat STAT_LOCATOR // find first locator
                                {
                                    ife actorvar[temp3].se_hitag pivot_lotag ife sprite[temp3].lotag pivot_current_point
                                    {
                                        set pivot_current_id temp3
                                    }

                                }
                            }
                        }
                    }
                    else
                    {
                        set att_noclamp 1
                        set att_target temp3
                        state angle_to_target
                        set temp4 att_return // save this for later

                        ife sprite[temp3].ang 512
                        {
                            ldist temp6 THISACTOR temp3
                            div temp6 sprite[].extra
                            set temp5 att_return
                            mul temp5 9
                            div temp5 10
                            abs temp5
                            ifg temp6 temp5
                                set temp6 temp5
                            ife temp6 0
                                set temp6 1
                            div att_return temp6
                        }
                        else
                            div att_return 5
                        ife sprite[temp3].ang 1536
                            set pivot_turning 1

                        ifl temp4 5 ifg temp4 -5 // recall here
                        {
                            set pivot_turning 0
                            set att_noclamp 1
                            set att_target temp3
                            state angle_to_target
                        }

                        geta[].ang temp4
                        ife sprite[temp3].ang 0
                        {
                            set pivot_turning 1
                            add temp4 sprite[].extra
                        }
                        else
                            sub temp4 att_return
                        and temp4 2047
                        seta[].ang temp4
                        // after rotation we need to get the diff between that and the original ang
                        sub temp4 actorvar[temp].pivot_ang

                        ifg temp4 1023
                            sub temp4 2047
                        ifl temp4 -1023
                            add temp4 2047

                        setav[temp].pivot_angdiff temp4
                    }
                }
            }
        }

        setav[temp].pivot_init 2
    }
    set temp9 MAX_MOVER_EXPLO_SPARK // max explosion sparks
    for temp2 sprofstat STAT_SLAVE_MOVER // bits to move around
    {

        ife ps_flash_col -1
            set ps_flash_col sprite.pal
        getav[temp2].pivot_master_id temp
        ifn temp -1
        {
            setu .vm_sprite temp2
            getav[temp].ps_flash temp6
            ifg temp6 0
            {
                ifn sprite.pal 69
                {
                    set ps_flash_col sprite.pal
                    spritepal 69
                }
                else
                    seta .pal ps_flash_col
            }
            else
            {
                ifl temp6 0
                {
                    seta[temp].xrepeat 0
                    changespritestat temp STAT_ACTOR
                    
                    espawn A_EXPLOSION
                    seta[RETURN].cstat 32768
                    seta[RETURN].xrepeat 64
                    seta[RETURN].yrepeat 64
                    setav[RETURN].explosion_nosmoke 1
                    ife temp9 0
                        setav[RETURN].explosion_nospark 1
                    else ifrnd 127
                        setav[RETURN].explosion_nospark 1
                    else
                        sub temp9 1
                    seta .xrepeat 0
                    changespritestat THISACTOR STAT_ACTOR
                }
                ifn ps_flash_col -1
                    seta .pal ps_flash_col
            }
            ifand actorvar[pivot_master_id].se_xvel 2
            {
                
                ifand actorvar[pivot_master_id].se_xvel 32768
                {
                    ifand se_xvel 32768
                        nullop
                    else
                    {
                        geta .cstat pivot_old_cstat
                        or se_xvel 32768
                        cstat 32768
                    }
                }
                else ifand se_xvel 32768
                {
                    xor se_xvel 32768
                    seta .cstat pivot_old_cstat
                }
            }
            geta[temp].x temp3
            getav[temp2].pivot_xoff temp4
            sub temp3 temp4
            seta[temp2].x temp3

            geta[temp].y temp3
            getav[temp2].pivot_yoff temp4
            sub temp3 temp4
            seta[temp2].y temp3
            
            geta[temp].z temp3
            getav[temp2].pivot_zoff temp4
            sub temp3 temp4
            seta[temp2].z temp3

            // using the previously saved difference rotatepoint and set a new location
            // doing this prevents error accumulation
            getav[temp].pivot_angdiff temp3
            rotatepoint sprite[temp].x sprite[temp].y sprite[temp2].x sprite[temp2].y temp3 temp4 temp5

            seta[temp2].x temp4
            seta[temp2].y temp5

            // use the same diff to match the new angle
            getav[temp2].pivot_ang temp4
            add temp4 temp3
            and temp4 2047
            seta[temp2].ang temp4

            seta[temp2].sectnum sprite[temp].sectnum
            geta[temp2].extra temp7
            ifl temp7 0
            {
                abs temp7
                ifand temp7 256
                {
                    set temp3 sprite[temp2].sectnum
                    updatesectorz sprite[temp2].x sprite[temp2].y sprite[temp2].z temp3
                    ifn temp3 -1
                        seta[temp2].sectnum temp3
                }
                ifand se_xvel 32768
                    nullop
                else ifand temp7 2
                {
                    setu .vm_sprite temp2
                    setu .vm_player myconnectindex
                    
                    
                    geta .ang temp3
                    add temp3 512
                    and temp3 2047
                    
                    set temp4 tilesizx[sprite.picnum]
                    mul temp4 sprite.xrepeat
                    shiftr temp4 3
                    set move_v temp4
                    cos move_xv temp3
                    sin move_yv temp3
                    mul move_xv move_v
                    mul move_yv move_v

                    shiftr move_xv 14
                    shiftr move_yv 14
                    set temp5 move_xv
                    set temp6 move_yv
                    
                    add temp5 sprite.x
                    add temp6 sprite.y
                    
                    
                    add temp3 1024
                    and temp3 2047
                    cos move_xv temp3
                    sin move_yv temp3
                    mul move_xv move_v
                    mul move_yv move_v

                    shiftr move_xv 14
                    shiftr move_yv 14
                    
                    add move_xv sprite.x
                    add move_yv sprite.y
                    
                    geta[player.i].x att_x
                    sub att_x temp5
                    geta[player.i].y att_y
                    sub att_y temp6

                    getangle att_ang att_x att_y
                    geta .ang att_return
                    sub att_return 512
                    and att_return 2047
                    
                    sub att_return att_ang

                    ifg att_return 1023
                        sub att_return 2047
                    ifl att_return -1023
                        add att_return 2047
                    abs att_return
                    
                    set temp8 att_return // we're gonna clobber this below
                    
                    geta[player.i].x att_x
                    sub att_x move_xv
                    geta[player.i].y att_y
                    sub att_y move_yv

                    getangle att_ang att_x att_y
                    geta .ang att_return
                    add att_return 512
                    and att_return 2047
                    
                    sub att_return att_ang

                    ifg att_return 1023
                        sub att_return 2047
                    ifl att_return -1023
                        add att_return 2047
                    abs att_return

                    ldist temp3 temp2 player.i
                    ifl temp3 temp4
                    {
                        set temp6 0
                        
                        ifl temp8 32
                            set temp6 1
                        ifl att_return 32
                            set temp6 1
                        
                        ife temp6 1
                        {
                            set temp4 tilesizy[sprite.picnum]
                            shiftl temp4 2
                            mul temp4 sprite.yrepeat
                            geta .z temp3
                            sub temp3 temp4
                            
                            ifle player.posz sprite.z
                            {
                                ifge sprite[player.i].z temp3
                                {
                                    addphealth -5
                                    set temp8 1
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for temp sprofstat STAT_FALLER
    {
        ifand sprite[temp].yvel 1
        {
            ife actorvar[temp].st_do_once 0
            {

                geta[temp].x temp2
                setav[temp].se_xvel temp2
                geta[temp].y temp2
                setav[temp].se_yvel temp2
                setav[temp].st_do_once 1
            }
            else
            {
                getav[temp].se_xvel temp2
                seta[temp].x temp2
                getav[temp].se_yvel temp2
                seta[temp].y temp2
            }
            seta[temp].xvel 0
            ifn sprite[temp].zvel 0
            {
                ife actorvar[temp].counter 0
                    setav[temp].counter 1
            }

            ifg actorvar[temp].counter 0
            {
                setu[].vm_sprite temp
                set temp2 counter
                shiftl temp2 8
                ifg counter 8
                    shiftl temp2 2
                seta[].zvel temp2
                ifl counter 16
                    add counter 1
            }
        }
    }

    for temp sprofstat STAT_TRIGGER_FALLER
    {
        setu[].vm_sprite temp
        sleeptime 300
        ifle counter2 2
            add counter2 1
        else ifg se_lotag 0
        {
            ife activateshit[se_lotag] 1
            {
                ife counter 0
                {
                    set counter 1
                    set se_above 1
                    ife st_do_once 0
                    {
                        set st_do_once tilesizx[sprite[].picnum]
                        mul st_do_once sprite[].xrepeat
                        shiftr st_do_once 2
                        shiftr st_do_once 1
                    }
                }
            }
            ifg counter 0
            {
                ifand se_hitag 1
                {
                    ifg counter 1
                    {
                        getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp2
                        sub temp2 256
                        ifge sprite[].z temp2
                        {
                            seta[].xrepeat 0
                            changespritestat THISACTOR STAT_ACTOR
                        }
                        else
                        {
                            geta .z temp2
                            geta .z temp3
                            geta .htfloorz temp5
                            geta .zvel temp4
                            ifl temp4 512
                            {
                                set temp4 GRAVITATIONALCONSTANT
                                mul temp4 se_above
                            }
                            ifl se_above 3
                                add se_above 1
                            add temp2 temp4
                            add temp2 GRAVITATIONALCONSTANT
                            seta .z temp2
                            
                            geta .zvel temp2
                            add temp2 GRAVITATIONALCONSTANT
                            clamp temp2 -32767 32767
                            seta .zvel temp2
                            movesprite THISACTOR 0 0 sprite.zvel 0 temp2
                            
                            geta .z temp4
                            ifand se_hitag 2
                            {
                                seta .z temp3
                                geta .htfloorz temp8
                                seta .htfloorz temp5
                                movesprite THISACTOR 0 0 sprite.zvel 0 temp2
                                getzrange sprite.x sprite.y sprite.z sprite.sectnum temp2 temp3 temp5 temp6 st_do_once CLIPMASK0
                                sub temp5 1024
                                ifge sprite.z temp5
                                {
                                    ifg temp6 49151
                                    {
                                        sub temp6 49152
                                        ifn temp6 THISACTOR
                                        {
                                            ifn sprite[temp6].statnum 210
                                            {
                                                seta .xrepeat 0
                                                changespritestat THISACTOR STAT_ACTOR
                                            }
                                            else
                                                seta .z temp4
                                        }
                                    }
                                    else
                                        seta .z temp4
                                }
                                else
                                    seta .z temp4
                                ife sprite.z temp4
                                    seta .htfloorz temp8
                            }
                        }
                    }
                }
                else
                {
                    fall
                    iffloordistl 1 ifg counter 1
                    {
                        seta[].xrepeat 0
                        changespritestat THISACTOR STAT_ACTOR
                    }
                }
                ifl counter 2
                    add counter 1
            }
            
        }
    }

    for temp range num_fields
    {
        set temp2 walls_field[temp]
        getw[temp2].cstat temp3
        ifand temp3 16
        {
            set temp3 209 // 1 + 16 + 64 +128
            setw[temp2].blend 255
        }
        setw[temp2].cstat temp3
        getw[temp2].nextwall temp4
        ifn temp4 -1
        {
            setw[temp4].cstat temp3
            setw[temp4].overpicnum T_FORCEFIELD
            ife wall[temp2].lotag wall[temp4].lotag
                setw[temp4].lotag 0
        }
        ifg wall[temp2].lotag 0
        {
            ife activateshit[wall[temp2].lotag] 1
            {
                ifand temp3 16
                    set temp3 128
                else
                    set temp3 209
                setw[temp2].cstat temp3
                ifn temp4 -1
                {
                    setw[temp4].cstat temp3
                    setw[temp4].overpicnum T_FORCEFIELD
                }
            }
        }
    }
endevent

eventloadactor A_NEWRESPAWN
    geta[].hitag se_hitag
    seta[].hitag 0
    geta[].lotag se_lotag
    seta[].lotag 0
    geta[].extra se_extra
    geta[].xvel se_xvel
    geta[].yvel se_yvel
    geta[].zvel se_zvel
    geta[].owner tp_owner
    clamp se_extra 0 65536
    set temp sprite.cstat
    cstat 32768
    ifand temp 8
        cstator 8
    ifand temp 512
        cstator 512
    ifand temp 4
        cstator 4
    ifand temp 32
        cstator 32
    ifl se_lotag 0
    {
        inv se_lotag
        set enemy_dontsleep 1
    }
    changespritestat THISACTOR STAT_NEWRESPAWN
enda
var howmany
var horde_round_spawned
var newrespawnq 0 2
var newrespawn_addmore 0 2
var num32_temp


defstate r2_esleep
    changespritestat RETURN STAT_ZOMBIEACTOR
    ifn sprite[].pal 0
        seta[RETURN].pal sprite[].pal
ends

appendevent EVENT_WORLD
    set num32_temp num_flag32
    for temp7 sprofstat STAT_NEWRESPAWN
    {
        setu[].vm_sprite temp7
        ife sprite.xrepeat 0
            changespritestat THISACTOR STAT_ACTOR
        else ifg se_lotag 0
        {
            ife activateshit[se_lotag] 1
                add newrespawnq 1

            set temp 0
            ifg newrespawnq 0
                set temp 1
            
            ife VOLUME EP_HORDE
            {
                ifge num32_temp HORDE_MAXENEMIESONSCREEN
                {
                    ifand tiledata[se_hitag].gameflags 32
                            set temp 0
                }
            }
            ife temp 1
            {
                sub newrespawnq 1
                espawn se_hitag
                seta .xoffset -127
                seta[RETURN].owner temp7
                clamp tp_owner 0 65536
                ifg sprite.blend 0
                {
                    switch se_hitag
                        case A_TURRET
                            setav[RETURN].tp_owner sprite.blend
                            setav[RETURN].enemy_init -3
                            break
                        case A_SHOCKCANISTER
                        case A_SHOCKCANISTER_DMG
                        case A_MECHBOSS_BOTTOM
                            setav[RETURN].tp_owner sprite.blend
                            break
                    endswitch
                }
                switch se_hitag
                    case A_SHOCKCANISTER
                    case A_SHOCKCANISTER_DMG
                        ifand tp_owner 32
                            ifl userdef[].player_skill 2
                                seta[RETURN].xrepeat 0
                        ifand tp_owner 16
                            ifl userdef[].player_skill 3
                                seta[RETURN].xrepeat 0
                        ifand tp_owner 64
                            ifl userdef[].player_skill 4
                                seta[RETURN].xrepeat 0
                        break
                endswitch
                ifand tiledata[se_hitag].gameflags 32
                {
                        add howmany 1
                        add num32_temp 1
                        add horde_round_spawned 1
                        ifand sprite.cstat 32
                            set newrespawn_addmore 1
                        ifg newrespawn_addmore 0
                        {
                            set newrespawn_addmore player[myconnectindex].max_actors_killed
                            add newrespawn_addmore 1
                            setplayer[myconnectindex].max_actors_killed newrespawn_addmore
                            add p_killed 1
                            set newrespawn_addmore 1
                        }
                        setav[RETURN].se_hitag se_extra
                        setav[RETURN].se_xvel se_xvel
                        setav[RETURN].se_yvel se_yvel
                        setav[RETURN].se_zvel se_zvel
                        setav[RETURN].se_lotag tp_owner
                        ifg sprite[].pal 8
                        {
                            ifl sprite[].pal 11
                                changespritestat RETURN STAT_ZOMBIEACTOR
                            else
                            {
                                ife sprite[].pal 99
                                {
                                    ife sprite[RETURN].picnum A_CULTIST
                                        changespritestat RETURN STAT_ZOMBIEACTOR
                                    else ife sprite[RETURN].picnum A_CULTIST_STAYPUT
                                        changespritestat RETURN STAT_ZOMBIEACTOR
                                    else ifand sprite.cstat 4
                                        changespritestat RETURN STAT_ZOMBIEACTOR
                                    else
                                        setav[RETURN].enemy_init 1
                                }
                                else ifand sprite.cstat 4
                                    state r2_esleep
                                else
                                {
                                    setav[RETURN].enemy_init 1
                                    ifn sprite[].pal 0
                                        seta[RETURN].pal sprite[].pal
                                }
                            }
                        }
                        else ifand sprite.cstat 4
                            state r2_esleep
                        else
                        {
                            setav[RETURN].enemy_init 1
                            ifn sprite[].pal 0
                                seta[RETURN].pal sprite[].pal
                        }
                        ife actorvar[RETURN].enemy_init 1
                        {
                            seta[RETURN].httimetosleep 300
                            changespritestat RETURN STAT_ACTOR
                        }
                        ife enemy_dontsleep 1
                        {
                            setav[RETURN].enemy_dontsleep 1
                            seta[RETURN].httimetosleep 300
                            changespritestat RETURN STAT_ACTOR
                        }
                }
                else
                {
                    switch sprite[RETURN].picnum
                        case A_TURRET_BOTTOM
                            seta[RETURN].ang sprite .ang
                            seta[RETURN].pal sprite .pal
                            seta[RETURN].xrepeat sprite .xrepeat
                            seta[RETURN].yrepeat sprite .yrepeat
                            seta[RETURN].cstat 257
                            break
                        default
                            ife actorvar[RETURN].is_pickup 1
                            {
                                setav[RETURN].se_hitag se_extra
                                setav[RETURN].se_xvel se_xvel
                                setav[RETURN].se_yvel se_yvel
                                setav[RETURN].se_zvel se_zvel
                                setav[RETURN].se_lotag tp_owner
                            }
                            ifg sprite[].pal 0
                                seta[RETURN].pal sprite[].pal
                            break
                    endswitch
                    set temp RETURN
                    state is_item
                    ife temp6 1
                        setav[RETURN].se_yvel se_yvel
                }
                ifand sprite.cstat 512
                {
                    set se_lotag 0
                    seta .xrepeat 0
                }
                ifand sprite.cstat 8
                    set newrespawn_addmore 1
            }
        }
    }
endevent

var save_icon
array display_quote 90
var ticks1
var ticks2
var ticks_last
var ticks_5sec
var ticks_count
var ticks_average
var ticks_average5
var ticks_num
var ticks_num5
onevent EVENT_DISPLAYSTART
    ife profiler 1
        getticks ticks1
endevent
appendevent EVENT_WORLD
    ife profiler 1
    {
        ife ticks_count 150
        {
            set ticks_count 0
            set ticks_5sec ticks_average5
            mul ticks_5sec 100
            div ticks_5sec ticks_num5
            set ticks_average5 0
            set ticks_num5 0
        }
        else
            add ticks_count 1
    }
endevent
appendevent EVENT_DISPLAYROOMS
    ife sector[].lotag 1
    {
        getflorzofslope sprite[].sectnum sprite[].x sprite[].y temp
        ifl temp sprite[].z
        {
            sub temp sprite[].z
            abs temp
            shiftr temp 4
            sub cameraz temp
        }
    }
    switch player.curr_weapon
        case 1
            ifg weaponcount 0 ifl weaponcount 5
            {
                set temp weaponcount
                sub temp 2
                shiftl temp 4
                add cameraz temp
                shiftr temp 4
                sub temp 2
                abs temp
                shiftr temp 1
                add camerahoriz temp
            }
            break    
        case WEAPON_SHOTGUN
        case WEAPON_GRENADE
            ifg weaponcount 0 ifl weaponcount 8
            {
                set temp weaponcount
                sub temp 4
                shiftl temp 4
                add cameraz temp
                shiftr temp 4
                sub temp 4
                abs temp
                shiftr temp 1
                add camerahoriz temp
            }
            break
        case WEAPON_SMG
            ifg weaponcount 0 ifl weaponcount 5
            {
                set temp weaponcount
                sub temp 2
                shiftl temp 4
                add cameraz temp
                shiftr temp 4
                sub temp 2
                abs temp
                shiftr temp 1
                add camerahoriz temp
                ife weaponcount 1
                {
                    shiftr temp 1
                    add cameraang temp
                }
            }
            break
        case WEAPON_CROSSBOW
            ifg weaponcount 0
            {
                ifg weaponcount 39 ifl weaponcount 47
                {
                    set temp weaponcount
                    sub temp 37
                    sub temp 4
                    
                    shiftl temp 4
                    add cameraz temp
                    shiftr temp 4
                    sub temp 4
                    abs temp
                    shiftr temp 1
                    ife weaponcount 41
                        add temp crossbow_fire_amt
                    add camerahoriz temp
                }

            }
            break
        case WEAPON_BOWLINGBOMB
            ifg weaponcount 13  ifl weaponcount 20
            {
                set temp weaponcount
                sub temp 26
                shiftl temp 1
                add cameraz temp
                set temp weaponcount
                ifg temp 17
                    sub temp 14
                shiftr temp 4
                sub camerahoriz temp
                ifl weaponcount 15
                {
                    set temp cameraang
                    add temp weaponcount
                    sub temp 13
                    set cameraang temp
                }
            }
            break
        case WEAPON_MINIGUN
            ifg weaponcount 0
            {
                switch weaponcount
                    case 20
                    case 26
                    case 28
                    case 30
                        {
                            set temp weaponcount
                            sub temp 20
                            shiftl temp 1
                            add cameraz temp
                            shiftr temp 2
                            sub temp 2
                            abs temp
                            shiftr temp 1
                            add camerahoriz temp
                        }
                        break
                endswitch
            }
            break
    endswitch
endevent
appendevent EVENT_DISPLAYROOMS
    ifn shakeitbaby_killer 0
        break
    ifn shakeitbaby 0
    {
        clamp shakeitbaby 0 30
        set temp shakeitbaby
        and temp 1
        shiftl temp 9
        set temp2 256
        sub temp2 temp
        shiftr temp2 1 // should have a better control mechanism for this kind of stuff later
        add cameraz temp2

        set temp shakeitbaby
        and temp 2
        set temp2 2
        sub temp2 temp
        shiftl temp2 2
        shiftr temp2 1
        add cameraang temp2
    }
    ifn shakeitbabysm 0
    {
        clamp shakeitbabysm 0 30
        set temp shakeitbabysm
        and temp 1
        shiftl temp 7
        set temp2 512
        sub temp2 temp
        // div temp2 2 // should have a better control mechanism for this kind of stuff later
        add cameraz temp2

        set temp shakeitbabysm
        and temp 2
        set temp2 2
        sub temp2 temp
        shiftl temp2 2
        div temp2 9
        add cameraang temp2
    }
    ifn shakeitbabysm_fu 0 ife shakeitbabysm_fu_c 1
    {
        clamp shakeitbabysm_fu 0 30
        set temp shakeitbabysm_fu
        and temp 1
        shiftl temp 7
        set temp2 512
        sub temp2 temp
        // div temp2 2 // should have a better control mechanism for this kind of stuff later
        add cameraz temp2

        set temp shakeitbabysm_fu
        and temp 2
        set temp2 2
        sub temp2 temp
        shiftl temp2 2
        div temp2 9
        add cameraang temp2
    }
    ifn shakeitbabymed 0
    {
        clamp shakeitbabymed 0 30
        set temp shakeitbabymed
        and temp 1
        shiftl temp 9
        set temp2 256
        sub temp2 temp
        shiftr temp2 3 // should have a better control mechanism for this kind of stuff later
        add cameraz temp2

        set temp shakeitbabymed
        and temp 2
        set temp2 2
        sub temp2 temp
        shiftl temp2 2
        shiftr temp2 3
        add cameraang temp2
    }
    ifn shakeitbabylow 0
    {
        clamp shakeitbabylow 0 30
        set temp shakeitbabylow
        and temp 1
        shiftl temp 9
        set temp2 256
        sub temp2 temp
        shiftr temp2 4 // should have a better control mechanism for this kind of stuff later
        add cameraz temp2

        set temp shakeitbabylow
        and temp 2
        set temp2 2
        sub temp2 temp
        shiftl temp2 2
        shiftr temp2 4
        add cameraang temp2
    }
endevent
var enable_3d
define THREEDEEINTENSITY 23 // higher is less. 10 should be lowest
var threedee THREEDEEINTENSITY GAMEVAR_NORESET GAMEVAR_PERPLAYER
defstate shift3d
    ifl threedee 16
    {
        qputs 11 threedee clamped to 16. default: 23
        echo 11
    }
    else ifg threedee 64
    {
        qputs 11 threedee clamped to 64. default: 23
        echo 11
    }
    clamp threedee 16 64
    cos temp5 temp
    sin temp7 temp
    shiftr temp5 threedee
    shiftr temp7 threedee
ends

var bitchfit
var amcam
var popcorn
array popcorn_popped 16 GAMEARRAY_UINT16

defstate display_popcorn
    getav[cam_id].tp_owner popcorn
    
    sub popcorn 65536
    ifg popcorn -1 ifl popcorn MAXSPRITES
    {
        resizearray popcorn_popped 0
        resizearray popcorn_popped 16
        // fill list
        for itervar range 16
        {
            setarray popcorn_popped[itervar] popcorn
            ifn popcorn -1
            {
                getav[popcorn].tp_owner popcorn
                sub popcorn 65536
                ifl popcorn 0
                    set popcorn -1
                ifg popcorn MAXSPRITES
                    set popcorn -1
            }
        }
        // display list
        for itervar range 16
        {
            set temp9 itervar
            sub temp9 15 // 0 to 15 is 16 values
            inv temp9
            set popcorn popcorn_popped[temp9]
            ifl popcorn 0
                    set popcorn -1
            ifg popcorn MAXSPRITES
                set popcorn -1
            ifn popcorn -1
            {
                getav[popcorn].cam_xoff temp
                sub temp camerax
                getav[popcorn].se_extra temp6
                ifn temp6 1
                    shiftr temp 3
                geta[popcorn].x temp2
                sub temp2 temp

                getav[popcorn].cam_yoff temp
                sub temp cameray
                getav[popcorn].se_extra temp6
                ifn temp6 1
                    shiftr temp 3
                geta[popcorn].y temp3
                sub temp3 temp

                getav[popcorn].cam_zoff temp
                sub temp cameraz
                getav[popcorn].se_extra temp6
                ifn temp6 1
                    shiftr temp 3
                geta[popcorn].z temp4
                sub temp4 temp

                setu[].maxspritesonscreen 1024
                set temp6 cameraq16ang
                ife enable_3d 1
                {
                    ife amcam 1
                        showviewq16unbiased temp2 temp3 temp4 temp6 cameraq16horiz sprite[popcorn].sectnum 0 0 319 199
                    else
                    {
                        set temp cameraq16ang
                        add temp 33554432
                        state shift3d

                        add temp5 temp2
                        add temp7 temp3
                        showviewq16unbiased temp5 temp7 temp4 temp6 cameraq16horiz sprite[cam_id].sectnum 0 0 160 199
                        set temp cameraq16ang
                        sub temp 33554432
                        state shift3d

                        add temp5 temp2
                        add temp7 temp3
                        showviewq16unbiased temp5 temp7 temp4 temp6 cameraq16horiz sprite[cam_id].sectnum 160 0 319 199
                    }
                }
                else
                    showviewq16unbiased temp2 temp3 temp4 temp6 cameraq16horiz sprite[popcorn].sectnum 0 0 319 199
            }
        }
    }
ends

var no_mirror
defstate display_skybox
    add no_mirror 1
    ifg no_mirror 2
    {
        set no_mirror 0
        break
    }
    ifn cam_id -1 ifn RETURN 1 ife p_nextlevel_ladder 0 ife cam_bypass 0
    {
        set temp 0
        ifn bitchfit 0
        {
            set temp 1
            add bitchfit 1
            ifge bitchfit 8
                set bitchfit 0
        }
        ifn gotpic[6135] 0
            set temp 2
        ifn gotpic[6130] 0
            set temp 2
        ife cam_force_seen 1
            set temp 2
        ifg temp 0
        {
            ife temp 2
                set bitchfit 0
            state display_popcorn
            getav[cam_id].cam_xoff temp
            sub temp camerax
            getav[cam_id].se_extra temp6
            ifn temp6 1
                shiftr temp 3
            geta[cam_id].x temp2
            sub temp2 temp

            getav[cam_id].cam_yoff temp
            sub temp cameray
            getav[cam_id].se_extra temp6
            ifn temp6 1
                shiftr temp 3
            geta[cam_id].y temp3
            sub temp3 temp

            getav[cam_id].cam_zoff temp
            sub temp cameraz
            getav[cam_id].se_extra temp6
            ifn temp6 1
                shiftr temp 3
            geta[cam_id].z temp4
            sub temp4 temp

            setu[].maxspritesonscreen 1024
            ifn bitchfit 0
            {
                set temp6 bitchfit
                shiftl temp6 8
                shiftl temp6 16
                add temp6 cameraq16ang
            }
            else
                set temp6 cameraq16ang
            ife enable_3d 1
            {
                set temp cameraq16ang
                add temp 33554432
                state shift3d

                add temp5 temp2
                add temp7 temp3
                showviewq16unbiased temp5 temp7 temp4 temp6 cameraq16horiz sprite[cam_id].sectnum 0 0 160 199
                set temp cameraq16ang
                sub temp 33554432
                state shift3d

                add temp5 temp2
                add temp7 temp3
                showviewq16unbiased temp5 temp7 temp4 temp6 cameraq16horiz sprite[cam_id].sectnum 160 0 319 199
            }
            else
                showviewq16unbiased temp2 temp3 temp4 temp6 cameraq16horiz sprite[cam_id].sectnum 0 0 319 199

            setu[].maxspritesonscreen MAXSPRITESONSCREEN
        }
    }
ends

appendevent EVENT_RESETGOTPICS
    setarray gotpic[6130] 0
    setarray gotpic[6135] 0
endevent
var did_3d
appendevent EVENT_DISPLAYSTART
    set did_3d 0
    set no_mirror 0
endevent
defstate display_event_common
    ifn load_black 0
        set RETURN 1

    ife enable_3d 1
    {
        ife did_3d 0
        {
            set did_3d 1
            state display_skybox
            set temp cameraq16ang
            add temp 33554432
            state shift3d

            add temp5 camerax
            add temp7 cameray
            showviewq16unbiased temp5 temp7 cameraz cameraq16ang cameraq16horiz camerasect 0 0 160 199
            set temp cameraq16ang
            sub temp 33554432
            state shift3d

            add temp5 camerax
            add temp7 cameray
            showviewq16unbiased temp5 temp7 cameraz cameraq16ang cameraq16horiz camerasect 160 0 319 199
        }
    }
    else
        state display_skybox
ends

appendevent EVENT_DISPLAYROOMS
    state display_event_common
        ife enable_3d 1
            set RETURN 1
endevent
/*
// TODO: Evaluate if okay to uncomment this
appendevent EVENT_DISPLAYROOMSCAMERA
    state display_event_common
endevent
*/
// TODO: Evaluate why this event does not help the viewscreen skybox issue
var o_camerax
var o_cameray
var o_cameraz
var o_cameraq16ang
var o_cameraq16horiz
appendevent EVENT_DISPLAYROOMSCAMERATILE
    set amcam 1
    set o_camerax camerax
    set o_cameray cameray
    set o_cameraz cameraz
    set o_cameraq16ang cameraq16ang
    set o_cameraq16horiz cameraq16horiz
    geta .x camerax
    geta .y cameray
    geta .z cameraz
    geta .ang temp
    shiftl temp 16
    set cameraq16ang temp
    geta .shade temp
    add temp 100
    shiftl temp 16
    set cameraq16horiz temp
    state display_event_common
    set camerax o_camerax
    set cameray o_cameray
    set cameraz o_cameraz
    set cameraq16ang o_cameraq16ang
    set cameraq16horiz o_cameraq16horiz
    set amcam 0
endevent

appendevent EVENT_SPAWN 
    switch sprite.picnum
        case A_GTFO
        case A_EGTFO
            cstat 32768
            geta[].lotag se_lotag
            seta[].lotag 0
            geta[].hitag se_hitag
            or se_hitag 128
            ifactor A_EGTFO
            {
                ife se_hitag 128
                    or se_hitag 1
                clamp se_hitag 1 255
            }
            seta[].hitag 0
            ifspritepal 9
                nullop
            else
                inv se_lotag
            ifactor A_EGTFO
                changespritestat THISACTOR STAT_EGTFO
            else
                changespritestat THISACTOR STAT_GTFO
            break
    endswitch
endevent

appendevent EVENT_WORLD
    for temp sprofstat STAT_GTFO
    {
        getav[temp].se_lotag temp3
        set temp4 temp3
        abs temp3
        ife activateshit[temp3] 1
        {
            inv temp4
            setav[temp].se_lotag temp4
        }
        geta[temp].sectnum temp3
        ifg temp4 0
        {
            ifand gtfo[temp3] actorvar[temp].se_hitag
            {
                set temp4 gtfo[temp3]
                xor temp4 actorvar[temp].se_hitag
                setarray gtfo[temp3] temp4
            }
        }
        else
        {
            set temp4 gtfo[temp3]
            or temp4 actorvar[temp].se_hitag
            setarray gtfo[temp3] temp4
        }
    }
    for temp sprofstat STAT_EGTFO
    {
        getav[temp].se_lotag temp3
        set temp4 temp3
        abs temp3
        ife activateshit[temp3] 1
        {
            inv temp4
            setav[temp].se_lotag temp4
        }
        geta[temp].sectnum temp3
        ifl temp4 0
            setarray e_gtfo[temp3] 0
        else
            setarray e_gtfo[temp3] actorvar[temp].se_hitag
    }
endevent

appendevent EVENT_SPAWN
    switch sprite.picnum
        case A_QUOTEBUSTER
            geta .hitag se_hitag
            geta .lotag se_lotag
            geta .extra se_extra
            seta .extra -1
            seta .hitag 0
            seta .lotag 0
            cstat 32768
            ifspritepal 1
                changespritestat THISACTOR STAT_QUOTEBUSTERS2
            else ifspritepal 2
                changespritestat THISACTOR STAT_QUOTEBUSTERS2
            else
                changespritestat THISACTOR STAT_QUOTEBUSTERS
            break
        case A_MUSICBEAST
            geta .hitag se_hitag
            geta .lotag se_lotag
            geta .extra se_extra
            clamp se_extra 0 6
            clamp se_hitag 0 63
            seta .extra -1
            seta .hitag 0
            seta .lotag 0
            cstat 32768
            changespritestat THISACTOR STAT_MUSICBEAST
            break
    endswitch
endevent

appendevent EVENT_WORLD
    for temp sprofstat STAT_QUOTEBUSTERS
    {
        setu .vm_sprite temp
        setu .vm_player myconnectindex
        ife activateshit[se_lotag] 1
        {
            
            setp .ftq se_hitag
            setp .fta 99
            echo se_hitag
            ifspritepal 9
            {
                seta .xrepeat 0
                changespritestat THISACTOR STAT_ACTOR
            }
        }
    }
    for temp sprofstat STAT_MUSICBEAST
    {
        setu .vm_sprite temp
        setu .vm_player myconnectindex
        ife activateshit[se_lotag] 1
        {
            starttrackslot se_extra se_hitag
            ifspritepal 9
            {
                seta .xrepeat 0
                changespritestat THISACTOR STAT_ACTOR
            }
        }
    }
endevent


var blackened 0 1
var blackened_tics 0 1

defstate quotebusters2
    getu .vm_sprite temp7
    set temp8 0
    for temp sprofstat STAT_QUOTEBUSTERS2
    {
        setu .vm_sprite temp
        ife activateshit[se_lotag] 1
        {
            switch sprite.pal
                case 1
                case 2
                    getp .ftq temp9
                    ife temp9 4
                    {
                        set temp8 1
                        ifg se_extra -1
                            setp .ftq se_extra
                        else
                        {
                            set temp9 se_hitag
                            ifspritepal 2
                                add temp9 1
                            setp .ftq temp9
                        }
                    }
                    else ife temp9 8
                    {
                        setp .ftq se_hitag
                        set temp8 1
                    }
                    break
            endswitch
        }
    }
    setu .vm_sprite temp7
ends

appendevent EVENT_DISPLAYSTART
    ifn load_black 0
    {
        ife blackened 0
            set blackened 1
        palfrom 63 0 0 0
        screenpal 0 0 0 255
    }
    ifg blackened 0
    {
        ifn blackened_tics totalclock
        {
            add blackened 1
            set blackened_tics totalclock
        }
    }
    set temp2 0
    set temp3 0
    ifn p_goodsect -1
    {
        getp[].i temp3
        getp[].posz temp6
        set temp5 player[].autostep_sbw
        shiftr temp5 1
        sub temp6 temp5
        getzrange player[].posx player[].posy temp6 sprite[temp3].sectnum temp temp8 temp4 temp5 player[].clipdist 0
        set temp4 -1
        ifl temp5 49152
            sub temp5 16384
        else
            set temp5 -1
        /* redefinequote 11 %ld %ld
        qsprintf 11 11 temp5 p_goodsect
        quote 11 */
        set temp3 player.cursectnum
        ifle temp3 -1
            set temp3 p_goodsect
        set temp3 gtfo[temp3]
        ifg temp5 -1
            or temp3 gtfo[temp5]
        ifand temp3 128
            set temp2 1
        ifand temp3 4
            ifand temp3 128
                xor temp3 128
    }
    ife player[].cursectnum -1
    {
        ife userdef[].clipping 0
            set temp2 1
    }
    else ife sector[].floorz sector[].ceilingz
        set temp2 1
        
    ife userdef[].clipping 0
    {
        ifg temp2 0
        {
            ifand temp3 128
            {
                setp[].posx p_goodx
                setp[].posy p_goody
                setp[].posxv 0
                setp[].posyv 0
                ifand temp3 1
                {
                    ifp ponground
                        ifl player[].posz p_goodz
                            setp[].posz p_goodz
                    set temp5 p_goodxv
                    inv temp5
                    set temp6 temp5
                    shiftr temp6 3
                    add temp5 temp6
                    setp[].posxv temp5
                    set temp5 p_goodyv
                    inv temp5
                    set temp6 temp5
                    shiftr temp6 3
                    add temp5 temp6
                    setp[].posyv temp5
                }
                setp[].cursectnum p_goodsect
            }
        }
        else
        {
            getp[].posx p_goodx
            getp[].posy p_goody
            getp[].posz p_goodz
            getp[].posxv p_goodxv
            getp[].posyv p_goodyv
            getp[].cursectnum p_goodsect
        }
    }
    
    ifn player[].ftq 0
    {
        set temp 0
        switch player.ftq // delete certain quotes
            case 109
            case 110
                set temp 1
                break
            case 4
            case 8
                state quotebusters2
                ife temp8 0
                {
                    ife player.ftq 4
                        setp .ftq 362
                    else
                        setp .ftq 361
                }
                set temp8 player.ftq
                echo temp8
                set temp 0
                break
        endswitch

        ife temp 1
        {
            setp .ftq 0
            setp .fta 0
        }
        ifge player.fta 99
        {
            set temp 0
            set temp6 0
            for temp range 30
            {
                ife player.ftq 122 ife need_autosave 3
                {
                    redefinequote 122 ^02Autosaving...
                    setp[myconnectindex].fta 99
                    set need_autosave 0
                }
                set temp2 display_quote[temp]
                ife temp2 0
                {
                    setarray display_quote[temp] player[].ftq
                    set temp2 temp
                    add temp2 30
                    setarray display_quote[temp2] 99
                    add temp2 30
                    setarray display_quote[temp2] 1
                    setp[].fta 0
                    setp[].ftq 0
                    set temp 30
                    set temp6 1
                }
                else ife temp2 player[].ftq
                {
                    set temp5 0
                    ifge player[].ftq 39 ifle player[].ftq 69
                        set temp5 1
                    ifge player[].ftq 130 ifle player[].ftq 192
                        set temp5 1
                    ifge player[].ftq 328 ifle player[].ftq 338
                        set temp5 1
                    ife player[].ftq 11
                        set temp5 1
                    ife player[].ftq 34
                        set temp5 1

                    ife temp5 1
                    {
                        setarray display_quote[temp] player[].ftq
                        set temp2 temp
                        add temp2 30
                        ifn player[].ftq 11
                            setarray display_quote[temp2] 99
                        else
                            setarray display_quote[temp2] 90

                        add temp2 30
                        set temp3 display_quote[temp2]
                        ifn player[].ftq 11
                            add temp3 1
                        setarray display_quote[temp2] temp3
                        setp[].fta 0
                        setp[].ftq 0
                        set temp 30
                        set temp6 1
                    }
                }
            }
            ifn temp6 1
            {

                setarray display_quote[0] 0
                set temp4 0
                for temp4 range 90
                {
                    set temp3 temp4
                    sub temp3 1
                    clamp temp3 0 90
                    set temp2 display_quote[temp4]
                    setarray display_quote[temp3] temp2
                }
                set temp 29
                setarray display_quote[temp] player[].ftq
                set temp2 temp
                add temp2 30
                setarray display_quote[temp2] 99
                setp[].fta 0
                setp[].ftq 0
            }
        }
        setp[].fta 0
        setp[].ftq 0
    }
endevent

var dialog_padding

appendevent EVENT_DISPLAYREST
    ifp palive ife p_eol 0
    {
        ifn fade_amount 0
        {
            set hudx_alpha 32
            sub hudx_alpha fade_amount
            shiftl hudx_alpha 3
            clamp hudx_alpha 0 255
            state black_background_alpha
        }
    }
    ifp palive
    ife p_eol 0
    {
        state ResetTile
        state ResetText
        set hudx_x 10
        set hudx_y 6
        ifg userdef[].screen_size 0
        {
            ifn dialog_padding 0
                add hudx_y 84
            else ife VOLUME EP_HORDE
                add hudx_y 84
        }
        set hudx_scale 34816
        set hudx_tilenum STARTALPHANUM
        set hudx_orientation 272
        for temp range 30
        ifn display_quote[temp] 0
        {
            set temp2 temp
            add temp2 30
            ifg display_quote[temp2] 10
            {
                ifg display_quote[temp2] 92
                {
                    set hudx_alpha display_quote[temp2]
                    sub hudx_alpha 92
                    shiftl hudx_alpha 5
                }
                else
                {
                    set hudx_alpha 18
                    sub hudx_alpha display_quote[temp2]
                    shiftl hudx_alpha 5
                }
                clamp hudx_alpha 0 255

                set hudx_quote display_quote[temp]
                set temp3 temp
                add temp3 60
                ifg display_quote[temp3] 1
                {
                    qstrcpy 256 display_quote[temp]
                    redefinequote 257 ^00 x%ld
                    qsprintf 257 257 display_quote[temp3]
                    qstrcat 256 257
                    set hudx_quote 256
                }

                state DrawText640x480Screen

                add hudx_y 14

            }
        }
    }
    ifn save_icon 0 ifn userdef.fta_on 0
    {
        state ResetTile
        set hudx_x HUD_DISK_X
        set hudx_y HUD_DISK_Y
        set hudx_scale HUD_DISK_Z

        set temp 6800
        set temp2 save_icon
        mod temp2 14
        add temp temp2
        ifand temp 3
            set hudx_shade 0
        else
            set hudx_shade 10

        set hudx_tilenum 5495
        set hudx_orientation 512
        state DrawTile640x480Screen
    }
endevent

appendevent EVENT_SAVEGAME
    set save_icon 15
endevent

appendevent EVENT_WORLD
    ifg save_icon 0
        sub save_icon 1
    set temp 0
    ifn dialog_display 0
        set dialog_padding 15
    else ifg dialog_padding 0
            sub dialog_padding 1
    for temp range 30
    {
        set temp2 display_quote[temp]
        ifn temp2 0
        {
            set temp3 temp
            add temp3 30
            set temp2 display_quote[temp3]
            ifg temp2 0
            {
                sub temp2 1
                setarray display_quote[temp3] temp2
            }
            else
            {
                setarray display_quote[temp] 0
                set temp4 temp
                add temp4 1
                ifl temp4 30
                {
                    set temp5 90
                    sub temp5 temp4
                    for temp6 range temp5 // 90
                    {
                        set temp3 temp4
                        sub temp3 1
                        set temp2 display_quote[temp4]
                        setarray display_quote[temp3] temp2
                        add temp4 1
                    }
                }
            }
        }
        // add temp 1
    }
endevent

var hub_health_trans
precache 5445 5559 1
precache 5880 6055 1
precache 6100 6143 1
precache 6656 6900 1
precache 6903 6996 1
precache 7000 7377 1
precache 7680 7884 1
precache 8320 8567 1
precache 8570 9004 1
precache 9139 9918 1
precache 11796 12842 1
var donotplay
appendevent EVENT_SOUND
    ife donotplay 1
    {
        set RETURN -1
        set donotplay 0
    }
endevent

var force_um
appendevent EVENT_PRELEVEL
    for temp range NUMWALLS
    {
        ifl wall[temp].extra 0
        {
            ifl wall[temp].extra -128
            {
                set temp3 wall[temp].extra
                abs temp3
                setw[temp].blend temp3
            }
            else
            {
                ifl wall[temp].extra -1 ifg wall[temp].extra -33
                {
                    set temp3 wall[temp].extra
                    abs temp3
                    setw[temp].blend temp3
                }
            }
        }
        ife wall[temp].picnum A_DO_NOT_RENDER
            setwall[temp].picnum T_BLANK
        ife wall[temp].overpicnum A_DO_NOT_RENDER
            setwall[temp].overpicnum T_BLANK
    }
endevent

appendevent EVENT_PRELEVEL
    setpv[myconnectindex].p_dontdie 0
    setpv[myconnectindex].p_whitefade 0
    set num_flag32 0
    set se_game_num 0
    set p_end_game_time WHITEFADE_TIME
    set se_displayrooms_num 0
    set eol_type 1
    set eol_relay 0
    set current_part 0
    set early_use 0
    set debug_hubsection -1
    setpv[myconnectindex].p_ladder_last -1
    for temp allsprites
    {
        ifg sprite[temp].statnum 0
            setav[temp].prop_noprop sprite[temp].statnum

        ife sprite[temp].picnum A_TAINTED_SECTOR
        {
            geta[temp].sectnum temp2
            setarray tainted[temp2] 1
            seta[temp].cstat 32768
            ifg sprite[temp].xvel 0
            {
                setav[temp].se_xvel sprite[temp].xvel
                seta[temp].xvel 0
            }
            ifand actorvar[temp].se_xvel 1
                setarray sect_activator[temp2] 1
        }
        else ife sprite[temp].picnum SECTOREFFECTOR
        {
            switch sprite[temp].lotag // important SEs for DISPLAYROOMS
                case 26
                case 31
                case 32
                    setarray se_displayrooms[se_displayrooms_num] temp
                    add se_displayrooms_num 1
                    break
            endswitch
            switch sprite[temp].lotag // important SEs that we use in EVENT_GAME
                case 64
                case 66
                case 67
                case 68
                case 69
                case 70
                case 71
                case 72
                case 73
                case 74
                case 75
                case 76
                case 77
                case 78
                case 79
                case 80
                case 100
                case 101
                case 102
                case 200
                case 201
                case 420
                    setarray se_game[se_game_num] temp
                    add se_game_num 1
                    break
            endswitch
        }
        else ife sprite[temp].picnum A_DO_NOT_RENDER
        {
            set temp2 sprite[temp].cstat
            or temp2 32768
            setactor[temp].cstat temp2
        }
        else ife sprite[temp].statnum STAT_TRIGGER_FALLER
        {
            ifn sprite[temp].lotag 0
            {
                setav[temp].counter 0
                setav[temp].se_lotag sprite[temp].lotag
                seta[temp].lotag 0
            }
            ifn sprite[temp].hitag 0
            {
                setav[temp].se_hitag sprite[temp].hitag
                seta[temp].hitag 0
            }
            seta[temp].httimetosleep 300
            changespritestat temp STAT_TRIGGER_FALLER
        }
    }
endevent

appendevent EVENT_ENTERLEVEL
    for temp allsprites
    {
        ife sprite[temp].pal 77 // ALL SHADOW SPRITES SHOULD BE SPRITENOPAL
        {
            setu[].vm_sprite temp
            geta[temp].htflags temp2
            or temp2 temp2
            spriteflags 64
        }
        ifl actorvar[temp].tp_owner 0 // THIS TAKES .OWNER SET TO -1024 AND CONVERTS IT INTO SPRITENOPAL
        {
            setu[].vm_sprite temp
            set temp2 tp_owner
            abs temp2
            ifand temp2 1024
            {
                ifn sprite[temp].picnum A_PARTICLE_SPAWNER
                {
                    geta[temp].htflags temp3
                    or temp3 temp3
                    spriteflags 64
                    xor temp2 1024
                    ife temp2 0
                        set temp2 0
                    else
                        inv temp2
                    set tp_owner temp2
                }
            }
        }
    }
endevent

appendevent EVENT_SPAWN
    ife sprite.statnum STAT_TRIGGER_FALLER
    {
        ifn sprite.lotag 0
        {
            set se_lotag sprite.lotag
            seta .lotag 0
            setav[temp].counter 0
        }
        ifn sprite.hitag 0
        {
            set se_hitag sprite.hitag
            seta .hitag 0
        }
        sleeptime 300
        changespritestat THISACTOR STAT_TRIGGER_FALLER
    }
endevent
appendevent EVENT_LOADACTOR
    ifl sprite[].owner 0
        geta[].owner tp_owner
endevent

defstate do_zone_unlocks
    set temp4 0
    switch userdef.level_number
        case EP_MAIN_ZONE_1_START
        case EP_MAIN_ZONE_2_START
        case EP_MAIN_ZONE_3_START
        case EP_MAIN_ZONE_4_START
        case EP_MAIN_ZONE_5_START
        case EP_MAIN_ZONE_6_START
        case EP_MAIN_ZONE_7_START
            switch userdef.level_number
                case EP_MAIN_ZONE_1_START
                    set temp4 1
                    break
                case EP_MAIN_ZONE_2_START
                    set temp4 2
                    break
                case EP_MAIN_ZONE_3_START
                    set temp4 3
                    break
                case EP_MAIN_ZONE_4_START
                    set temp4 4
                    break
                case EP_MAIN_ZONE_5_START
                    set temp4 5
                    break
                case EP_MAIN_ZONE_6_START
                    set temp4 6
                    break
                case EP_MAIN_ZONE_7_START
                    set temp4 7
                    break
            endswitch
            redefinequote 115 gamestate.bin
            readarrayfromfile gamestate 115
            set temp5 gamestate[2]
            ifl temp5 temp4
            {
                setarray gamestate[2] temp4
                writearraytofile gamestate 115
            }
            break
    endswitch
ends

onevent EVENT_ENTERLEVEL
    set cam_id -1
    set cam_id_source -1
    set cam_force_seen 0
    set cam_bypass 0
    set bitchfit 1
    set force_um 0
    set fryall 0
    set se_ifspawn_once 0
    getu[].user_map force_um

    for temp range 4096
        setarray gtfo[temp] 0
    resizearray preloadactivations 0
    resizearray preloadactivations 65536
    resizearray activateshit 0
    resizearray activateshit 65536
    set num_fields 0
    loadmapstate
    setpv[myconnectindex].p_idle_timer 0
    setpv[myconnectindex].p_secrets_show 0
    setpv[myconnectindex].p_card_holdtime 0
    set p_entertime 0
    set temp 0
    set temp2 walls_x[0]
    getu[].screen_size last_ssize
    for temp range 256
    {
        set temp3 walls_x[temp]
        add temp2 temp3
    }
    ife temp2 0
    {
        set temp 0
        for temp range NUMWALLS
        {
            setarray walls_x[temp] wall[temp].x
            setarray walls_y[temp] wall[temp].y
            ife wall[temp].overpicnum T_FORCEFIELD
            {
                setarray walls_field[num_fields] temp
                add num_fields 1
            }
        }
    }

    for temp range NUMSECTORS
    {
        ife sector[temp].floorpicnum A_DO_NOT_RENDER
        {
            sets[temp].floorpicnum T_BLANK
            setarray tainted[temp] 1
        }
        ife sector[temp].ceilingpicnum A_DO_NOT_RENDER
        {
            sets[temp].ceilingpicnum T_BLANK
            setarray tainted[temp] 1
        }
        setarray e_gtfo[temp] 0
        gets[temp].lotag temp2
        ifg temp2 2
            setarray tainted[temp] 1
        else ifl temp2 0
            setarray tainted[temp] 1
    }
    for temp sprofstat STAT_ACTIVATOR
    {
        ife sprite[temp].picnum ACTIVATOR
            setarray sect_activator[sprite[temp].sectnum] 1
    }
    set temp sectpal[8192]
    ifn temp 1
    {
        setarray sectpal[8192] 1
        for temp range NUMSECTORS
        {
            setarray sectpal[temp] sector[temp].floorpal
            set temp3 temp
            add temp3 NUMSECTORS
            setarray sectpal[temp3] sector[temp].ceilingpal
        }
        for temp range NUMWALLS
        {
            setarray wallpal[temp] wall[temp].pal
        }
    }
    ifn load_black 0
    {
        set temp2 myconnectindex
        set fade_amount 63
        setp[temp2].kickback_pic 0
        setp[temp2].weapon_pos -9
        set weapon1_realclip 0
        set weapon2_realclip 0
    }
    ifn p_nextlevel -1
    {
        set temp2 myconnectindex
        set level_text 1

        ifn p_access_saved 0
            setp[temp2].got_access p_access_saved

        ifn p_actors_killed_last 0
            setp[temp2].actors_killed p_actors_killed_last
        ifn p_secrets_transition 0
            setp[temp2].secret_rooms p_secrets_transition
        setp[temp2].posxv 0
        setp[temp2].posyv 0
        setp[temp2].poszv 0

        setp[temp2].pyoff 0
        setp[temp2].opyoff 0

        setp[temp2].ang p_nextlevel_ang
        setp[temp2].oang p_nextlevel_ang
        setp[temp2].horiz p_nextlevel_horiz
        setp[temp2].ohoriz p_nextlevel_horiz
        setp[temp2].look_ang p_nextlevel_look_ang
        setp[temp2].return_to_center p_nextlevel_rtc
        setp[temp2].kickback_pic 0 // hacks so the gun doesn't reload at map start
        setp[temp2].weapon_pos 0

        // make sure the weapon is lowered if you should be on a ladder
        ife p_nextlevel_ladder 1
            setp[temp2].weapon_pos 19

        setp[temp2].knuckle_incs 0

        set level_text 0

        for temp sprofstat STAT_EFFECTOR
        {
            getav[temp].se_lotag temp2
            switch temp2
                case 65
                    getav[temp].se_hitag temp2
                    ife temp2 p_nextlevel_tag // ifn p_nextlevel -1
                    {

                        set temp2 myconnectindex
                        setp[temp2].cursectnum sprite[temp].sectnum

                        set temp3 sprite[temp].sectnum
                        getp[temp2].i temp4
                        seta[temp4].sectnum sprite[temp].sectnum
                        setp[temp2].truecz sector[temp3].ceilingz
                        setp[temp2].truefz sector[temp3].floorz

                        geta[temp].x temp3
                        add temp3 p_nextlevel_xoff
                        ife p_nextlevel_ladder 1
                        {
                            cos temp4 p_nextlevel_ang
                            div temp4 228
                            add temp3 temp4
                        }
                        setp[temp2].posx temp3

                        geta[temp].y temp3
                        add temp3 p_nextlevel_yoff
                        ife p_nextlevel_ladder 1
                        {
                            sin temp4 p_nextlevel_ang
                            div temp4 228
                            add temp3 temp4
                        }
                        setp[temp2].posy temp3

                        geta[temp].z temp3
                        add temp3 p_nextlevel_zoff
                        setp[temp2].posz temp3

                        setp[temp2].oposx player[temp2].posx
                        setp[temp2].oposy player[temp2].posy
                        setp[temp2].oposz player[temp2].posz

                        setp[temp2].poszv p_nextlevel_zvel
                        getp[temp2].posx p_save_x
                        getp[temp2].posy p_save_y
                        getp[temp2].posz p_save_z
                        getp[temp2].ang p_save_ang
                        getp[temp2].horiz p_save_horiz
                        getp[temp2].cursectnum p_save_sectnum
                    }
                    break
                default
                    break
            endswitch
        }
    }
    else
    {
        set temp 0
        for temp range 90
        {
            setarray display_quote[temp] 0
        }
    }
    set p_access_saved 0

    state do_zone_unlocks
    savemapstate
    readgamevar skip_enter_autosave
    ife skip_enter_autosave 0
        ifn VOLUME EP_HORDE
        {
        // ifn userdef[].autosave 0 // can't skip these
            ife skip_autosave 0
                set need_autosave 1
        }
    set hub_health_trans 1
    set skip_autosave 0

endevent


// THIS HACK IS DUMB!
// We copy the above code so that for an extra few frames we
// can force the player to the correct position!
// This prevents a few ms visual glitch.
state player_hub_start_pos
    ifn p_nextlevel -1
    {

        set temp2 myconnectindex
        add p_nl_counter 1

        set level_text 1

        setp[temp2].posxv 0
        setp[temp2].posyv 0
        setp[temp2].poszv 0

        setp[temp2].pyoff 0
        setp[temp2].opyoff 0

        setp[temp2].ang p_nextlevel_ang
        setp[temp2].oang p_nextlevel_ang
        setp[temp2].horiz p_nextlevel_horiz
        setp[temp2].ohoriz p_nextlevel_horiz
        setp[temp2].look_ang p_nextlevel_look_ang
        setp[temp2].return_to_center p_nextlevel_rtc
        setp[temp2].kickback_pic 0 // hacks so the gun doesn't reload at map start
        setp[temp2].weapon_pos 0

        // make sure the weapon is lowered if you should be on a ladder
        ife p_nextlevel_ladder 1
            setp[temp2].weapon_pos 19
        setp[temp2].knuckle_incs 0
        set level_text 0
        setu[].clipping 0
        for temp sprofstat STAT_EFFECTOR
        {
            getav[temp].se_lotag temp2
            switch temp2
                case 65
                    getav[temp].se_hitag temp2
                    ife temp2 p_nextlevel_tag // ifn p_nextlevel -1
                    {

                        set temp2 myconnectindex
                        setp[temp2].cursectnum sprite[temp].sectnum

                        set temp3 sprite[temp].sectnum
                        getp[temp2].i temp4
                        seta[temp4].sectnum sprite[temp].sectnum
                        setp[temp2].truecz sector[temp3].ceilingz
                        setp[temp2].truefz sector[temp3].floorz

                        geta[temp].x temp3
                        add temp3 p_nextlevel_xoff
                        ife p_nextlevel_ladder 1
                        {
                            cos temp4 p_nextlevel_ang
                            div temp4 48
                            add temp3 temp4
                        }
                        setp[temp2].posx temp3

                        geta[temp].y temp3
                        add temp3 p_nextlevel_yoff
                        ife p_nextlevel_ladder 1
                        {
                            sin temp4 p_nextlevel_ang
                            div temp4 48
                            add temp3 temp4
                        }
                        setp[temp2].posy temp3

                        geta[temp].z temp3
                        add temp3 p_nextlevel_zoff
                        setp[temp2].posz temp3

                        setp[temp2].oposx player[temp2].posx
                        setp[temp2].oposy player[temp2].posy
                        setp[temp2].oposz player[temp2].posz
                        setp[temp2].poszv p_nextlevel_zvel
                        ifg p_nl_counter 1
                        {
                            set p_nextlevel -1
                            set p_nextepisode -1
                            set p_nextlevel_tag -1
                            setp[temp2].movement_lock 0
                            set p_nl_counter 0
                        }
                    }
                    break
                default
                    break
            endswitch
        }
        ifn save_noclip -1
            setu[].clipping save_noclip
    }
    else
        set save_noclip -1
ends

// Loading

appendevent EVENT_GETLOADTILE
    // This prevents the loading screen to draw anything
    // and the game view remains as the background
    // however it also means everything is drawn in permanent state! 
    set RETURN -1

    set p_eol 0
    ife load_black 1
        state black_background

    ifn userdef.fta_on 0
    {
        state ResetTile
        set hudx_x HUD_DISK_X
        set hudx_y HUD_DISK_Y
        set hudx_scale HUD_DISK_Z

        set temp 6800
        add temp load_tile
        ifand temp 3
            set hudx_shade 0
        else
            set hudx_shade 10

        set hudx_tilenum 5495
        set hudx_orientation 512
        state DrawTile640x480Screen
    }

    add load_tile 1
    ifg load_tile 14
        set load_tile 0
endevent

//

var last_ceilz 0 2
var last_florz 0 2
var last_sdir 0 2
var cur_sdir 0 2
var cur_mode 0 2
var last_lotag 0 2
var ds_sectnum 0 2
var ds_extra 0 2
var ds_ang 0 2
var ds_ang_goal 0 2
var ds_oflorz 0 2
var ds_oceilz 0 2

var ds_snd_hitag 0 2
var ds_snd_lotag 0 2
var ds_snd 0 2
var ds_snd_fnd 0 2

var ds_uhohlocked

eventloadactor DS
    gets[].lotag se_lotag // sector lotag isn't always preserved for some reason
    geta[].hitag se_hitag
    seta[].hitag 0
    ifl se_hitag 1
        set se_hitag 0
    geta[].sectnum ds_sectnum
    ifl se_lotag 0
        add se_lotag 32768
enda

defstate erase_mfx
    ife ds_snd 0
    {
        for temp spritesofsector sprite[].sectnum
        {
            ife sprite[temp].picnum MUSICANDSFX
            {
                set temp2 0
                ifge sprite[temp].hitag 1000
                    set temp2 1
                else ifge sprite[temp].lotag 1000
                    set temp2 1
                ife temp2 1
                {
                    geta[temp].hitag ds_snd_hitag
                    geta[temp].lotag ds_snd_lotag
                    set ds_snd_fnd 1
                    seta[temp].xrepeat 0
                    seta[temp].yrepeat 0
                    changespritestat temp STAT_ACTOR
                }
            }
        }
        set ds_snd 1
    }
ends
defstate ds_litetrigger
    ifg se_hitag 0
    {
        operateactivators se_hitag THISACTOR
        operatemasterswitches se_hitag
        operaterespawns se_hitag
        setarray preloadactivations[se_hitag] 1
    }
ends

defstate ds_lockstate
    set ds_uhohlocked 0
    ifand last_lotag 16384
    {
        ifand sector[].lotag 16384
            nullop
        else
            set ds_uhohlocked 1
    }
    else ifand sector[].lotag 16384
    {
        ifand last_lotag 16384
            nullop
        else
            set ds_uhohlocked 1
    }
ends
useractor notenemy DS
    sleeptime 300
    cstat 0
    cstat 32768
    switch se_lotag
        case 20
            state erase_mfx
            ife counter 0
            {
                gets[].lotag last_lotag
                seta[].extra sector[].extra // save .extra/gpspeed
                sets[].extra 1 // set speed to lowest possible value so it won't interfere with our stuff
                add counter 1
            }

            ifn last_lotag sector[].lotag
            {
                state ds_lockstate
                ife ds_uhohlocked 0
                {
                    state ds_litetrigger
                    set ds_snd_fnd 2
                    ifn ds_snd_lotag 0
                        soundvar ds_snd_lotag
                }
                gets[].lotag last_lotag
            }
            gets[].ceilingz temp2
            ifn temp2 last_ceilz
            {
                nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1 // floorz for some reason
                gets[RETURN].ceilingz temp3 // next sector ceilingz, do a diff
                sub temp3 temp2
                abs temp3   // difference between ceiling and ceiling

                set temp4 sector[].floorz // current floorz, do a diff
                sub temp4 temp2
                abs temp4 // difference between ceiling and floor

                gets[].ceilingz temp2
                set temp sprite[].extra
                ifl temp3 4096 // apply the diffs with a bit of slop so we can kill movement
                {
                    sub temp3 4097
                    div temp3 512
                    ife temp3 0
                        set temp3 1
                    div temp temp3
                    abs temp
                    shiftl temp 2
                    div temp 3
                    set temp5 sprite[].extra
                    shiftr temp5 2
                    mul temp5 3
                    ifg temp temp5
                        set temp temp5
                }
                ifl temp4 4096
                {
                    sub temp4 4097
                    div temp4 512
                    ife temp4 0
                        set temp4 1
                    div temp temp4
                    abs temp
                    shiftl temp 2
                    div temp 3
                    set temp5 sprite[].extra
                    shiftr temp5 2
                    mul temp5 3
                    ifg temp temp5
                        set temp temp5
                }
                ifspritepal 9
                {
                    ife temp sprite.extra
                        set counter2 1
                    ife counter2 1
                        set temp sprite.extra
                }
                shiftl temp 2 // internally the game seems to move things at about twice the rate of .extra
                set temp5 0 // so we can skip moving if not necessary

                ifl temp3 -7 // hard set if matching ceiling
                {
                    nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1
                    sets[].ceilingz sector[RETURN].ceilingz
                    set temp5 1
                }
                else ifl temp4 -7 // hard set if matching floor
                {
                    sets[].ceilingz sector[].floorz
                    set temp5 1
                }

                ife temp5 0 // move it!
                {
                    ifg last_ceilz temp2
                        add temp2 -temp
                    else
                        sub temp2 -temp
                    sets[].ceilingz temp2
                }
                else
                {
                    ifg ds_snd_fnd 1
                    {
                        set ds_snd_fnd 1
                        ifn ds_snd_hitag 0
                            soundvar ds_snd_hitag
                    }
                }
            }
            else
                set counter2 0
            gets[].ceilingz last_ceilz
            break
       case 21
            state erase_mfx
            ife counter 0
            {
                gets[].lotag last_lotag
                seta[].extra sector[].extra // save .extra/gpspeed
                sets[].extra 1 // set speed to lowest possible value so it won't interfere with our stuff
                add counter 1
            }
            ifn last_lotag sector[].lotag
            {
                state ds_lockstate
                ife ds_uhohlocked 0
                {
                    state ds_litetrigger
                    set ds_snd_fnd 2
                    ifn ds_snd_lotag 0
                        soundvar ds_snd_lotag
                }
                gets[].lotag last_lotag
            }
            gets[].floorz temp2
            ifn temp2 last_florz
            {
                nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1 // floorz for some reason
                gets[RETURN].floorz temp3 // next sector ceilingz, do a diff
                sub temp3 temp2
                abs temp3   // difference between ceiling and ceiling

                set temp4 sector[].ceilingz // current floorz, do a diff
                sub temp4 temp2
                abs temp4 // difference between ceiling and floor

                gets[].floorz temp2
                set temp sprite[].extra
                ifl temp3 4096 // apply the diffs with a bit of slop so we can kill movement
                {

                    sub temp3 4097
                    div temp3 512
                    ife temp3 0
                        set temp3 1
                    div temp temp3
                    abs temp
                    shiftl temp 2
                    div temp 3
                    set temp5 sprite[].extra
                    shiftr temp5 2
                    mul temp5 3
                    ifg temp temp5
                        set temp temp5
                }
                ifl temp4 4096
                {
                    sub temp4 4097
                    div temp4 512
                    ife temp4 0
                        set temp4 1
                    div temp temp4
                    abs temp
                    shiftl temp 2
                    div temp 3
                    set temp5 sprite[].extra
                    shiftr temp5 2
                    mul temp5 3
                    ifg temp temp5
                        set temp temp5
                }
                shiftl temp 2 // internally the game seems to move things at about twice the rate of .extra
                set temp5 0 // so we can skip moving if not necessary

                ifl temp3 -7 // hard set if matching floor
                {
                    nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1
                    sets[].floorz sector[RETURN].floorz
                    set temp5 1
                }
                else ifl temp4 -7 // hard set if matching ceiling
                {
                    sets[].floorz sector[].ceilingz
                    set temp5 1
                }

                ife temp5 0 // move it!
                {
                    ifg last_florz temp2
                        add temp2 -temp
                    else
                        sub temp2 -temp
                    ifl temp2 sector[].ceilingz
                        set temp2 sector[].ceilingz
                    sets[].floorz temp2
                }
                else
                {
                    ifg ds_snd_fnd 1
                    {
                        set ds_snd_fnd 1
                        ifn ds_snd_hitag 0
                            soundvar ds_snd_hitag
                    }
                }
            }
            gets[].floorz last_florz
            break
       case 22
            state erase_mfx
            ife counter 0
            {
                gets[].lotag last_lotag
                seta[].extra sector[].extra // save .extra/gpspeed
                sets[].extra 1 // set speed to lowest possible value so it won't interfere with our stuff
                add counter 1



                nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1 // floorz for some reason

                gets[].ceilingz temp2
                gets[RETURN].ceilingz temp3 // next sector ceilingz, do a diff
                sub temp3 temp2
                abs temp3

                gets[].floorz temp2
                gets[RETURN].floorz temp4 // next sector floorz, do a diff
                sub temp4 temp2
                abs temp4

                set temp5 0
                ifn temp4 temp3
                {
                    set temp5 temp4
                    sub temp5 temp3
                    shiftr temp5 1
                    gets[].floorz temp2
                    add temp2 temp5
                    sets[].floorz temp2

                    set temp5 temp3
                    sub temp5 temp4
                    shiftr temp5 1
                    gets[].ceilingz temp2
                    sub temp2 temp5
                    sets[].ceilingz temp2
                    set temp5 0
                }
                else
                {
                        ife temp3 0
                        {
                            ife temp4 0
                            {
                                gets[].floorz temp
                                gets[].ceilingz temp2
                                sub temp2 temp
                                shiftr temp2 1
                                add temp2 sector[].floorz
                                set ds_oflorz temp2
                                set ds_oceilz temp2
                                set temp5 1
                            }
                        }
                }
                ife temp5 0
                {
                    gets[].floorz ds_oflorz
                    gets[].ceilingz ds_oceilz
                }
            }
            ifn last_lotag sector[].lotag
            {
                state ds_lockstate
                ife ds_uhohlocked 0
                {
                    state ds_litetrigger
                    set ds_snd_fnd 2
                    ifn ds_snd_lotag 0
                        soundvar ds_snd_lotag
                }
                gets[].lotag last_lotag
            }
            gets[].ceilingz temp2
            ifn temp2 last_ceilz
            {
                nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1 // floorz for some reason
                gets[RETURN].ceilingz temp3 // next sector ceilingz, do a diff
                sub temp3 temp2
                abs temp3   // difference between ceiling and ceiling

                set temp4 ds_oceilz // current floorz, do a diff
                sub temp4 temp2
                abs temp4 // difference between ceiling and floor

                gets[].ceilingz temp2
                set temp sprite[].extra
                ifl temp3 4096 // apply the diffs with a bit of slop so we can kill movement
                {

                    sub temp3 4097
                    div temp3 512
                    ife temp3 0
                        set temp3 1
                    div temp temp3
                    abs temp
                    shiftl temp 2
                    div temp 3
                    set temp5 sprite[].extra
                    shiftr temp5 2
                    mul temp5 3
                    ifg temp temp5
                        set temp temp5
                }
                ifl temp4 4096
                {
                    sub temp4 4097
                    div temp4 512
                    ife temp4 0
                        set temp4 1
                    div temp temp4
                    abs temp
                    shiftl temp 2
                    div temp 3
                    set temp5 sprite[].extra
                    shiftr temp5 2
                    mul temp5 3
                    ifg temp temp5
                        set temp temp5
                }
                shiftl temp 2 // internally the game seems to move things at about twice the rate of .extra
                set temp5 0 // so we can skip moving if not necessary

                ifl temp3 -7 // hard set if matching ceiling
                {
                    nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1
                    sets[].ceilingz sector[RETURN].ceilingz
                    set temp5 1
                }
                else ifl temp4 -7 // hard set if matching ceiling
                {
                    sets[].ceilingz ds_oceilz
                    set temp5 1
                }

                ife temp5 0 // move it!
                {
                    ifg last_ceilz temp2
                        add temp2 -temp
                    else
                        sub temp2 -temp
                    ifg temp2 sector[].floorz
                        set temp2 sector[].floorz
                    sets[].ceilingz temp2
                }
                else
                {
                    ifg ds_snd_fnd 1
                    {
                        set ds_snd_fnd 1
                        ifn ds_snd_hitag 0
                            soundvar ds_snd_hitag
                    }
                }
            }
            gets[].ceilingz last_ceilz

            gets[].floorz temp2
            ifn temp2 last_florz
            {
                nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1 // floorz for some reason
                gets[RETURN].floorz temp3 // next sector floorz, do a diff
                sub temp3 temp2
                abs temp3   // difference between floor and floor

                set temp4 ds_oflorz // current ceilingz, do a diff
                sub temp4 temp2
                abs temp4 // difference between ceiling and floor
                /* redefinequote 11 diff-floor: %ld | diff-ceil: %ld
                qsprintf 11 11 temp3 temp4
                quote 11 */
                gets[].floorz temp2
                set temp sprite[].extra
                ifl temp3 4096 // apply the diffs with a bit of slop so we can kill movement
                {

                    sub temp3 4097
                    div temp3 512
                    ife temp3 0
                        set temp3 1
                    div temp temp3
                    abs temp
                    shiftl temp 2
                    div temp 3
                    set temp5 sprite[].extra
                    shiftr temp5 2
                    mul temp5 3
                    ifg temp temp5
                        set temp temp5
                }
                ifl temp4 4096
                {
                    sub temp4 4097
                    div temp4 512
                    ife temp4 0
                        set temp4 1
                    div temp temp4
                    abs temp
                    shiftl temp 2
                    div temp 3
                    set temp5 sprite[].extra
                    shiftr temp5 2
                    mul temp5 3
                    ifg temp temp5
                        set temp temp5
                }
                shiftl temp 2 // internally the game seems to move things at about twice the rate of .extra
                set temp5 0 // so we can skip moving if not necessary
               /* redefinequote 11 %ld %ld
                qsprintf 11 11 temp3 temp4
                quote 11 */
                ifl temp3 -7 // hard set if matching floor
                {
                    nextsectorneighborz sprite[].sectnum sector[].floorz -1 -1
                    sets[].floorz sector[RETURN].floorz
                    set temp5 1
                }
                else ifl temp4 -7 // hard set if matching ceiling
                {
                    sets[].floorz ds_oflorz
                    set temp5 1
                }

                ife temp5 0 // move it!
                {
                    ifg last_florz temp2
                        add temp2 -temp
                    else
                        sub temp2 -temp
                    ifl temp2 sector[].ceilingz
                        set temp2 sector[].ceilingz
                    sets[].floorz temp2
                }
                else
                {
                    ifg ds_snd_fnd 1
                    {
                        set ds_snd_fnd 1
                        ifn ds_snd_hitag 0
                            soundvar ds_snd_hitag
                    }
                }
            }
            gets[].floorz last_florz
            break
        default
           break
    endswitch
enda
var last_xl 0 2
var activator_found 0 2
var st_found_ds 0 2
var ds_extra_orig 0 2
var orig_x 0 2
var orig_y 0 2
var orig_z 0 2
var n_x 0 2
var n_y 0 2
var skip1 0 2
var skip2 0 2
var sound_lotag 0 2

appendevent EVENT_MOVEEFFECTORS
    switch sprite[].lotag
        case 10
        case -10
            set temp 0
            ife sector[].lotag 25
                set temp 1
            else ife sector[].lotag -32743
                set temp 1
            ife temp 1 // this is a really bad workaround for some hardcoded bug with sliding doors
            {
                geta[].lotag temp
                ifg temp 0
                    inv temp
                seta[].lotag temp
            }
            ifspritepal 9 // enforce clearing during animation
                ife sector.lotag 0
                    set counter 0
            ife sprite[].ang 512
            {
                ife sector[].lotag 25
                {
                    add counter 1
                    ife counter sprite[].hitag
                    {
                        set counter 0
                        operatesectors sprite[].sectnum THISACTOR
                    }
                }
                else ife sector[].lotag -32743
                    set counter 0
            }
            else
            {
                ife sector[].lotag -32743
                {
                    add counter 1
                    ife counter sprite[].hitag
                    {
                        set counter 0
                        operatesectors sprite[].sectnum THISACTOR
                    }
                }
                else ife sector[].lotag 25
                    set counter 0
            }
            break
    endswitch
    switch sprite[].lotag
        case 11
            ife counter 0
            {
                set counter 1
                gets[].extra temp
               seta[].yvel temp
                ife last_sdir 0
                    geta[].yvel last_sdir
            }
            ife st_do_once 0
            {
                set st_do_once 1
                gets[].lotag sound_lotag
                state erase_mfx
                for temp spritesofsector sprite[].sectnum
                {
                    ife sprite[temp].picnum DS
                    {
                        getav[temp].se_hitag temp2
                        ifg temp2 0
                            set se_hitag temp2
                    }
                }
            }
            ife counter 2
                set counter 0
            ifn sound_lotag sector[].lotag
            {
                set ds_uhohlocked 0
                ifand sound_lotag 16384
                {
                    ifand sector[].lotag 16384
                        nullop
                    else
                        set ds_uhohlocked 1
                }
                else ifand sector[].lotag 16384
                {
                    ifand sound_lotag 16384
                        nullop
                    else
                        set ds_uhohlocked 1
                }
                ife ds_uhohlocked 0
                {
                    state ds_litetrigger
                    set ds_snd_fnd 2
                    ifn ds_snd_lotag 0
                        soundvar ds_snd_lotag
                }
                gets[].lotag sound_lotag
            }
          //  redefinequote 11 %ld %ld
          //     qsprintf 11 11 sprite[].yvel sprite[].extra
          //     quote 11
            /* redefinequote 11 %ld
               qsprintf 11 11 sprite[].htg_t 2
               quote 11
            set temp sprite[].htg_t 2
            and temp 511 */
            /* redefinequote 11 %ld %ld
            qsprintf 11 11 RETURN sector[].extra

            quote 11 */

            gets[].extra temp
            set temp2 sprite[].htg_t 2
            ife sprite[].ang 512
            {
                ifl temp2 0
                    set temp2 0
                else ifg temp2 512
                    set temp2 512
            }
            else
            {
                ifl temp2 -512
                    set temp2 -512
                else ifg temp2 0
                    set temp2 0
            }
            seta[].htg_t 2 temp2

            abs temp2
            ife temp2 256
                set temp2 257
            sub temp2 256
            abs temp2

            ifg temp2 160
            {
                set temp3 temp2
                div temp3 70
                div temp temp3
            }


            abs temp
            gets[].extra temp3
            shiftr temp3 3
            ifl temp temp3
                set temp temp3
            ifg temp sector[].extra
                set temp sector[].extra
            ifg temp last_sdir
                set temp last_sdir
            shiftr temp 1
            seta[].yvel temp
            break
        case 15
            ife counter 0
            {
                set counter 1
                ife st_do_once 0
                {
                    geta[].yvel ds_extra_orig
                    shiftr ds_extra_orig 3

                    gets[].extra temp
                    add temp 24
                    sets[].extra temp
                    seta[].yvel temp
                    set st_do_once 1
                    geta[].x orig_x
                    geta[].y orig_y
                    for temp spritesofsector sprite[].sectnum
                    {
                        ife sprite[temp].picnum DS
                        {
                            set st_found_ds 1
                            getav[temp].se_hitag temp2
                            ifg temp2 0
                                set se_hitag temp2
                        }
                        else ife sprite[temp].picnum ACTIVATORLOCKED
                            sets[].lotag 16409
                    }
                }
                ife st_found_ds 1
                    state erase_mfx
                gets[].extra temp
                geta[].yvel ds_extra
                    shiftr ds_extra 3

                set temp ds_extra
                shiftr temp 2
                seta[].xvel temp
                geta[].xvel cur_sdir
                shiftl cur_sdir 1
                set last_sdir 0

                set cur_mode 0
                ife last_lotag 0 ifn sector[].lotag 16409 ifn sector[].lotag -16359
                    sets[].lotag 25
                else ifn sector[].lotag 16409 ifn sector[].lotag -16359
                    sets[].lotag last_lotag
            }
            ifn sound_lotag last_lotag
            {
                set ds_uhohlocked 0
                ifand sound_lotag 16384
                {
                    ifand sector[].lotag 16384
                        nullop
                    else
                        set ds_uhohlocked 1
                }
                else ifand sector[].lotag 16384
                {
                    ifand sound_lotag 16384
                        nullop
                    else
                        set ds_uhohlocked 1
                }
                ife ds_uhohlocked 0
                {
                    state ds_litetrigger
                    set ds_snd_fnd 2
                    ifn ds_snd_lotag 0
                        soundvar ds_snd_lotag
                }
                set sound_lotag last_lotag
            }
            ifg counter 1
                add counter 1
            ifg counter ds_extra
            {
                set counter 0
                set temp ds_extra
                shiftr temp 2

                ifg cur_sdir temp
                    shiftr cur_sdir 1
                seta[].xvel cur_sdir
                shiftl cur_sdir 1

            }
            ife last_lotag 25 ife last_sdir 0 ifn sector[].lotag 0
            {
                seta[].x orig_x
                seta[].y orig_y
                for temp wallsofsector sprite[].sectnum
                {
                    set temp2 walls_x[temp]
                    setw[temp].x temp2
                    set temp2 walls_y[temp]
                    setw[temp].y temp2
                    set temp2 walls_x[temp]
                    set temp3 walls_y[temp]
                    dragpoint temp temp2 temp3
                }
                ife ds_snd_fnd 2
                {
                    set ds_snd_fnd 1
                    ifn ds_snd_hitag 0
                        soundvar ds_snd_hitag
                }
            }
            else ife last_lotag 25 ife cur_mode 1 ifl last_sdir 12
            {
                geta[].ang temp6
                mod temp6 512
                ifn temp6 0
                {
                    for temp wallsofsector sprite[].sectnum
                    {
                        set temp2 walls_x[temp]
                        setw[temp].x temp2
                        set temp2 walls_y[temp]
                        setw[temp].y temp2
                        set temp2 walls_x[temp]
                        set temp3 walls_y[temp]
                        dragpoint temp temp2 temp3
                    }
                    seta[].x orig_x
                    seta[].y orig_y
                }
            }
            ife last_lotag -32743 ife last_sdir 0
            {
                ife n_x 0 ife n_y 0
                {
                    geta[].x n_x
                    geta[].y n_y
                }
                else
                {
                    seta[].x n_x
                    seta[].y n_y
                }
                ife ds_snd_fnd 2
                {
                    set ds_snd_fnd 1
                    ifn ds_snd_hitag 0
                        soundvar ds_snd_hitag
                }
            }
            ife sector[].lotag 16384
            {
                ife last_lotag -32743
                    sets[].lotag -16359
                else ife last_lotag 25
                    sets[].lotag 16409
            }
              /*   ife se_hitag 555
                 {
                    redefinequote 11 %ld %ld %ld %ld %ld %ld %ld %ld
                    qsprintf 11 11 sprite[].yvel sprite[].xvel sector[].extra last_sdir sector[].lotag last_lotag sprite[].hitag ds_extra
                    quote 11
                } */
            break
    endswitch
    switch sprite[].lotag
        case 24
            // palfrom 30 0 30 0
            ife counter 0
            {
                set counter 1
                gets[].floorxpanning se_xvel
                gets[].floorypanning se_yvel
            }
            ife sprite[].ang 1024
            {
                gets[].floorxpanning temp
                sub temp 16
                sets[].floorxpanning temp
                // sets[].floorxpanning se_xvel
                sets[].floorypanning se_yvel
            }
            break
        case 25
            ife activateshit[se_hitag] 1
            {
                geta .htg_t 4 temp
                xor temp 1
                seta .htg_t 4 temp
            }
            else ifspritepal 9
            {
                geta .htg_t 4 temp
                xor temp 1
                seta .htg_t 4 temp
                spritepal 0
            }
            /* redefinequote 11 %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld
            qsprintf 11 11 sprite[].yvel sprite[].xvel sector[].extra sector[].lotag sprite[].hitag sprite.htg_t 0 sprite.htg_t 1 sprite.htg_t 2 sprite.htg_t 3 sprite.htg_t 4
            quote 11 */
            break
        case 26
            for temp6 sprofstat STAT_MASTER_MOVER
            {
                ife sprite[temp6].sectnum sprite[].sectnum
                {
                    ife actorvar[temp6].st_do_once 0
                    {
                        setav[temp6].orig_x sprite[temp6].x
                        setav[temp6].orig_y sprite[temp6].y
                        setav[temp6].orig_z sprite[temp6].z
                        setav[temp6].st_do_once 1
                    }
                    else
                    {
                        seta[temp6].x actorvar[temp6].orig_x
                        seta[temp6].y actorvar[temp6].orig_y
                        seta[temp6].z actorvar[temp6].orig_z
                    }

                }
            }
            break
        case 30
            ife st_do_once 0
            {
                set st_do_once 1
                ifn sprite.xvel 0
                {
                    set se_xvel sprite.xvel
                    seta .xvel 0
                    geta .x cam_xoff
                    geta .y cam_yoff
                    for temp sprofstat STAT_LOCATOR
                    {
                        ife sprite[temp].hitag sprite.hitag
                        {
                            ife sprite[temp].lotag 1
                            {
                                geta[temp].x pivot_xoff
                                geta[temp].y pivot_yoff
                            }
                        }
                    }
                }
            }
          /*  redefinequote 11 h:%ld z:%ld e:%ld yv:%ld xv:%ld zv:%ld se:%ld sl:%ld sh:%ld o:%ld sd:%ld c:%ld c2:%ld
            qsprintf 11 11  sprite[].hitag sprite[].z sprite[].extra sprite[].yvel sprite[].xvel sprite[].zvel sector[].extra sector[].lotag sector[].hitag sprite.owner sprite.shade counter counter2
            quote 11 */
            ifg se_xvel 0
            {
              /*  ifn sprite.xvel 0
                {
                    ife counter 0
                        set counter 1
                }
                ife counter 1
                {
                    add counter2 1
                    set temp counter2
                    shiftl temp 4
                    ifge temp se_xvel
                    {
                        set counter2 se_xvel
                        shiftr counter2 4
                    }
                    geta .x temp
                    sub temp pivot_xoff
                    mul temp temp
                    
                    geta .y temp2
                    sub temp2 pivot_yoff
                    mul temp2 temp2
                    
                    add temp temp2
                    sqrt temp temp
                    abs temp
                    
                    set temp6 se_xvel
                    shiftl temp6 4
                    ifle temp temp6
                    {
                        set counter -1
                        inv counter2
                    }
                }
                ife counter -1
                {
                    ifl counter2 0
                        add counter2 1
                    
                     set temp6 se_xvel
                    shiftl temp6 3
                    geta .x temp
                    sub temp cam_xoff
                    mul temp temp
                    
                    geta .y temp2
                    sub temp2 pivot_yoff
                    mul temp2 temp2
                    
                    add temp temp2
                    sqrt temp temp
                    abs temp
                    ifle temp temp6
                    {
                        set counter -1
                        inv counter2
                    }
                }
                set temp counter2
                abs temp
                shiftl temp 4
                seta .xvel 0 */
                
                set temp2 se_xvel
                clamp temp2 1 256
                shiftl temp2 3
                findnearsprite LOCATORS temp2 temp
                ifn temp -1
                {
                    // palfrom 30 0 0 30
                    ifn sprite[temp].lotag sprite.owner
                    {
                        ife counter2 1
                        {
                            set counter2 -1
                            ifg sprite.xvel 256
                            {
                                seta .xvel 256
                                set counter 16
                                set counter2 -2
                            }
                        }
                    }

                }
                ifn sprite.xvel 0 ife counter2 0
                {
                    set counter2 1
                    set counter 0
                }
                ife counter2 1
                {
                    add counter 1
                    set temp counter
                    shiftl temp 4
                    ifg temp se_xvel
                    {
                        set counter se_xvel
                        shiftr counter 4
                    }
                    clamp temp 0 se_xvel
                    seta .xvel temp
                }
                ifl counter2 0
                {
                    ife counter2 -2
                    {
                        geta .xvel temp
                        ife temp 0
                            set counter2 0
                    }
                    else
                    {
                        sub counter 1
                        clamp counter 0 65536
                        set temp counter
                        shiftl temp 4
                        seta .xvel temp
                        ife temp 0
                            set counter2 0
                   } 
                }
             /*   geta .xvel temp
                clamp temp 0 se_xvel
                seta .xvel temp */
            }
           /* ifn st_do_once sprite.owner
            {
                set counter 0
                set st_do_once sprite.owner
            }
            else */
           /* {
                set temp2 se_xvel
                shiftl temp2 3
                clamp temp2 1024 65536
                findnearsprite LOCATORS temp2 temp
                ifn temp -1
                {
                    // palfrom 30 0 0 30
                    ifn sprite[temp].lotag sprite.owner
                    {
                        add counter 1
                    }
                    else
                        set counter 0
                }
                /* for temp spritesofsector sprite.sectnum
                    ife sprite[temp].picnum LOCATORS
                        palfrom 30 0 0 30 */
            // }
            /* ifg sprite.xvel 0
            {
               // ifg se_xvel 256
                {
                    ifge sprite.xvel 256
                    {
                        geta .xvel temp
                        set temp2 se_xvel
                        div temp2 16
                        ifle temp 256 ifg se_xvel 256
                            set temp2 16
                        ife counter 0
                            add temp 16
                        else
                        {
                            set temp se_xvel
                            set temp2 temp
                            shiftr temp2 4
                            shiftr temp2 1
                            mul temp2 counter
                            sub temp temp2
                            clamp temp 0 65536
                            ife temp 0
                                set counter 0
                        }
                        seta .xvel temp
                    }
                }
                
                ifge sprite.xvel se_xvel
                    seta .xvel se_xvel
            } */

            break
        case 31
            /* redefinequote 11 h:%ld z:%ld e:%ld yv:%ld xv:%ld zv:%ld se:%ld sl:%ld sh:%ld %ld %ld %ld %ld %ld %ld
            qsprintf 11 11  sprite[].hitag sprite[].z sprite[].extra sprite[].yvel sprite[].xvel sprite[].zvel sector[].extra sector[].lotag sector[].hitag sprite.htg_t 1 sprite.htg_t 3 sprite.htg_t 4 sprite.htg_t 5
            quote 11 */
            ife st_do_once 0
            {
                gets[].floorz se_zvel
                geta[].yvel se_yvel
                set st_do_once 1
                set se_extra 0 // our own "internal" flags
                for temp spritesofsector sprite[].sectnum
                {
                    ife sprite[temp].picnum DS
                    {
                        set st_do_once 2
                        set temp2 se_yvel
                        shiftr temp2 4
                        seta[].yvel temp2
                    }
                    ifspritepal 9
                    {
                        switch sprite[temp].statnum
                            case STAT_DEFAULT
                            case STAT_GRADIENT
                            case STAT_FALLER
                            case STAT_TRIGGER_FALLER
                            case STAT_NEONSIGN
                                setav[temp].se_31_savez sprite[temp].z
                                setav[temp].se_31_saved 1
                                break
                        endswitch
                    }
                }
                ifn sprite[].hitag 0
                {
                    geta[].hitag se_hitag
                    seta[].hitag 0
                    set htzvel -1
                    for temp6 sprofstat STAT_EFFECTOR
                    {
                        ife sprite[temp6].lotag 127
                        {
                            ifl sprite[temp6].extra 0
                                seta[temp6].extra 0
                            ife se_hitag sprite[temp6].hitag
                            {
                                ife sprite[temp6].pal 9 // second level
                                {
                                    set htzvel temp6
                                    or se_extra 2
                                }
                                else
                                {
                                    ifand sprite[temp6].extra 4
                                        nullop
                                    else
                                        seta[].z sprite[temp6].z
                                    ifand sprite[temp6].extra 1
                                    {
                                        or se_extra 1
                                        gets[].floorz se_xvel
                                        sub se_xvel sector[].ceilingz
                                    }
                                }
                            }
                        }
                    }
                }
            }
            ifand se_extra 1
            {
                gets[].floorz temp
                sub temp se_xvel
                sets[].ceilingz temp
            }
            ifand se_extra 2
            {
                ife sprite.htg_t 0 0
                    ife sprite.htg_t 2 1
                    {
                        ifn htzvel -1
                        {
                            seta .htg_t 1 sprite[htzvel].z
                            set se_zvel sprite[htzvel].z
                            seta .z sector.floorz
                            seta .htg_t 0 0
                            seta .htg_t 2 0
                        }
                        xor se_extra 2
                    }
            }
            ifspritepal 9
            {
                for temp spritesofsector sprite[].sectnum
                {
                    ife actorvar[temp].se_31_saved 1
                    {
                        seta[temp].z actorvar[temp].se_31_savez
                    }
                }
            }
            ife st_do_once 2
            {
                ifn sector[].floorz se_zvel
                {
                    ifn sector[].floorz sprite[].z
                    {
                        set temp6 0
                        set temp2 se_yvel
                        shiftl temp2 3
                        gets[].floorz temp
                        sub temp se_zvel
                        abs temp
                        ifl temp temp2
                            set temp6 1
                        else
                        {
                            set temp2 se_yvel
                            shiftl temp2 2
                            gets[].floorz temp
                            sub temp sprite[].z
                            abs temp
                            ifl temp temp2
                                set temp6 1
                        }

                        ifand sprite.xvel 4
                        {
                            ifn temp6 0
                            {
                                seta[].yvel se_yvel
                                set temp6 0
                            }
                            else
                            {
                                geta .xvel temp4
                                xor temp4 4
                                seta .xvel temp4
                            }
                        }
                        ife temp6 1
                        {
                            set temp4 se_yvel
                            shiftr temp4 4
                            set temp3 se_yvel
                            shiftr temp3 1
                            shiftr temp2 1
                            ifl temp temp2
                            {
                                shiftr temp3 1
                                shiftr temp2 1
                                ifl temp temp2
                                {
                                    shiftr temp3 1
                                    shiftr temp2 2
                                    ifg temp3 temp4
                                    {
                                        ifl temp temp2
                                        {
                                            shiftr temp3 1
                                            shiftr temp2 1
                                            ifl temp temp2
                                            {
                                                shiftr temp3 1
                                                shiftr temp2 1
                                                ifl temp temp2
                                                    shiftr temp3 1
                                            }
                                        }
                                    }
                                }
                            }
                            ifl temp3 16
                                set temp3 16
                            else ifl temp3 temp4
                                set temp3 temp4
                            seta[].yvel temp3
                        }
                        else
                            seta[].yvel se_yvel
                        sets[].extra sprite[].yvel
                    }
                }
                else
                {
                    set temp2 se_yvel
                    shiftr temp2 4
                    seta[].yvel temp2
                }
            }
            ifand sprite.xvel 1
            {
                ife activateshit[se_hitag] 1
                {
                    ife sprite.htg_t 0 0
                    {
                        geta .htg_t 0 temp
                        xor temp 1
                        seta .htg_t 0 temp
                        geta .htg_t 2 temp
                        xor temp 1
                        seta .htg_t 2 temp
                    }
                }
            }
            ifand sprite.xvel 2
            {
                ifn sector.floorz se_zvel
                {
                    set temp se_zvel
                    sub temp sector.floorz
                    abs temp
                    ifg temp se_yvel
                        sets .floorz se_zvel
                }
            }
            
        /*    redefinequote 11 h:%ld z:%ld e:%ld yv:%ld xv:%ld zv:%ld se:%ld sl:%ld sh:%ld
            qsprintf 11 11  sprite[].htg_t 0 sprite[].htg_t 2 sprite[].htg_t 3 sprite[].yvel sprite[].xvel sprite[].zvel sector[].extra sector[].lotag sector[].hitag
            quote 11 */
            break
    endswitch
    switch sprite[].lotag
        case 32
            /* redefinequote 11 h:%ld z:%ld e:%ld yv:%ld xv:%ld zv:%ld se:%ld sl:%ld sh:%ld
            qsprintf 11 11  sprite[].hitag sprite[].z sprite[].extra sprite[].yvel sprite[].xvel sprite[].zvel sector[].extra sector[].lotag sector[].hitag
            quote 11 */
            ife st_do_once 0
            {
                gets[].ceilingz se_zvel
                geta[].yvel se_yvel
                set se_extra 0
                set st_do_once 1
                for temp spritesofsector sprite[].sectnum
                {
                    ife sprite[temp].picnum DS
                    {
                        set st_do_once 2
                        set temp2 se_yvel
                        shiftr temp2 4
                        seta[].yvel temp2
                    }
                }
                ifn sprite[].hitag 0
                {
                    geta[].hitag se_hitag
                    seta[].hitag 0
                    for temp6 sprofstat STAT_EFFECTOR
                    {
                        ife sprite[temp6].lotag 127
                        {
                            ifl sprite[temp6].extra 0
                                seta[temp6].extra 0
                            ife se_hitag sprite[temp6].hitag
                            {
                                ifand sprite[temp6].extra 2
                                    nullop
                                else
                                    seta[].z sprite[temp6].z
                                ifand sprite[temp6].extra 1
                                {
                                    set se_extra 1
                                    gets[].ceilingz se_xvel
                                    sub se_xvel sector[].floorz
                                }
                            }
                        }
                    }
                    gets[].ceilingz se_zvel
                }
            }
            ife se_extra 1
            {
                gets[].ceilingz temp
                sub temp se_xvel
                sets[].floorz temp
            }
            ife st_do_once 2
            {
                ifn sector[].ceilingz se_zvel
                {
                    ifn sector[].ceilingz sprite[].z
                    {
                        set temp6 0
                        set temp2 se_yvel
                        shiftl temp2 3
                        gets[].ceilingz temp
                        sub temp se_zvel
                        abs temp
                        ifl temp temp2
                            set temp6 1
                        else
                        {
                            set temp2 se_yvel
                            shiftl temp2 2
                            gets[].ceilingz temp
                            sub temp sprite[].z
                            abs temp
                            ifl temp temp2
                                set temp6 1
                        }

                        ife temp6 1
                        {
                            set temp4 se_yvel
                            shiftr temp4 4
                            set temp3 se_yvel
                            shiftr temp3 1
                            shiftr temp2 1
                            ifl temp temp2
                            {
                                shiftr temp3 1
                                shiftr temp2 1
                                ifl temp temp2
                                {
                                    shiftr temp3 1
                                    shiftr temp2 2
                                    ifg temp3 temp4
                                    {
                                        ifl temp temp2
                                        {
                                            shiftr temp3 1
                                            shiftr temp2 1
                                            ifl temp temp2
                                            {
                                                shiftr temp3 1
                                                shiftr temp2 1
                                                ifl temp temp2
                                                    shiftr temp3 1
                                            }
                                        }
                                    }
                                }
                            }
                            ifl temp3 16
                                set temp3 16
                            else ifl temp3 temp4
                                set temp3 temp4
                            seta[].yvel temp3
                        }
                        else
                            seta[].yvel se_yvel
                        sets[].extra sprite[].yvel
                    }
                }
                else
                {
                    set temp2 se_yvel
                    shiftr temp2 4
                    seta[].yvel temp2
                }
            }
            break
        case 17
            ifspritepal 9 // override default behavior
            {
                ife st_do_once 0
                {
                    set temp2 0
                    ifge sprite.shade 17
                    {
                        for temp sprofstat STAT_EFFECTOR
                        {
                            ifn temp THISACTOR
                            {
                                ife sprite[temp].picnum SECTOREFFECTOR
                                {
                                    ife sprite[temp].lotag 17
                                    {
                                        ife sprite[temp].hitag sprite.hitag
                                        {
                                            geta[temp].sectnum temp3
                                            setav[temp].pivot_zoff sector[temp3].floorz
                                            setav[temp].cam_zoff sector[temp3].ceilingz
                                            ifg sprite[temp].z sprite.z // label which is on top
                                            {
                                                set temp2 1
                                                setav[temp].st_do_once 1
                                            }
                                            else
                                                setav[temp].st_do_once -1
                                        }
                                    }
                                }
                            }
                        }
                        gets .floorz pivot_zoff
                        gets .ceilingz cam_zoff
                        ife temp2 1
                            set st_do_once 1
                        else
                            set st_do_once -1
                    }
                }
                ife activateshit[sprite.hitag] 1 // check for activation
                    ife counter 0
                        set counter 1
                
                
                ifn counter 0
                {
                    ife counter2 0 // set elevator state
                    {
                        set temp st_do_once
                        seta .htg_t 0 temp
                        set counter3 sprite.htg_t 0
                        set counter2 -1
                    }
                    else ife counter2 1
                    {
                        set temp st_do_once
                        inv temp
                        seta .htg_t 0 temp
                        set counter3 sprite.htg_t 0
                        set counter2 -2
                    }
                    ifl counter2 0
                    {
                        ife sprite.htg_t 0 0
                        {
                            add counter2 2
                            set counter 0
                            set counter3 sprite.htg_t 0
                        }
                        else
                        {
                            ifn sprite.htg_t 0 counter3 // if the player tries to interfere midway they can't
                                seta .htg_t 0 counter3
                            
                            ife sprite.htg_t 0 1 // reset position if things fuck up
                            {
                                ife st_do_once 1
                                {
                                    ifl sector.floorz pivot_zoff
                                    {
                                        sets .floorz pivot_zoff
                                        sets .ceilingz cam_zoff
                                        add counter2 2
                                        set counter 0
                                        seta .htg_t 0 0
                                        set counter3 sprite.htg_t 0
                                    }
                                }
                                else ifg sector.floorz pivot_zoff
                                {
                                    sets .floorz pivot_zoff
                                    sets .ceilingz cam_zoff
                                    add counter2 2
                                    set counter 0
                                    seta .htg_t 0 0
                                    set counter3 sprite.htg_t 0
                                }
                            }
                        }
                    }
                    seta .htg_t 1 sprite.htg_t 0 // these should match
                }
                else
                {
                    seta .htg_t 0 0
                    seta .htg_t 1 0
                }
                ifn db_temp 0 // stupid overrides for hard coded sounds
                {
                    ife db_temp 71 // start sound
                    {
                        ifg sprite.xvel 0
                            soundvar sprite.xvel
                    }
                    else ife db_temp 73 // stop sound
                    {
                        ifg sprite.zvel 0
                            soundvar sprite.zvel
                    }
                    set db_temp 0
                }
            }
            break
        case 24
        case 34
            ifspritepal 9
            {
                spritepal 0
                seta .htg_t 4 1
            }
            ife activateshit[sprite.hitag] 1
            {
                geta .htg_t 4 temp
                xor temp 1
                seta .htg_t 4 temp
            }
            break
    endswitch
endevent


appendevent EVENT_MOVESECTOR
    switch sprite[].lotag
        case 11
            set temp RETURN
            and temp 255
            /* redefinequote 11 %ld %ld
            qsprintf 11 11 RETURN sector[].extra
            quote 11 */

            ife temp 0
            {
                

                ife ds_snd_fnd 2
                {
                    set ds_snd_fnd 1
                    soundvar ds_snd_hitag
                }
            }
            set counter 2
            geta[].yvel temp
            ife sprite[].ang 512
            {
                ifl RETURN 0
                    set RETURN 0
                else ifg RETURN 512
                    set RETURN 512
            }
            else
            {
                ifl RETURN -512
                    set RETURN -512
                else ifg RETURN 0
                    set RETURN 0
            }
            set temp2 RETURN

            abs temp2
            ife temp2 256
                set temp2 257
            sub temp2 256
            abs temp2

            ifg temp2 160
            {
                set temp3 temp2
                div temp3 80
                div temp temp3
            }

            abs temp
            gets[].extra temp3
            shiftr temp3 3
            ifl temp temp3
                set temp temp3
            ifg temp sector[].extra
                set temp sector[].extra
            ifg temp last_sdir
                set temp last_sdir

            seta[].yvel temp
            /* redefinequote 11 %ld %ld %ld %ld
               qsprintf 11 11 sprite[].yvel RETURN sector[].extra temp2
               quote 11 */
            break
        case 15
            ife st_found_ds 0 // used to be optional now default
            {
                ifn sector[].lotag last_lotag ifn sector[].lotag 16409 ifn sector[].lotag -16359
                {
                    set last_sdir 1
                    set last_xl 1
                    ifn sector[].lotag 16409 ifn sector[].lotag -16359
                        gets[].lotag last_lotag
                }
                ifg last_sdir 0
                {
                    add last_sdir 1

                    seta[].xvel last_xl
                    shiftl last_xl 1
                    ifg last_xl 16
                        set last_xl 16

                }
                ife last_lotag 0
                {
                    set last_lotag -32768
                }
            }
            else // additional smoothing using DS sprite
            {
                ife cur_mode 0
                    add last_sdir 1
                else
                    sub last_sdir 1
                ifg last_sdir cur_sdir
                  set cur_mode 1

                abs last_sdir
                set temp last_sdir
                ife se_ang 256 // correction for some weird internal math
                {
                    ifn last_lotag 25
                    {
                        ifg last_sdir 16
                            sub temp 1
                        else
                            sub temp 2
                    }
                    else
                    {
                        ifg last_sdir 16
                            add temp 1
                        else
                            add temp 2
                    }
                }
                abs temp
                seta[].xvel temp
                ife counter 1
                    add counter 1



                ifn sector[].lotag 0 ifn sector[].lotag 16409 ifn sector[].lotag -16359
                {
                    // palfrom 30 0 30 0
                    gets[].lotag last_lotag
                    sets[].lotag 0
                }
              /*  redefinequote 11 %ld %ld %ld %ld %ld %ld
                qsprintf 11 11 sprite[].yvel sprite[].xvel sector[].extra last_sdir sector[].lotag last_lotag
                quote 11 */
            }
            break
        case 26
            ifl sprite[].extra 0
                seta[].extra 0
            ife st_do_once 0
            {
                ifand sprite[].extra 4
                    add st_do_once 2
                ifand sprite[].extra 8
                    add st_do_once 4
                ife st_do_once 0
                    set st_do_once 1
                set orig_z sector[].ceilingz
                gets[].extra temp
                shiftr temp 3
                sets[].extra temp
            }
            else
            {
                set temp 32
                div temp st_do_once
                seta[].xvel temp
                set temp 256
                div temp st_do_once
                seta[].zvel temp
            }

            ifand sprite[].extra 1
            {
                geta[].zvel temp
                ifg temp 0
                    inv temp
                seta[].zvel temp
            }
            ifg counter 0
            {
                geta[].z temp
                set temp2 counter
                mul temp2 sprite[].zvel
                ifand sprite[].extra 2
                   set temp2 0
                add temp temp2
                sets[].floorz temp
                ifand sector[].ceilingstat 2
                {
                    set temp orig_z
                    set temp2 counter
                    mul temp2 sprite[].zvel
                    add temp temp2
                    sets[].ceilingz temp
                }
            }
            add counter 1
            geta[].zvel temp2
            set temp 2048
            abs temp2
            div temp temp2
           // set temp 8
            ifg counter temp
                set counter 0
            geta[].xvel temp
            sets[].extra temp
            sets[].lotag 3072 // easy trigger for other things
      /*      redefinequote 11 %ld %ld %ld %ld %ld | %ld %ld %ld | %ld
            qsprintf 11 11 sprite[].xvel sprite[].yvel sprite[].zvel sprite[].extra sprite[].hitag sector[].lotag sector[].hitag sector[].extra sprite[player[].i].xvel
            quote 11  */
            break
        case 30
/*            set se_xvel 128
            set temp2 se_xvel
            shiftl temp2 3
            findnearsprite LOCATORS temp2 temp
            ifn temp -1
            {
                // palfrom 30 0 0 30
                ifn sprite[temp].lotag sprite.owner
                {
                    ife counter2 1
                        set counter2 -1
                }

            }
            ifn sprite.xvel 0 ife counter2 0
            {
                set counter2 1
                set counter 0
            }
            ife counter2 1
            {
                add counter 1
                set temp counter
                shiftl temp 4
                clamp temp 0 se_xvel
                seta .xvel temp
            }
            else ife counter2 -1
            {
                sub counter 1
                set temp counter
                shiftl temp 4
                
                seta .xvel temp
                ife temp 0
                    set counter2 0
            } */
           /* geta .xvel temp
            clamp temp 0 se_xvel
            seta .xvel temp */
           /* ifg se_xvel 0
                seta .xvel 0 */
            break
    endswitch
endevent

appendevent EVENT_DISPLAYROOMS
    getu[].vm_sprite temp7
    for temp5 range se_displayrooms_num // 6 sprofstat STAT_EFFECTOR
    {
        set temp6 se_displayrooms[temp5]
        setu[].vm_sprite temp6
        ife sprite[].picnum SECTOREFFECTOR
        {
            ife sprite[].lotag 26
            {
                ife counter 0
                {
                    for temp wallsofsector sprite[].sectnum
                    {
                        set temp2 walls_x[temp]
                        setw[temp].x temp2
                        set temp2 walls_y[temp]
                        setw[temp].y temp2
                        set temp2 walls_x[temp]
                        set temp3 walls_y[temp]
                        dragpoint temp temp2 temp3
                    }
                    geta[].sectnum temp
                    sets[temp].floorz sprite[].z
                    ifn st_do_once 0
                        sets[temp].ceilingz orig_z
                    set counter 1
                }
                else
                {
                    set move_v sprite[].xvel
                    mul move_v counter
                    state move_actor
                    for temp wallsofsector sprite[].sectnum
                    {
                        set temp2 walls_x[temp]
                        add temp2 move_xv
                        setw[temp].x temp2
                        set temp3 walls_y[temp]
                        add temp3 move_yv
                        setw[temp].y temp3
                        dragpoint temp temp2 temp3
                    }
                }
            }
            else ife sprite[].lotag 31
            {
                ife se_extra 1
                {
                    gets[].floorz temp
                    sub temp se_xvel
                    sets[].ceilingz temp
                }
            }
            else ife sprite[].lotag 32
            {
                ife se_extra 1
                {
                    gets[].ceilingz temp
                    sub temp se_xvel
                    sets[].floorz temp
                }
            }
        }
    }
    setu[].vm_sprite temp7
    ife profiler 1
    {
        getticks ticks2
        sub ticks2 ticks1
        add ticks_average ticks2
        ifg ticks_average 2147483647
            set ticks_average 0
        ife ticks_num 0
            set ticks_num 1
        add ticks_average5 ticks2
        ifg ticks_average5 2147483647
            set ticks_average5 0
        ife ticks_num5 0
            set ticks_num5 1

        ifn ticks_average 0
        {
            set temp ticks_average
            mul temp 100
            div temp ticks_num
            set temp2 temp
            div temp2 100
            ifge temp 100
            {
                set temp3 temp2
                mul temp3 100
                sub temp temp3
            }
        }
        else
        {
            set temp 0
            set temp2 0
        }
        ifn ticks_5sec 0
        {
            set temp3 ticks_5sec
            set temp4 temp3
            div temp4 100
            ifge temp3 100
            {
                set temp5 temp4
                mul temp5 100
                sub temp3 temp5
            }
        }
        else
        {
            set temp3 0
            set temp4 0
        }
        redefinequote 400 current: %ldms  last: ^08%ldms  ^00average: ^09%ld.%ldms ^00last 5sec: ^14%ld.%ldms
        qsprintf 400 400 ticks2 ticks_last temp2 temp temp4 temp3
        set ticks_last ticks2
        add ticks_num 1
        ifg ticks_num 2147483647
            set ticks_num 1
        add ticks_num5 1
        ifg ticks_num5 2147483647
            set ticks_num5 1
    }
endevent


/*
case ST_20_CEILING_DOOR:
REDODOOR:

        if (sptr->lotag&0x8000)
        {
            for (SPRITES_OF_SECT(sn, i))
                if (sprite[i].statnum == STAT_EFFECTOR && SLT==SE_9_DOWN_OPEN_DOOR_LIGHTS)
                {
                    j = SZ;
                    break;
                }

            if (i==-1)
                j = sptr->floorz;
        }
        else
        {
            j = nextsectorneighborz(sn,sptr->ceilingz,-1,-1);

            if (j >= 0) j = sector[j].ceilingz;
            else
            {
                sptr->lotag |= 32768;
                goto REDODOOR;
            }
        }

        sptr->lotag ^= 0x8000;

        SetAnimation(sn,&sptr->ceilingz,j,sptr->extra);
        A_CallSound(sn,ii);

        return;
*/
