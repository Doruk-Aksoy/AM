/*
--------------------------------------------------------------------------------
================================================================================
                          +:                                                   
WWW@*WWWWWWW+  *WWWWWWW*  :=@       @WWWWWWWWW*WWW*  =WWW*WWWWWWWWWW@*WWW+  @WW
WWW@*WWWWWWWWW**WWWWWWWWW=   =*     @WWWWWWWWW*WWW*  =WWW*WWWWWWWWWW@*WWW+  @WW
WWW@*WWW+  WWWW*WWW*  @WWW :WWWWWW+ @WWW*    *+WWW*  =WWW*WWW#=#WWWW#*WWWWW@@WW
WWW@*WWW+  @WWW*WWW*  #WWW @WWWWWWW @WWW#WWWW@+WWW*  =WWW*WWW#WWWWW* *WWWWW@@WW
WWW@*WWW@  @WWW*WWW*  #WWW += =# += @WWW      +WWWW: =WWW*WWW=  @WWW@      *WWW
WWW@ *WWWWWWWWW*WWW*  #WWW   =WW@   @WWW       :WWWWWWWWW*WWW=   WWW@:WWWWWWWW@
@@@@   +@@@@@@@+@@@+  #WWW          @WWW         :WWWWWWW+W@@=   @@@@:@@@@@@#  

###############################################################################
Ion Fury
Code by Jonathan Strander, Fox Martins, Richard Gobeille, and Evan Ramos
All code as written belongs to Voidpoint and the respective authors.
(c) 2019 Voidpoint, LLC
--------------------------------------------------------------------------------
While we encourage you to experiment, modifications are allowed WITHOUT any
warranty or guarantee of support. Editing these files is AT YOUR OWN RISK, and
we encourage you to make backups.
--------------------------------------------------------------------------------

NOTES:
This file contains switches and switch-like objects including proximity sensors
and relay multiswitches among others.
================================================================================
--------------------------------------------------------------------------------
*/
// Switches and other random crap.
// Let's do this! (poorly)

action AC_SWITCH 0 1 1 1 1

action AC_SWITCH_3_F 0 3 1 1 1
action AC_SWITCH_3_B 0 3 1 -1 1

action AC_SWITCH_5_F 0 5 1 1 1
action AC_SWITCH_5_B 0 5 1 -1 1

action AC_SWITCH_6_F 0 6 1 1 1
action AC_SWITCH_6_B 0 6 1 -1 1

action AC_SWITCH_7_F 0 7 1 1 1
action AC_SWITCH_7_B 0 7 1 -1 1

var switch_toggle_delay 0 2
var switch_num_frames 0 2
var switch_break 0 2
var switch_wait 0 2
var switch_cousins -1 2
var switch_source 0 2
var switch_keep_active 0 2

state switch_load
    geta[].hitag se_hitag
    geta[].lotag se_lotag
    geta[].extra se_extra
    geta[].xvel se_xvel
    geta[].yvel se_yvel
    ifl se_xvel 0
        set se_xvel 0
    ifl se_extra 0
        set se_extra 0
    seta[].hitag 0
    seta[].lotag 0
    cstator 256
    ifand sprite[].cstat 512
        cstator 32768
    ifand se_extra 8
    {
        geta[].cstat temp
        xor temp 256
        seta[].cstat temp
    }
    switch sprite[].picnum
        case A_ELEVATOR_DN_SWITCH_OFF
        case A_ELEVATOR_DN_SWITCH_ON
        case A_ELEVATOR_UP_SWITCH_OFF
        case A_ELEVATOR_UP_SWITCH_ON
            or se_extra 1024
            break
    endswitch
    set actor_switch 1
ends

appendevent EVENT_LOADACTOR
    switch sprite[].picnum
        case A_ACCESSCARDSWITCH_SPAWN
        case A_ACCESSCARDSWITCH_OFF
            state switch_load
            cactor A_ACCESSCARDSWITCH_OFF
            break
        case A_ACCESSCARDSWITCH_ON
        case A_ACCESSCARDSWITCH2_ON
        case A_ACCESSCARDSWITCH2_OFF
        case A_LIGHTSWITCH_ON
        case A_LIGHTSWITCH_OFF
        case A_ELEVATOR_DN_SWITCH_OFF
        case A_ELEVATOR_DN_SWITCH_ON
        case A_ELEVATOR_UP_SWITCH_OFF
        case A_ELEVATOR_UP_SWITCH_ON
        case A_DIPSWITCH_OFF
        case A_DIPSWITCH_ON
        case A_ROTARYSWITCH_OFF
        case A_ROTARYSWITCH_ON
        case A_LEVERSWITCH_OFF
        case A_LEVERSWITCH_ON
        case A_ISOLATORSWITCH_OFF
        case A_ISOLATORSWITCH_ON
        case A_BREAKERSWITCH_OFF
        case A_BREAKERSWITCH_ON
        case A_DIPSWITCH2_OFF
        case A_DIPSWITCH2_ON
        case A_PUSHBUTTONSWITCH_OFF
        case A_PUSHBUTTONSWITCH_ON
        case A_ROTARYSWITCH2_OFF
        case A_ROTARYSWITCH2_ON
        case A_LEVERSWITCH2_OFF
        case A_LEVERSWITCH2_ON
        case A_BREAKERSWITCH2_OFF
        case A_BREAKERSWITCH2_ON
        case A_LEVERSWITCH3_OFF
        case A_LEVERSWITCH3_ON
        case A_VALVESWITCH_1
        case A_VALVESWITCH_2
        case A_VALVESWITCH_1_CLOSE
        case A_VALVESWITCH_2_CLOSE
        case A_CORDSWITCH_OFF
        case A_CORDSWITCH_ON
        case T_DARTBOARD_SWITCH
            state switch_load
            break
        case A_LOCKSOUND
            geta[].hitag se_hitag
            geta[].lotag se_lotag
            seta[].hitag 0
            seta[].lotag 0
            geta[].cstat temp
            or temp 512
            or temp 32768
            ifand temp 256
                xor temp 256
            seta[].cstat temp
            set actor_switch 1
            changespritestat THISACTOR STAT_LOCKSOUND
            break
        case A_BATONSWITCH_OFF
        case A_BATONSWITCH_ON
        case A_BATONSWITCH_TIMED
            geta[].hitag se_hitag
            geta[].lotag se_lotag
            geta[].extra se_extra
            clamp se_extra -1 65536
            ifle se_hitag 0
                set se_hitag 150
            clamp se_hitag 30 65536
            seta[].hitag 0
            seta[].lotag 0
            geta[].xvel se_xvel
            geta[].yvel se_yvel
            geta[].zvel se_zvel
            set actor_switch 1
            cstator 257
            break
    endswitch

    switch sprite[].picnum
        case A_LIGHTSWITCH_ON
        case A_LIGHTSWITCH_OFF
        case A_ROTARYSWITCH_OFF
        case A_ROTARYSWITCH_ON
        case A_LEVERSWITCH_OFF
        case A_LEVERSWITCH_ON
        case A_ISOLATORSWITCH_OFF
        case A_ISOLATORSWITCH_ON
        case A_BREAKERSWITCH_OFF
        case A_BREAKERSWITCH_ON
        case A_ROTARYSWITCH2_OFF
        case A_ROTARYSWITCH2_ON
        case A_LEVERSWITCH2_OFF
        case A_LEVERSWITCH2_ON
        case A_BREAKERSWITCH2_OFF
        case A_BREAKERSWITCH2_ON
        case A_LEVERSWITCH3_OFF
        case A_LEVERSWITCH3_ON
        case A_VALVESWITCH_1
        case A_VALVESWITCH_2
        case A_VALVESWITCH_1_CLOSE
        case A_VALVESWITCH_2_CLOSE
        case A_CORDSWITCH_OFF
        case A_CORDSWITCH_ON
            ifand sprite[].cstat 32768
                nullop
            else
            {
                or se_extra 8
                geta[].cstat temp
                ifand temp 256
                {
                    xor temp 256
                    seta[].cstat temp
                }
                ifand temp 2
                    nullop
                else
                    cstator 512 // just to make sure it has some cstat to be detected
            }
            break
    endswitch
    switch sprite[].picnum
        case A_VALVESWITCH_1
        case A_VALVESWITCH_2
        case A_VALVESWITCH_1_CLOSE
        case A_VALVESWITCH_2_CLOSE
            ifand sprite[].cstat 32768
                nullop
            else
            {
                or se_extra 8
                geta[].cstat temp
                ifand temp 256
                {
                    xor temp 256
                    seta[].cstat temp
                }
                ifand temp 2
                    nullop
                else
                    cstator 512 // just to make sure it has some cstat to be detected
            }
            break
    endswitch
    
    switch sprite[].picnum
        case A_CRACKSWITCH_1
        case A_CRACKSWITCH_2
        case A_CRACKSWITCH_3
        case A_CRACKSWITCH_4
        case A_CRACKSWITCH_5
            geta[].hitag se_hitag
            geta[].lotag se_lotag
            seta[].hitag 0
            seta[].lotag 0
            geta[].yvel se_yvel
            seta[].yvel 0
            geta[].cstat temp
            ifand temp 1
                xor temp 1
            or temp 256
            seta[].cstat temp
            set actor_crack 1
            break
    endswitch
endevent

useractor notenemy A_LOCKSOUND
    changespritestat THISACTOR STAT_LOCKSOUND
enda
appendevent EVENT_WORLD
    for temp7 sprofstat STAT_LOCKSOUND
    {
        setu .vm_sprite temp7
        setu .vm_player myconnectindex
        dist temp THISACTOR player[].i
        setu[].vm_distance temp
        ifg se_hitag 0
        {
            ife activateshit[se_hitag] 1
            {
                ifspritepal 9
                    spritepal 0
                else
                    spritepal 9
            }
        }
        ifspritepal 9
            set switch_toggle_delay 1
        ife switch_toggle_delay 1
        {
            ifhitspace
                set actor_switch_usable 0
            else
                set switch_toggle_delay 0
        }
        else
        {
            ifpdistl 1536 ife actor_switch_usable 1 ifhitspace
            {
                ifg se_lotag 0
                    soundvar se_lotag
                else
                    sound S_DOOR_LOCKED
                set switch_toggle_delay 1
            }
        }
        set actor_switch_usable 0
    }
endevent

defstate switch_zap
    set temp tilesizy[sprite.picnum]
    shiftl temp 2
    mul temp sprite.yrepeat
    shiftr temp 1
    inv temp
    add temp sprite.z
    espawn A_GENERIC_PARTICLE
    seta[RETURN].xrepeat 123
    seta[RETURN].z temp
    seta[RETURN].ang sprite.ang
    seta[RETURN].xvel 32
    ssp RETURN 0
    seta[RETURN].xvel 0
    espawn A_GENERIC_PARTICLE
    seta[RETURN].xrepeat 120
    seta[RETURN].z temp
    seta[RETURN].ang sprite.ang
    seta[RETURN].xvel 32
    ssp RETURN 0
    seta[RETURN].xvel 0
    sound S_P_ZAPPED_END
ends

defstate switch_toggle
    strength 0
    sleeptime 300
    ifn se_yvel 0
    {
        set temp se_yvel
        abs temp
        ife activateshit[temp] 1
            inv se_yvel
        geta .cstat temp
        ifg se_yvel 0
        {
            ifand temp 32768
                ifand temp 256
                {
                    or se_extra 8192
                    xor temp 256
                }
            ifand se_extra 1 ife switch_break 0
            {
                xor se_extra 1
                or se_extra 4096
            }
            ifle switch_wait 3
                set switch_wait 3
            ife switch_toggle_delay 0 
            {
                ifpdistl 1536 ife actor_switch_usable 1 ifaction AC_SWITCH ifhitspace
                {
                    ifand se_extra 16
                        nullop
                    else ifand se_extra 512
                        nullop
                    else ifand se_extra 16384
                        nullop
                    else ifand sprite.cstat 32768
                        nullop
                    else
                    {
                        setp .sound_pitch 660
                        sound S_SWITCH_SNAPPY
                        sound S_SWITCH_BUTTON02
                        setp .sound_pitch 0
                        set switch_toggle_delay 1
                    }
                }
            }
        }
        else
        {
            ifand se_extra 4096
            {
                xor se_extra 4096
                or se_extra 1
            }
            ifand temp 32768
                ifand se_extra 8192
                {
                    xor se_extra 8192
                    or temp 256
                }
        }
        seta .cstat temp
    }
    ife switch_toggle_delay 1
    {
        ifand se_extra 1
        {
            ife switch_keep_active 0
                set actor_switch_usable 0
            else
            {
                ifhitspace
                    set actor_switch_usable 0
                else
                    set switch_toggle_delay 0
            }
            ifactioncount 2
                nullop
            else ifactioncount 1
            {
                ifand se_extra 64
                {
                    ifand sprite[].cstat 32768
                        killit
                }
                else
                    state switch_zap
            }
            set switch_break 1
        }
        else ifhitspace
            set actor_switch_usable 0
        else
            set switch_toggle_delay 0
        ifand se_extra 2
        {
            ifactioncount 2
                nullop
            else ifactioncount 1
                state switch_zap
        }
    }
ends

defstate switch_activate
    operateactivators se_lotag THISACTOR
    operatemasterswitches se_lotag
    operaterespawns se_lotag
    setarray preloadactivations[se_lotag] 1
ends

defstate switch_pick_fw_action
    switch switch_num_frames
        case 3
            action AC_SWITCH_3_F
            break
        case 5
            action AC_SWITCH_5_F
            break
        case 6
            action AC_SWITCH_6_F
            break
        case 7
            action AC_SWITCH_7_F
            break
    endswitch
ends

defstate switch_pick_bw_action
    switch switch_num_frames
        case 3
            action AC_SWITCH_3_B
            break
        case 5
            action AC_SWITCH_5_B
            break
        case 6
            action AC_SWITCH_6_B
            break
        case 7
            action AC_SWITCH_7_B
            break
    endswitch
ends

defstate switch_play_sound
    ifand se_extra 32
        nullop
    else
    {
        ife se_hitag 0
        {
            switch sprite[].picnum
                case A_CORDSWITCH_OFF
                case A_CORDSWITCH_ON
                    sound S_STEP_FABRIC_JUMP3
                    break
                default
                    sound S_SWITCH_BUTTON01
                    break
            endswitch
        }
        else
            soundvar se_hitag
    }
ends

defstate switch_forward
    state switch_toggle
    set temp 0
    ifpdistl 1536 ife actor_switch_usable 1 ifaction AC_SWITCH ifhitspace
    {
        ifand se_extra 16
            nullop
        else ifand se_extra 512
            nullop
        else
            set temp 1
    }
    else ifhitweapon
    {
        ifand se_extra 8
            nullop
        else ifand se_extra 16
        {
            ifwasweapon EXPLOSION
            {
                ifand se_extra 256
                {
                    geta[].htowner temp2
                    geta[temp2].picnum temp2
                    ife temp2 A_MECHBOSS_TOP
                    {
                        ifaction AC_SWITCH
                            ife switch_break 0
                                set temp 1
                    }
                }
                else
                    ifaction AC_SWITCH
                        ife switch_break 0
                            set temp 1
            }
        }
        else
        {
            ifwasweapon EXPLOSION
            {
                ifand se_extra 1024
                    nullop
                else ifaction AC_SWITCH ife switch_break 0
                    set temp 1
            }
            else ifaction AC_SWITCH ife switch_break 0
                set temp 1
        }
    }
    else ifn se_lotag 0 ife switch_break 0 ife switch_cousins se_lotag
        set temp 1
    ifg switch_wait 0
    {
        sub switch_wait 1
        set temp 0
        ifand se_extra 2048
        {
            ife switch_wait 0
            {
                ifaction AC_SWITCH
                {
                    state switch_pick_fw_action
                    state switch_play_sound
                    set actor_switch_usable 0
                    break
                }
            }
        }
    }
    
    ife temp 1
    {
        set switch_wait se_xvel
        ifn switch_cousins se_lotag
        {
            state switch_play_sound
            ifn se_lotag 0
            {
                ife switch_keep_active 0
                    state switch_activate
                ifand se_extra 128 ifand se_extra 1
                    set switch_keep_active 1
                ifand se_extra 4
                    nullop
                else
                {
                    for temp sprofstat STAT_ACTOR
                    {
                        ifn temp THISACTOR
                        {
                            getav[temp].actor_switch temp2
                            ife temp2 1
                            {
                                getav[temp].se_lotag temp2
                                ife temp2 se_lotag
                                {
                                    setav[temp].switch_cousins se_lotag
                                }
                            }
                        }
                    }
                }
            }
            set switch_source 1 // for later maybe
            set switch_cousins -1
        }
        else
            set switch_cousins -1
        state switch_pick_fw_action
    }

    ifactioncount 3
    {
        switch sprite[].htg_t 4
        {
            case AC_SWITCH_3_F:
                set switch_toggle_delay 1
                action AC_SWITCH
                geta[].picnum temp
                add temp 2
                seta[].picnum temp
                set temp 1337
                ifand se_extra 2048
                    ife switch_wait 0
                        set switch_wait 1
                break
            case AC_SWITCH_5_F:
                ifactioncount 5
                {
                    set switch_toggle_delay 1
                    action AC_SWITCH
                    geta[].picnum temp
                    add temp 4
                    seta[].picnum temp
                    set temp 1337
                    ifand se_extra 2048
                        ife switch_wait 0
                            set switch_wait 1
                }
                break
            case AC_SWITCH_6_F:
                ifactioncount 6
                {
                    set switch_toggle_delay 1
                    action AC_SWITCH
                    geta[].picnum temp
                    add temp 5
                    seta[].picnum temp
                    set temp 1337
                    ifand se_extra 2048
                        ife switch_wait 0
                            set switch_wait 1
                }
                break
            case AC_SWITCH_7_F:
                ifactioncount 7
                {
                    set switch_toggle_delay 1
                    action AC_SWITCH
                    geta[].picnum temp
                    add temp 6
                    seta[].picnum temp
                    set temp 1337
                    ifand se_extra 2048
                        ife switch_wait 0
                            set switch_wait 1
                }
                break
        }
        endswitch

        ife temp 1337
            break
    }
    set actor_switch_usable 0
ends

defstate switch_backward
    state switch_toggle
    set temp 0
    ifpdistl 1536 ife actor_switch_usable 1 ifaction AC_SWITCH ifhitspace
    {
        ifand se_extra 16
            nullop
        else ifand se_extra 512
            nullop
        else
            set temp 1
    }
    else ifhitweapon
    {
        ifand se_extra 8
            nullop
        else ifand se_extra 16
        {
            ifwasweapon EXPLOSION
            {
                ifand se_extra 256
                {
                    geta[].htowner temp2
                    geta[temp2].picnum temp2
                    ife temp2 A_MECHBOSS_TOP
                    {
                        ifaction AC_SWITCH
                            ife switch_break 0
                                set temp 1
                    }
                }
                else
                    ifaction AC_SWITCH
                        ife switch_break 0
                            set temp 1
            }
        }
        else
        {
            ifwasweapon EXPLOSION
            {
                ifand se_extra 1024
                    nullop
                else ifaction AC_SWITCH ife switch_break 0
                    set temp 1
            }
            else ifaction AC_SWITCH ife switch_break 0
                set temp 1
        }
    }
    else ifn se_lotag 0 ife switch_break 0 ife switch_cousins se_lotag
        set temp 1
    ifg switch_wait 0
    {
        sub switch_wait 1
        set temp 0
        ifand se_extra 2048
        {
            ife switch_wait 0
            {
                ifaction AC_SWITCH
                {
                    state switch_pick_bw_action
                    state switch_play_sound
                    set actor_switch_usable 0
                    break
                }
            }
        }
    }
    ife temp 1
    {
        set switch_wait se_xvel
        ifn switch_cousins se_lotag
        {
            state switch_play_sound

            ifn se_lotag 0
            {
                ife switch_keep_active 0
                    state switch_activate
                ifand se_extra 128 ifand se_extra 1
                    set switch_keep_active 1
                ifand se_extra 4
                    nullop
                else
                {
                    for temp sprofstat STAT_ACTOR
                    {
                        ifn temp THISACTOR
                        {
                            getav[temp].actor_switch temp2
                            ife temp2 1
                            {
                                getav[temp].se_lotag temp2
                                ife temp2 se_lotag
                                {
                                    setav[temp].switch_cousins se_lotag
                                }
                            }
                        }
                    }
                }
            }
            set switch_source 1 // for later maybe
            set switch_cousins -1
        }
        else
            set switch_cousins -1
        state switch_pick_bw_action
    }

    ifactioncount 3
    {
        switch sprite[].htg_t 4
        {
            case AC_SWITCH_3_B:
                set switch_toggle_delay 1
                action AC_SWITCH
                geta[].picnum temp
                sub temp 2
                seta[].picnum temp
                set temp 1337
                break
            case AC_SWITCH_5_B:
                ifactioncount 5
                {
                    set switch_toggle_delay 1
                    action AC_SWITCH
                    geta[].picnum temp
                    sub temp 4
                    seta[].picnum temp
                    set temp 1337
                }
                break
            case AC_SWITCH_6_B:
                ifactioncount 6
                {
                    set switch_toggle_delay 1
                    action AC_SWITCH
                    geta[].picnum temp
                    sub temp 5
                    seta[].picnum temp
                    set temp 1337
                }
                break
            case AC_SWITCH_7_B:
                ifactioncount 7
                {
                    set switch_toggle_delay 1
                    action AC_SWITCH
                    geta[].picnum temp
                    sub temp 6
                    seta[].picnum temp
                    set temp 1337
                }
                break
        }
        endswitch

        ife temp 1337
            break
    }
    set actor_switch_usable 0
ends

useractor notenemy A_LIGHTSWITCH_ON 0 AC_SWITCH
    set switch_num_frames 3
    state switch_forward
enda
useractor notenemy A_LIGHTSWITCH_OFF 0 AC_SWITCH
    set switch_num_frames 3
    state switch_backward
enda


// make elevator switches delay-able later
var elevator_delay 0 2
useractor notenemy A_ELEVATOR_DN_SWITCH_OFF 0 AC_SWITCH
    sleeptime 300
    set switch_num_frames 3
    ifn se_xvel 0
    {
        set elevator_delay se_xvel
        set se_xvel 0
    }
    state switch_forward
enda
useractor notenemy A_ELEVATOR_DN_SWITCH_ON 0 AC_SWITCH
    sleeptime 300
    set temp 0
    seta[].htextra -1
    ifle elevator_delay 0
        set temp2 150
    else
        set temp2 elevator_delay
    ifaction AC_SWITCH ifge sprite.htg_t 2 temp2
        set temp 1
    ife temp 1
    {
        ifand se_extra 32
                nullop
        else
        {
            ife se_hitag 0
                sound S_SWITCH_BUTTON01
            else
                soundvar se_hitag
        }
        action AC_SWITCH_3_B
    }
    ifaction AC_SWITCH_3_B ifactioncount 2
    {
        set switch_toggle_delay 1
        action AC_SWITCH
        geta[].picnum temp
        add temp 1
        seta[].picnum temp
        break
    }
enda

useractor notenemy A_ELEVATOR_UP_SWITCH_OFF 0 AC_SWITCH
    sleeptime 300
    set switch_num_frames 3
    ifn se_xvel 0
    {
        set elevator_delay se_xvel
        set se_xvel 0
    }
    state switch_forward
enda
useractor notenemy A_ELEVATOR_UP_SWITCH_ON 0 AC_SWITCH
    sleeptime 300
    set temp 0
    seta[].htextra -1
    ifle elevator_delay 0
        set temp2 150
    else
        set temp2 elevator_delay
    ifaction AC_SWITCH ifge sprite.htg_t 2 temp2
        set temp 1
    ife temp 1
    {
        ifand se_extra 32
                nullop
        else
        {
            ife se_hitag 0
                sound S_SWITCH_BUTTON01
            else
                soundvar se_hitag
        }
        action AC_SWITCH_3_B
    }
    ifaction AC_SWITCH_3_B ifactioncount 2
    {
        set switch_toggle_delay 1
        action AC_SWITCH
        geta[].picnum temp
        sub temp 5
        seta[].picnum temp
        break
    }
enda

useractor notenemy A_DIPSWITCH_OFF 0 AC_SWITCH
    set switch_num_frames 3
    state switch_forward
enda
useractor notenemy A_DIPSWITCH_ON 0 AC_SWITCH
    set switch_num_frames 3
    state switch_backward
enda

useractor notenemy A_ROTARYSWITCH_OFF 0 AC_SWITCH
    set switch_num_frames 3
    state switch_forward
enda
useractor notenemy A_ROTARYSWITCH_ON 0 AC_SWITCH
    set switch_num_frames 3
    state switch_backward
enda

useractor notenemy A_LEVERSWITCH_OFF 0 AC_SWITCH
    set switch_num_frames 5
    state switch_forward
enda
useractor notenemy A_LEVERSWITCH_ON 0 AC_SWITCH
    set switch_num_frames 5
    state switch_backward
enda

useractor notenemy A_ISOLATORSWITCH_OFF 0 AC_SWITCH
    set switch_num_frames 3
    state switch_forward
enda
useractor notenemy A_ISOLATORSWITCH_ON 0 AC_SWITCH
    set switch_num_frames 3
    state switch_backward
enda

useractor notenemy A_BREAKERSWITCH_OFF 0 AC_SWITCH
    set switch_num_frames 7
    state switch_forward
enda
useractor notenemy A_BREAKERSWITCH_ON 0 AC_SWITCH
    set switch_num_frames 7
    state switch_backward
enda


useractor notenemy A_DIPSWITCH2_OFF 0 AC_SWITCH
    set switch_num_frames 3
    state switch_forward
enda
useractor notenemy A_DIPSWITCH2_ON 0 AC_SWITCH
    set switch_num_frames 3
    state switch_backward
enda

useractor notenemy A_PUSHBUTTONSWITCH_OFF 0 AC_SWITCH
    set switch_num_frames 3
    state switch_forward
enda
useractor notenemy A_PUSHBUTTONSWITCH_ON 0 AC_SWITCH
    set switch_num_frames 3
    state switch_backward
enda

useractor notenemy A_ROTARYSWITCH2_OFF 0 AC_SWITCH
    set switch_num_frames 3
    state switch_forward
enda
useractor notenemy A_ROTARYSWITCH2_ON 0 AC_SWITCH
    set switch_num_frames 3
    state switch_backward
enda

useractor notenemy A_LEVERSWITCH2_OFF 0 AC_SWITCH
    set switch_num_frames 5
    state switch_forward
enda
useractor notenemy A_LEVERSWITCH2_ON 0 AC_SWITCH
    set switch_num_frames 5
    state switch_backward
enda

useractor notenemy A_BREAKERSWITCH2_OFF 0 AC_SWITCH
    set switch_num_frames 7
    state switch_forward
enda
useractor notenemy A_BREAKERSWITCH2_ON 0 AC_SWITCH
    set switch_num_frames 7
    state switch_backward
enda

useractor notenemy A_LEVERSWITCH3_OFF 0 AC_SWITCH
    set switch_num_frames 7
    state switch_forward
enda
useractor notenemy A_LEVERSWITCH3_ON 0 AC_SWITCH
    set switch_num_frames 7
    state switch_backward
enda

useractor notenemy A_CORDSWITCH_OFF 0 AC_SWITCH
    set switch_num_frames 6
    state switch_forward
enda
useractor notenemy A_CORDSWITCH_ON 0 AC_SWITCH
    set switch_num_frames 6
    state switch_backward
enda

action AC_BATONSWITCH_1 1 1 1 1 1
action AC_BATONSWITCH_2 4 1 1 1 1
action AC_BATONSWITCH_3 7 1 1 1 1
action AC_BATONSWITCH_4 10 1 1 1 1
action AC_BATONSWITCH_5 13 1 1 1 1


defstate bsdm_sparks
    ifrnd 4
    {
        rand temp 2
        add temp 2
        geta .ang temp3
        add temp3 1024
        and temp3 2047
        set temp4 tilesizy[sprite[].picnum]
        shiftl temp4 2
        mul temp4 sprite[].yrepeat
        shiftr temp4 1
        set temp2 sprite[].z
        sub temp2 temp4
        for itervar range temp
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 128
            seta[RETURN].cstat 32768
            setav[RETURN].particle_force_pal 7
            seta[RETURN].ang temp3
            seta[RETURN].z temp2
        }
        shiftl temp 1
        for itervar range temp
        {
            espawn A_GENERIC_PARTICLE
            seta[RETURN].xrepeat 129
            seta[RETURN].cstat 32768
            setav[RETURN].particle_force_pal 7
            seta[RETURN].ang temp3
            seta[RETURN].z temp2
        }
        ifpdistl 16384
        {
            getp .sound_pitch temp
            rand temp2 32
            setp .sound_pitch temp2
            ifactorsound THISACTOR S_ENV_ZAP1_QT
            {
                ifactorsound THISACTOR S_ENV_ZAP2_QT
                    sound S_ENV_ZAP1_QT
                else
                    sound S_ENV_ZAP2_QT
            }
            else
                sound S_ENV_ZAP1_QT
            setp .sound_pitch temp
        }
    }
ends

useractor notenemy A_BATONSWITCH_OFF 0 AC_SWITCH
    sleeptime 300
    strength 1
    ifaction AC_SWITCH
    {
        ifand sprite.htg_t 2 2
            seta .htg_t 3 457
        else ifand sprite.htg_t 2 4
            seta .htg_t 3 457
        else
            seta .htg_t 3 0
        state bsdm_sparks
    }
    ifhitweapon
    {
        ifand g_do_use_prompt 4
            xor g_do_use_prompt 4
        set temp 0
        ifwasweapon P_SHOCKER
            set temp 1
        else ifwasweapon P_PLASMA_BOLT
            ife sprite.htowner player.i
                set temp 1
        ife temp 1
        {
            set temp 0
            for temp2 sprofstat STAT_ACTOR
            {
                ifn temp2 THISACTOR
                    ife sprite[temp2].picnum A_BATONSWITCH_OFF
                    {
                        ife actorvar[temp2].se_lotag se_lotag
                            set temp 1
                    }
            }
            ife temp 0
                state switch_activate
            getp .sound_pitch temp
            setp .sound_pitch 480
            sound S_SWITCH_CARDUNLOCK
            sound S_BIG_IMPACT
            setp .sound_pitch temp
            cactor A_BATONSWITCH_ON
        }
    }
enda
useractor notenemy A_BATONSWITCH_ON 0 AC_SWITCH
    
    ife counter2 0
        sound S_AMB_SPARKLOOP_QT
    add counter2 1
    ifg counter2 45
    {
        sound S_AMB_SPARKLOOP_QT
        set counter2 0
    }
    ifactorsound THISACTOR S_AMB_SPARKLOOP_QT
        nullop
    else
        sound S_AMB_SPARKLOOP_QT
enda

var bswitch_on 0 2
var bswitch_delay 0 2
useractor notenemy A_BATONSWITCH_TIMED 0 AC_SWITCH
    sleeptime 300
    strength 1
    ife st_do_once 0
    {
        set st_do_once se_hitag
        div st_do_once 5
        clamp st_do_once 1 65536
    }
    ifaction AC_SWITCH
    {
        ifand sprite.htg_t 2 2
            seta .htg_t 3 472
        else ifand sprite.htg_t 2 4
            seta .htg_t 3 472
        else
            seta .htg_t 3 0
        state bsdm_sparks
    }
    ife bswitch_delay 0
    {
        ifhitweapon
        {
            set temp 0
            ifwasweapon P_SHOCKER
                set temp 1
            else ifwasweapon P_PLASMA_BOLT
                ife sprite.htowner player.i
                    set temp 1
            ife temp 1
            {
                set temp 0
                for temp2 sprofstat STAT_ACTOR
                {
                    ifn temp2 THISACTOR
                        ife sprite[temp2].picnum A_BATONSWITCH_TIMED
                        {
                            ife actorvar[temp2].se_lotag se_lotag
                            {
                                ife actorvar[temp2].counter 0
                                    set temp 1
                                ifg se_extra 0
                                    setav[temp2].se_extra se_extra
                            }
                        }
                }
                ife temp 0
                {
                    ife bswitch_on 0
                        state switch_activate
                    for temp2 sprofstat STAT_ACTOR
                    {
                        ife sprite[temp2].picnum A_BATONSWITCH_TIMED
                        {
                            ife actorvar[temp2].se_lotag se_lotag
                                    setav[temp2].bswitch_on 1
                        }
                    }
                }
                    
             //   set counter st_do_once
                set counter 5
                action AC_BATONSWITCH_1
                getp .sound_pitch temp
                setp .sound_pitch 480
                sound S_SWITCH_CARDUNLOCK
                sound S_BIG_IMPACT
                setp .sound_pitch temp
                ifand g_do_use_prompt 4
                    xor g_do_use_prompt 4
            }
        }
    }
    else
    {
        seta[].htextra -1
        sub bswitch_delay 1
        ifle bswitch_delay 0
        {
            for temp2 sprofstat STAT_ACTOR
            {
                ife sprite[temp2].picnum A_BATONSWITCH_TIMED
                {
                    ife actorvar[temp2].se_lotag se_lotag
                            setav[temp2].bswitch_delay 0
                }
            }
        }
    }
   // else
    ifg counter 0
    {
            ife counter2 0
                sound S_AMB_SPARKLOOP_QT
            add counter2 1
            ifg counter2 45
            {
                sound S_AMB_SPARKLOOP_QT
                set counter2 0
            }
            ifactorsound THISACTOR S_AMB_SPARKLOOP_QT
                nullop
            else
                sound S_AMB_SPARKLOOP_QT
        ifge sprite[].htg_t 2 st_do_once
        {
            sub counter 1
            switch sprite [].htg_t 4
            {
                case AC_BATONSWITCH_1:
                    action AC_BATONSWITCH_2
                    break
                case AC_BATONSWITCH_2:
                    action AC_BATONSWITCH_3
                    break
                case AC_BATONSWITCH_3:
                    action AC_BATONSWITCH_4
                    break
                case AC_BATONSWITCH_4:
                    action AC_BATONSWITCH_5
                    break
                case AC_BATONSWITCH_5:
                    set temp 0
                    for temp2 sprofstat STAT_ACTOR
                    {
                        ifn temp2 THISACTOR
                            ife sprite[temp2].picnum A_BATONSWITCH_TIMED
                            {
                                ife actorvar[temp2].se_lotag se_lotag
                                {
                                    ife actorvar[temp2].counter 0
                                        set temp 1
                                }
                            }
                    }
                    ife temp 0
                    {
                        ifg se_extra 0
                        {
                            set temp7 se_lotag
                            set se_lotag se_extra
                            state switch_activate
                            set se_lotag temp7
                        }
                        else ife se_extra -1
                            state switch_activate
                        set bswitch_on 0
                        ifn se_xvel 0
                        {
                            for temp2 sprofstat STAT_ACTOR
                            {
                                ife sprite[temp2].picnum A_BATONSWITCH_TIMED
                                {
                                    ife actorvar[temp2].se_lotag se_lotag
                                            setav[temp2].bswitch_delay se_xvel
                                }
                            }
                        }
                        
                    }
                    set counter 0
                    getp .sound_pitch temp
                    setp .sound_pitch 480
                    sound S_ENGINE_OFF
                    setp .sound_pitch temp
                    action AC_SWITCH
                    break
            }
            endswitch
        }
    }
    else
    {
        stopactorsound THISACTOR S_AMB_SPARKLOOP
        set counter2 0
    }
enda

action AC_VALVESWITCH_OFF 0 1 1 1 1
action AC_VALVESWITCH_ON 0 1 1 1 1
action AC_VALVESWITCH_FORWARD 0 8 1 1 1
action AC_VALVESWITCH_REVERSE 7 8 1 -1 1

appendevent EVENT_SPAWN
    switch sprite[].picnum
        case A_VALVESWITCH_1
        case A_VALVESWITCH_2
            ifand sprite[].cstat 32768
                nullop
            else
                cstator 16
            break
        case A_VALVESWITCH_1_CLOSE
            action AC_VALVESWITCH_ON
            ifand sprite[].cstat 32768
                nullop
            else
                cstator 16
            cactor A_VALVESWITCH_1
            break
        case A_VALVESWITCH_2_CLOSE
            action AC_VALVESWITCH_ON
            ifand sprite[].cstat 32768
                nullop
            else
                cstator 16
            cactor A_VALVESWITCH_2
            break
    endswitch
endevent

defstate valveswitch_code
    or se_extra 64
    state switch_toggle
    set temp 0
    ifpdistl 1536 ife actor_switch_usable 1 ifhitspace
    {
        ifand se_extra 16
            nullop
        else ifand se_extra 512
            nullop
        else
            set temp 1
    }
    set actor_switch_usable 0
    ifg switch_wait 0
    {
        sub switch_wait 1
        set temp 0
    }
    
    ife temp 1
    {
        ifaction AC_VALVESWITCH_OFF
        {
            action AC_VALVESWITCH_FORWARD
            ifand se_extra 32
                nullop
            else
            {
                ife se_hitag 0
                    sound S_VALVE_TURN
                else
                    soundvar se_hitag
            }
        }
        else ifaction AC_VALVESWITCH_ON
        {
            action AC_VALVESWITCH_REVERSE
            ifand se_extra 32
                nullop
            else
            {
                ife se_hitag 0
                    sound S_VALVE_TURN
                else
                    soundvar se_hitag
            }
        }
    }
    set temp 0
    ifactioncount 24
    {
        ifaction AC_VALVESWITCH_FORWARD
        {
            action AC_VALVESWITCH_ON
            set temp 1
        }
        else ifaction AC_VALVESWITCH_REVERSE
        {
            action AC_VALVESWITCH_OFF
            set temp 1
        }
    }
    else ifaction AC_VALVESWITCH_FORWARD
        set switch_toggle_delay 1
    else ifaction AC_VALVESWITCH_REVERSE
        set switch_toggle_delay 1
    ife temp 1
    {
        set switch_wait se_xvel
        ifn se_lotag 0
        {
            ife switch_keep_active 0
                state switch_activate
            ifand se_extra 128 ifand se_extra 1
                set switch_keep_active 1
        }
        set switch_source 1 // for later maybe
    }
ends
useractor notenemy A_VALVESWITCH_1 0 AC_VALVESWITCH_OFF
    state valveswitch_code
enda

useractor notenemy A_VALVESWITCH_2 0 AC_VALVESWITCH_OFF
    state valveswitch_code
enda
useractor notenemy A_VALVESWITCH_1_CLOSE 0 AC_VALVESWITCH_OFF
    state valveswitch_code
enda
useractor notenemy A_VALVESWITCH_2_CLOSE 0 AC_VALVESWITCH_OFF
    state valveswitch_code
enda

var access_pal
var fix_access

action AC_CARDSWITCH 0 4 1 1 16
action AC_CARDSWITCHDENIED 4 2 1 1 32

spritenopal A_ACCESSCARDSWITCH_OFF
spritenopal A_ACCESSCARDSWITCH_ON
useractor notenemy A_ACCESSCARDSWITCH_SPAWN 0 AC_SWITCH
    sleeptime 300
    action AC_CARDSWITCH
    cactor A_ACCESSCARDSWITCH_OFF
enda

defstate palfinder3000
    switch sprite[].pal
        case PAL_KEYCARD_1
        default
            ifand player[].got_access 1
                set temp 1
            break
        case PAL_KEYCARD_2
            ifand player[].got_access 2
                set temp 2
            break
        case PAL_KEYCARD_3
            ifand player[].got_access 4
                set temp 3
            break
        case PAL_KEYCARD_4
            ifand player[].got_access 8
                set temp 4
            break
    endswitch
ends

defstate access_card_code
    set temp 0
    set temp2 se_yvel
    abs temp2
    ife activateshit[temp2] 1
        inv se_yvel
    sleeptime 300
    ifg sprite.shade 0
        seta .shade 0
    ife switch_toggle_delay 1
    {
        ifhitspace
            set actor_switch_usable 0
        else
            set switch_toggle_delay 0
    }
    
    ifaction AC_CARDSWITCHDENIED
    {
        set temp 0
        ifactioncount 15
            action AC_CARDSWITCH
        else ifpdistl 1536 ifhitspace ife player[].kickback_pic 0 ife player[].access_incs 0 ife actor_switch_usable 1
            {
                state palfinder3000
                ifn temp 0
                    action AC_CARDSWITCH
                else
                {
                    set temp4 tilesizy[sprite[].picnum]
                    shiftl temp4 2
                    mul temp4 sprite[].yrepeat
                    shiftr temp4 1
                    set temp2 sprite[].z
                    sub temp2 temp4
                    addphealth -1
                    palfrom 30 0 0 30
                    soundonce S_P_ZAPPED_END
                    espawn A_GENERIC_PARTICLE
                    seta[RETURN].z temp2
                    seta[RETURN].xrepeat 123
                    espawn A_GENERIC_PARTICLE
                    seta[RETURN].xrepeat 120
                    seta[RETURN].z temp2
                    set switch_toggle_delay 1
                }
            }
        ife temp 0
        {
            set actor_switch_usable 0
            break
        }
    }
    ifn se_yvel 0
    {
        ifg se_yvel 0
        {
            ifaction AC_CARDSWITCH
            {
                seta .htg_t 2 0
                seta .htg_t 3 5
            }
            ife switch_toggle_delay 0
            {
                ifpdistl 1536 ife actor_switch_usable 1 ifaction AC_CARDSWITCH ifhitspace
                {
                    setp .sound_pitch 660
                    sound S_SWITCH_SNAPPY
                    sound S_SWITCH_BUTTON02
                    setp .sound_pitch 0
                    set switch_toggle_delay 1
                    ifrnd 32
                    {
                        ife p_lastline 0
                        {
                            actorsound player.i S_SHELLYVO_LVLSND10 // temp
                            set counter3 1
                        }
                    }
                    else ife counter3 0
                    {
                        ife p_lastline 0
                        {
                            actorsound player.i S_SHELLYVO_LVLSND10 // temp
                            set counter3 1
                        }
                    }
                }
            }
            ife counter 0
                break
        }
        else ifg sprite.htg_t 3 4
            seta .htg_t 3 0
    }
    set temp 0
    state palfinder3000
    ifpdistl 1536 ifhitspace ife player[].kickback_pic 0 ife actor_switch_usable 1 ife player[].access_incs 0
    {
        ifn temp 0
        {
            ifand g_do_use_prompt 8
                xor g_do_use_prompt 8
            getp[].got_access fix_access
            ife temp 1
                xor fix_access 1
            else ife temp 2
                xor fix_access 2
            else ife temp 3
                xor fix_access 4
            else ife temp 4
                xor fix_access 8
            setp[].access_incs 1
            set flash_keycards -3
            geta[].pal access_pal
            set counter 1
            ifg p_have_dart 0
                ifl p_have_dart 19
                    set p_have_dart 19
        }
        else
        {
            ife se_hitag 0
                sound S_SWITCH_CARDLOCKED
            else
                soundvar se_hitag
            set switch_toggle_delay 1
            action AC_CARDSWITCHDENIED
            switch sprite[].pal
                case PAL_KEYCARD_1
                default
                    quote 88
                    break
                case PAL_KEYCARD_2
                    quote 89
                    break
                case PAL_KEYCARD_3
                    quote 90
                    break
                case PAL_KEYCARD_4
                    quote 91
                    break
            endswitch
            ifg p_have_dart 0
                ifl p_have_dart 19
                    set p_have_dart 19
            resetcount
        }
    }
    ife counter 1
    {
        ife player[].access_incs 7
            sound S_BBOMB_THROW
        ife player[].access_incs 15
        {
            ife se_hitag 0
                sound S_SWITCH_CARDUNLOCK
            else
                soundvar se_hitag

            ifn se_lotag 0
                state switch_activate
            ifactor A_ACCESSCARDSWITCH_OFF
            {
                for temp sprofstat STAT_ACTOR
                {
                    ife sprite[temp].picnum A_ACCESSCARDSWITCH_OFF
                    {
                        ife sprite[temp].pal sprite[].pal
                        {
                            getav[temp].se_lotag temp2
                            ife temp2 se_lotag
                                seta[temp].picnum A_ACCESSCARDSWITCH_ON
                        }
                    }
                    else ife sprite[temp].picnum A_ACCESSCARDSWITCH_SPAWN
                    {
                        ife sprite[temp].pal sprite[].pal
                        {
                            getav[temp].se_lotag temp2
                            ife temp2 se_lotag
                                seta[temp].picnum A_ACCESSCARDSWITCH_ON
                        }
                    }
                }
                action AC_SWITCH
                cactor A_ACCESSCARDSWITCH_ON
            }
            else ifactor A_ACCESSCARDSWITCH2_OFF
            {
                for temp sprofstat STAT_ACTOR
                {
                    ife sprite[temp].picnum A_ACCESSCARDSWITCH2_OFF
                    {
                        ife sprite[temp].pal sprite[].pal
                        {
                            getav[temp].se_lotag temp2
                            ife temp2 se_lotag
                                seta[temp].picnum A_ACCESSCARDSWITCH2_ON
                        }
                    }
                }
                action AC_SWITCH
                cactor A_ACCESSCARDSWITCH2_ON
            }
            break
        }
    }
    set actor_switch_usable 0
ends

useractor notenemy A_ACCESSCARDSWITCH_OFF 0 AC_CARDSWITCH
    state access_card_code
enda

useractor notenemy A_ACCESSCARDSWITCH_ON 0 AC_SWITCH
    ifaction AC_SWITCH
        nullop
    else
        action AC_SWITCH
    ife st_do_once 0
    {
        for temp sprofstat STAT_ACTOR
        {
            ife sprite[temp].picnum A_ACCESSCARDSWITCH_OFF
            {
                ife sprite[temp].pal sprite[].pal
                {
                    getav[temp].se_lotag temp2
                    ife temp2 se_lotag
                        seta[temp].picnum A_ACCESSCARDSWITCH_ON
                }
            }
            else ife sprite[temp].picnum A_ACCESSCARDSWITCH_SPAWN
            {
                ife sprite[temp].pal sprite[].pal
                {
                    getav[temp].se_lotag temp2
                    ife temp2 se_lotag
                        seta[temp].picnum A_ACCESSCARDSWITCH_ON
                }
            }
        }
        set st_do_once 1
    }
enda

useractor notenemy A_ACCESSCARDSWITCH2_OFF 0 AC_CARDSWITCH
    state access_card_code
enda

useractor notenemy A_ACCESSCARDSWITCH2_ON 0 AC_SWITCH
    ifaction AC_SWITCH
        nullop
    else
        action AC_SWITCH
    ife st_do_once 0
    {
        for temp sprofstat STAT_ACTOR
        {
            ife sprite[temp].picnum A_ACCESSCARDSWITCH2_OFF
            {
                ife sprite[temp].pal sprite[].pal
                {
                    getav[temp].se_lotag temp2
                    ife temp2 se_lotag
                        seta[temp].picnum A_ACCESSCARDSWITCH2_ON
                }
            }
        }
        set st_do_once 1
    }
enda

appendevent EVENT_LOADACTOR
    ifactor A_SECTOR_SWITCH
    {
        geta[].hitag se_hitag
        geta[].lotag se_lotag
        geta[].extra se_extra
        geta[].xvel se_xvel
        ifl se_xvel 0
            set se_xvel 0
        ifl se_extra 0
            set se_extra 0
        seta[].hitag 0
        seta[].lotag 0
        cstat 32768
    }
endevent

useractor notenemy A_SECTOR_SWITCH
    ifg switch_wait 0
    {
        sub switch_wait 1
        break
    }
    ife switch_toggle_delay 1
    {
        ifhitspace
            break
        else
            set switch_toggle_delay 0
    }
    ifand se_extra 2
    {
        ife player[].cursectnum sprite[].sectnum
        {
            ife nogrunting 0 ifl p_dragobj 0
            {
                ifhitspace
                {
                    state switch_activate
                    set switch_toggle_delay 1
                    set switch_wait se_xvel
                }
            }
        }
    }
    else
    {
        ifn ref_hitsect -1
        {
            ife ref_hitsect sprite[].sectnum
            {
                ifhitspace
                {                
                    ife player[].cursectnum sprite[].sectnum
                        set temp 1535
                    else
                    {
                        espawn 6801
                        seta[RETURN].sectnum ref_hitsect
                        seta[RETURN].x ref_hitx
                        seta[RETURN].y ref_hity
                        seta[RETURN].z ref_hitz
                        seta[RETURN].cstat 32768
                        ldist temp RETURN player[].i
                        seta[RETURN].xrepeat 0
                    }
                    ifl temp 1536
                    {
                        ifand se_extra 1
                        {
                            getceilzofslope ref_hitsect ref_hitx ref_hity temp
                            add temp 1024
                            ifl ref_hitz temp
                            {
                                state switch_activate
                                set switch_toggle_delay 1
                                set switch_wait se_xvel
                            }
                        }
                        else
                        {
                            getflorzofslope ref_hitsect ref_hitx ref_hity temp
                            sub temp 1024
                            ifg ref_hitz temp
                            {
                                state switch_activate
                                set switch_toggle_delay 1
                                set switch_wait se_xvel
                            }
                        }
                    }
                }
            }
        }
    }
enda

appendevent EVENT_LOADACTOR
    ifactor A_RELAY_MULTISWITCH
    {
        geta[].hitag se_hitag
        geta[].lotag se_lotag
        geta[].extra se_extra
        geta[].xvel se_xvel
        geta[].yvel se_yvel
        geta[].zvel se_zvel
        ifl se_xvel 0
            set se_xvel 0
        ifl se_yvel 0
            set se_yvel 0
        ifl se_extra 0
            set se_extra 0
        seta[].hitag 0
        seta[].lotag 0
        cstat 32768
        ifand se_yvel 8 // based on skill here
        {
            getu[].player_skill temp
            sub temp 1
            clamp temp 0 65536
            add se_hitag temp
        }
    }
endevent

useractor notenemy A_RELAY_MULTISWITCH
    set actor_switch 1
    ifg switch_wait 0
    {
        sub switch_wait 1
        break
    }
    ifg counter se_extra
        break
        
    set temp7 0
    set temp se_zvel
    abs temp
    add temp 1
    for itervar range temp
    {
        set temp2 itervar
        ifl se_zvel 0
            inv temp2
        add temp2 se_lotag
        ife activateshit[temp2] 1
            set temp7 1
    }
    ife temp7 1
    {
        set temp se_hitag
        set temp3 se_lotag
        set temp2 counter
        abs temp2
        add se_hitag temp2
        set se_lotag se_hitag
        state switch_activate
        set switch_toggle_delay 1
        set switch_wait se_xvel
        set se_hitag temp
        set se_lotag temp3
        ifg se_extra 0
            add counter 1
        else
            set counter 0
        ifg counter se_extra
        {
            ifand se_yvel 1
            {
                inv counter
                ifand se_yvel 2
                    add counter 2
                else
                    add counter 1
            }
            else ifand se_yvel 4
                nullop
            else
                set counter 0
        }
    }

enda

eventloadactor A_COMBO_SEQUENCE_SWITCH
    geta[].hitag se_hitag
    geta[].lotag se_lotag
    geta[].extra se_extra
    geta[].xvel se_xvel
    geta[].yvel se_yvel
    geta[].zvel se_zvel
    geta[].owner tp_owner
    set counter 0
    ifand sprite.cstat 512
    {
        ifl se_lotag 0
        {
            inv se_lotag
            or tp_activated 1
        }
        ifl se_hitag 0
        {
            inv se_hitag
            or tp_activated 2
        }
        ifl se_extra 0
        {
            inv se_extra
            or tp_activated 4
        }
        ifl se_xvel 0
        {
            inv se_xvel
            or tp_activated 8
        }
        ifl se_yvel 0
        {
            inv se_yvel
            or tp_activated 16
        }
        ifl se_zvel 0
        {
            inv se_zvel
            or tp_activated 32
        }
    }
    else
    {
        ifl se_lotag 0
            set se_lotag 0
        ifl se_hitag 0
            set se_hitag 0
        ifl se_extra 0
            set se_extra 0
        ifl se_xvel 0
            set se_xvel 0
        ifl se_yvel 0
            set se_yvel 0
        ifl se_zvel 0
            set se_zvel 0
    }
    ifg se_lotag 0
    {
        or counter 1
        add counter2 1
        ifg se_hitag 0
        {
            or counter 2
            add counter2 1
            ifg se_extra 0
            {
                or counter 4
                add counter2 1
                ifg se_xvel 0
                {
                    or counter 8
                    add counter2 1
                    ifg se_yvel 0
                    {
                        or counter 16
                        add counter2 1
                        ifg se_zvel 0
                            or counter 32
                    }
                }
            }
        }
    }

    ifl tp_owner 0
        set tp_owner 0
    seta[].hitag 0
    seta[].lotag 0
    ifspritepal 10
        set se_above 1
    else ifspritepal 11
    {
        set se_above 1
        spritepal 9
    }
    else ifspritepal 1
        set se_above 2
    else ifspritepal 2
    {
        set se_above 2
        spritepal 9
    }
    ife se_above 2
        ifand counter 32
            xor counter 32
    ifand sprite.cstat 8
        cstat 32776
    else
        cstat 32768
enda

var combo_toggle 0 2
useractor notenemy A_COMBO_SEQUENCE_SWITCH
    ifg tp_owner 0
    {
        ife se_above 1
        {
            ifg se_lotag 0 ife activateshit[se_lotag] 1
            {
                ifand tp_activated 1
                    xor tp_activated 1
                else
                    or tp_activated 1
            }
            ifg se_hitag 0 ife activateshit[se_hitag] 1
            {
                ifand tp_activated 2
                    xor tp_activated 2
                else
                    or tp_activated 2
            }
            ifg se_extra 0 ife activateshit[se_extra] 1
            {
                ifand tp_activated 4
                    xor tp_activated 4
                else
                    or tp_activated 4
            }
            ifg se_xvel 0 ife activateshit[se_xvel] 1
            {
                ifand tp_activated 8
                    xor tp_activated 8
                else
                    or tp_activated 8
            }
            ifg se_yvel 0 ife activateshit[se_yvel] 1
            {
                ifand tp_activated 16
                    xor tp_activated 16
                else
                    or tp_activated 16
            }
            ifg se_zvel 0 ife activateshit[se_zvel] 1
            {
                ifand tp_activated 32
                    xor tp_activated 32
                else
                    or tp_activated 32
            }
            ifand sprite.cstat 8
            {
                ifn combo_toggle 0
                {
                    ifn combo_toggle tp_activated
                    {
                        set combo_toggle tp_activated
                        set tp_activated counter
                    }
                    else
                        break
                }
            }
            ife tp_activated counter
            {
                operateactivators tp_owner THISACTOR
                operatemasterswitches tp_owner
                operaterespawns tp_owner
                setarray preloadactivations[tp_owner] 1
                ifand sprite.cstat 8
                {
                    ife combo_toggle 0
                        set combo_toggle tp_activated
                    else
                    {
                        set tp_activated combo_toggle
                        set combo_toggle 0
                    }
                }
                else
                    set tp_activated 0
                ifspritepal 9
                    killit
            }
        }
        else ife se_above 2
        {
            ife tp_activated 0
                set counter3 0
                
            ifg se_zvel 0
            {
                set temp sprite.blend
                add temp 1
                for itervar range temp
                {
                    set temp2 se_zvel
                    add temp2 itervar
                    ife activateshit[temp2] 1
                    {
                        switch counter3
                            case 0
                                ifg se_lotag 0
                                {
                                    ifn temp2 se_lotag
                                        set tp_activated 0
                                }
                                break
                            case 1
                                ifg se_hitag 0
                                {
                                    ifn temp2 se_hitag
                                        set tp_activated 0
                                }
                                break
                             case 2
                                ifg se_extra 0
                                {
                                    ifn temp2 se_extra
                                        set tp_activated 0
                                }
                                break
                             case 3
                                ifg se_xvel 0
                                {
                                    ifn temp2 se_xvel
                                        set tp_activated 0
                                }
                                break
                             case 4
                                ifg se_yvel 0
                                {
                                    ifn temp2 se_yvel
                                        set tp_activated 0
                                }
                                break
                        endswitch
                    }
                }
            }
            ife tp_activated 0
                set counter3 0
            switch counter3
                case 0
                    ifg se_lotag 0 ife activateshit[se_lotag] 1
                    {
                        add counter3 1
                        or tp_activated 1
                    }
                    break
                case 1
                    ifg se_hitag 0 ife activateshit[se_hitag] 1
                    {
                        add counter3 1
                        or tp_activated 2
                    }
                    break
                 case 2
                    ifg se_extra 0 ife activateshit[se_extra] 1
                    {
                        add counter3 1
                        or tp_activated 4
                    }
                    break
                 case 3
                    ifg se_xvel 0 ife activateshit[se_xvel] 1
                    {
                        add counter3 1
                        or tp_activated 8
                    }
                    break
                 case 4
                    ifg se_yvel 0 ife activateshit[se_yvel] 1
                    {
                        add counter3 1
                        or tp_activated 16
                    }
                    break
            endswitch


            

            ifand sprite.cstat 8
            {
                ifn combo_toggle 0
                {
                    ifn combo_toggle tp_activated
                    {
                        set combo_toggle tp_activated
                        set tp_activated counter
                    }
                    else
                        break
                }
            }
            ife tp_activated counter
            {
                operateactivators tp_owner THISACTOR
                operatemasterswitches tp_owner
                operaterespawns tp_owner
                setarray preloadactivations[tp_owner] 1
                ifand sprite.cstat 8
                {
                    ife combo_toggle 0
                        set combo_toggle tp_activated
                    else
                    {
                        set tp_activated combo_toggle
                        set combo_toggle 0
                    }
                }
                else
                    set tp_activated 0
                ifspritepal 9
                    killit
            }
        }
        else
        {
            ifg se_lotag 0 ife activateshit[se_lotag] 1
            {
                ifand tp_activated 1
                {
                    set tp_activated 0
                    or tp_activated 1
                }
                else
                {
                    ifg tp_activated 1 // first
                        set tp_activated 0
                    or tp_activated 1
                }
            }
            ifg se_hitag 0 ife activateshit[se_hitag] 1
            {
                ifand tp_activated 2
                    set tp_activated 0
                else
                {
                    ife tp_activated 1
                        or tp_activated 2
                    else
                        set tp_activated 0
                }
            }
            ifg se_extra 0 ife activateshit[se_extra] 1
            {
                ifand tp_activated 4
                    set tp_activated 0
                else
                {
                    ife tp_activated 3
                        or tp_activated 4
                    else
                        set tp_activated 0
                }
            }
            ifg se_xvel 0 ife activateshit[se_xvel] 1
            {
                ifand tp_activated 8
                    set tp_activated 0
                else
                {
                    ife tp_activated 7
                        or tp_activated 8
                    else
                        set tp_activated 0
                }
            }
            ifg se_yvel 0 ife activateshit[se_yvel] 1
            {
                ifand tp_activated 16
                    set tp_activated 0
                else
                {
                    ife tp_activated 15
                        or tp_activated 16
                    else
                        set tp_activated 0
                }
            }
            
            ife se_above 2
            {
                ifg se_zvel 0
                {
                    set temp sprite.blend
                    add temp 1
                    for itervar range temp
                    {
                        set temp2 se_zvel
                        add temp2 itervar
                        ife activateshit[temp2] 1
                        {
                            ife temp2 se_lotag
                            {
                                ife se_lotag 0
                                    set tp_activated 0
                            }
                            else ife temp2 se_hitag
                            {
                                ife se_hitag 0
                                    set tp_activated 0
                            }
                            else ife temp2 se_extra
                            {
                                ife se_extra 0
                                    set tp_activated 0
                            }
                            else ife temp2 se_xvel
                            {
                                ife se_xvel 0
                                    set tp_activated 0
                            }
                            else ife temp2 se_yvel
                            {
                                ife se_yvel 0
                                    set tp_activated 0
                            }
                            else
                                set tp_activated 0
                        }
                    }
                }
            }
            else
            {
                ifg se_zvel 0 ife activateshit[se_zvel] 1
                {
                    ifand tp_activated 32
                        set tp_activated 0
                    else
                    {
                        ife tp_activated 31
                            or tp_activated 32
                        else
                            set tp_activated 0
                    }
                }
            }
            ifand sprite.cstat 8
            {
                ifn combo_toggle 0
                {
                    ifn combo_toggle tp_activated
                    {
                        set combo_toggle tp_activated
                        set tp_activated counter
                    }
                    else
                        break
                }
            }
            ife tp_activated counter
            {
                operateactivators tp_owner THISACTOR
                operatemasterswitches tp_owner
                operaterespawns tp_owner
                setarray preloadactivations[tp_owner] 1
                ifand sprite.cstat 8
                {
                    ife combo_toggle 0
                        set combo_toggle tp_activated
                    else
                    {
                        set tp_activated combo_toggle
                        set combo_toggle 0
                    }
                }
                else
                    set tp_activated 0
                ifspritepal 9
                    killit
            }
        }
    }
enda

defstate crack_code
    ife st_do_once 0
    {
        set rain_amount tilesizx[sprite[].picnum]
        mul rain_amount sprite[].xrepeat
        shiftr rain_amount 2
        set pivot_xoff rain_amount
        shiftr pivot_xoff 1
        
        set temp4 tilesizy[sprite[].picnum]
        shiftl temp4 2
        mul temp4 sprite[].yrepeat
        set pivot_yoff temp4
        add rain_amount temp4
        shiftr rain_amount 10
        set st_do_once 1
    }
    ife sprite[].xrepeat 0
        killit
    ife counter3 1
    {
        rand temp 3
        add temp 1
        add counter2 temp
        ifg counter2 rain_amount
        {
            sub counter2 rain_amount
            sub temp counter2
            clamp temp 0 4
            set counter2 rain_amount
        }
        for itervar range temp
        {
            ifrnd 127
            {
                espawn A_GENERIC_DEBRIS
                setav[RETURN].debris_type se_hitag
                ifg se_yvel 0
                    setav[RETURN].particle_force_pal se_yvel
                else
                    setav[RETURN].particle_force_pal 1
                rand temp2 8
                setav[RETURN].debris_add_size temp2
                rand temp2 16
                setav[RETURN].debris_add_vel temp2
            }
            else
            {
                espawn A_SMOKE2
                rand temp2 8
                add temp2 rain_amount
                seta[RETURN].xrepeat temp2
                seta[RETURN].yrepeat temp2
            }
            seta[RETURN].cstat 32768
            rand temp2 pivot_xoff
            geta .ang temp3
            ifrnd 127
                add temp3 512
            else
                sub temp3 512
            and temp3 2047
            seta[RETURN].ang temp3
            seta[RETURN].xvel temp2
            ssp RETURN 0
            seta[RETURN].xvel 0
            seta[RETURN].ang sprite.ang
            rand temp2 pivot_yoff
            inv temp2
            add temp2 sprite.z
            seta[RETURN].z temp2
        }
        
        ifge counter2 rain_amount
            killit
        break
    }
    ifg se_lotag 0
    {
        ife counter 0
        {
            set temp4 tilesizy[sprite[].picnum]
            shiftl temp4 2
            mul temp4 sprite[].yrepeat
            findnearspritezvar P_GRENADE 256 temp4 temp
            ifn temp -1
            {
                seta[temp].xvel 0
                seta[temp].yvel 0
            }
            set counter 1
        }
        else
            set counter 0
        ifhitweapon
        {
            strength 1
            ifwasweapon EXPLOSION
            {
                state switch_activate
                for temp sprofstat STAT_ACTOR
                {
                    switch sprite[temp].picnum
                        case A_CRACKSWITCH_1
                        case A_CRACKSWITCH_2
                        case A_CRACKSWITCH_3
                        case A_CRACKSWITCH_4
                        case A_CRACKSWITCH_5
                            ife actorvar[temp].se_lotag se_lotag
                            {
                                setav[temp].counter3 1
                                seta[temp].cstat 32768
                            }
                            break
                    endswitch
                }
                cstat 32768
                set counter3 1
                break
            }
        }
    }
ends

useractor notenemy A_CRACKSWITCH_1 1 AC_SWITCH state crack_code enda
useractor notenemy A_CRACKSWITCH_2 1 AC_SWITCH state crack_code enda
useractor notenemy A_CRACKSWITCH_3 1 AC_SWITCH state crack_code enda
useractor notenemy A_CRACKSWITCH_4 1 AC_SWITCH state crack_code enda
useractor notenemy A_CRACKSWITCH_5 1 AC_SWITCH state crack_code enda

var p_slowaccess -41 0

appendevent EVENT_PREWORLD
    ife player[myconnectindex].access_incs 2
    {
        set p_slowaccess -40
        set p_have_dart 0
    }
    ifn p_slowaccess -41 ifl p_slowaccess 0
    {
        set temp p_slowaccess
        shiftr temp 1
        add temp 22
        abs temp
        setp[myconnectindex].access_incs temp
        ifl p_slowaccess -28
            add p_slowaccess 2
        else
            add p_slowaccess 1
    }
endevent

// Draw hand holding access card

appendevent EVENT_DISPLAYACCESS
    ifg player[].access_incs 9
        setp[].got_access fix_access

    ifg weaponcount 12 ifl weaponcount 18
        break
    state ResetTile
    set hudx_x -164
    set hudx_tilenum T_ACCESSHAND
    set hudx_pal access_pal
    set hudx_orientation 16

    set hudx_scale 73728
    set hudx_y -84
    ifg p_have_dart 0
    {
        set temp smooth_weapon_pos
        mul temp 2
        set temp2 smooth_weapon_pos
        shiftr temp2 4
        add temp temp2
        sub hudx_y temp
        shiftr temp 2
        sub hudx_x temp
        add hudx_angle 96
    }

    set temp p_slowaccess
    abs temp
    sub temp 22
    shiftl temp 3
    ifg p_slowaccess -22 // player[].access_incs 11
    {
        shiftl temp 1
        sub hudx_y temp
        set temp p_slowaccess
        abs temp
        sub temp 42
        shiftl temp 2
        sub hudx_angle temp
    }
    else
    {
        add hudx_y temp
        inv temp
        shiftr temp 1
        sub hudx_x temp
        shiftr temp 1
        sub hudx_x temp
    }
    getp[].ohoriz temp
    sub temp player[].horiz
    shiftr temp 2
    sub hudx_y temp
    sub hudx_y weapon_horiz
    guniqhudid 101
    state DrawTile640x480WeaponBob
    guniqhudid 0
endevent


// DO TAG +1 for proximity!

var light_toggle 0 2
var light_wait 0 2
var light_overage 0 2
var light_flicker 0 2
var light_shade -1024 2
var light_newshade 0 2

eventloadactor A_LIGHT_FX
    geta[].lotag se_lotag
    seta[].lotag 0
    geta[].hitag se_hitag
    geta[].extra se_extra
    ifl se_extra 0
        set se_extra 0
    seta[].hitag 0
    ife se_hitag 0 ife se_extra 0
        set se_hitag 1
    seta[].cstat 32768
    geta[].xvel se_xvel
    seta[].xvel 0
    geta[].yvel se_yvel
    seta[].yvel 0
    geta[].zvel se_zvel
    ifl se_zvel 1
        set se_zvel 1
    seta[].zvel 0
enda
appendevent EVENT_SPAWN
 ifactor A_LIGHT_FX
 {
    ifn se_extra 0 changespritestat THISACTOR STAT_FLICKERFX
    else changespritestat THISACTOR STAT_LIGHTFX
 }
endevent
var ltdelay
var lt_do 0 2
var lt_flip 0 2

appendevent EVENT_WORLD
    for temp6 sprofstat STAT_FLICKERFX
    {
        ife sprite[temp6].picnum A_LIGHT_FX
        {
            setu[].vm_sprite temp6
            ifn se_extra 0
            {
                ife activateshit[se_lotag] 1
                        setvar lt_do 1
                ifand se_xvel 4
                {
                    setvar lt_do 1
                    xor se_xvel 4
                }
                ife se_hitag 0
                {
                    ife light_toggle 1
                        set light_toggle 0
                    else ifg light_toggle 1
                        sub light_toggle 1
                    add light_flicker 1
                    ife light_flicker se_extra
                    {
                        set light_flicker 0
                        ifand se_xvel 1
                        {
                            ifand se_xvel 2
                                set light_toggle se_zvel
                            for temp sprofstat STAT_LIGHTFX
                            {
                                ife sprite[temp].picnum A_LIGHT_FX
                                {
                                    getav[temp].se_lotag temp2
                                    getav[temp].se_extra temp4
                                    ife temp2 se_lotag ife temp4 0
                                    {
                                        getav[temp].light_toggle temp2
                                        ife temp2 0
                                            set temp2 1
                                        else
                                            set temp2 0
                                        setav[temp].light_toggle temp2
                                        setav[temp].light_overage 0
                                        setav[temp].light_wait 0
                                    }
                                }
                            }
                        }
                        else ifrnd 127
                        {
                            ifand se_xvel 2
                                set light_toggle se_zvel
                            for temp sprofstat STAT_LIGHTFX
                            {
                                ife sprite[temp].picnum A_LIGHT_FX
                                {
                                    getav[temp].se_lotag temp2
                                    getav[temp].se_extra temp4
                                    ife temp2 se_lotag ife temp4 0
                                    {
                                        getav[temp].light_toggle temp2
                                        ife temp2 0
                                            set temp2 1
                                        else
                                            set temp2 0
                                        setav[temp].light_toggle temp2
                                        setav[temp].light_overage 0
                                        setav[temp].light_wait 0
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    ife lt_do 1
                    {
                        set lt_do 0
                        ife light_wait 0
                        {
                            set light_wait 1
                            for temp sprofstat STAT_LIGHTFX
                            {
                                ife sprite[temp].picnum A_LIGHT_FX
                                {
                                    getav[temp].se_lotag temp2
                                    getav[temp].se_extra temp4
                                    ife temp2 se_hitag ife temp4 0
                                    {
                                        getav[temp].light_toggle temp2
                                        set temp2 1
                                        setav[temp].light_toggle temp2
                                        setav[temp].light_overage 0
                                        setav[temp].light_wait 0
                                    }
                                }
                            }
                            ifand se_xvel 2
                                set light_toggle se_zvel
                            set light_flicker 0
                        }
                        else
                        {
                            set light_wait 0
                            for temp sprofstat STAT_LIGHTFX
                            {
                                ife sprite[temp].picnum A_LIGHT_FX
                                {
                                    getav[temp].se_lotag temp2
                                    getav[temp].se_extra temp4
                                    ife temp2 se_hitag ife temp4 0
                                    {
                                        getav[temp].light_toggle temp2
                                        set temp2 0
                                        setav[temp].light_toggle temp2
                                        setav[temp].light_overage 0
                                        setav[temp].light_wait 0
                                    }
                                }
                            }
                            set light_toggle 0
                            set light_flicker 0
                        }
                        set ltdelay 1
                    }

                    ife light_wait 1
                    {
                        add light_flicker 1
                        set temp3 0
                        ife light_toggle 1
                        {
                            set temp3 1
                            set light_toggle 0
                        }
                        else ifg light_toggle 1
                            sub light_toggle 1
                        ife light_flicker se_extra
                        {
                            set light_flicker 0

                            ifand se_xvel 1
                                set temp3 1
                            else ifrnd 127
                                set temp3 1
                        }
                        ife temp3 1
                        {
                            set temp3 0
                            for temp sprofstat STAT_LIGHTFX
                            {
                                ife sprite[temp].picnum A_LIGHT_FX
                                {
                                    getav[temp].se_lotag temp2
                                    getav[temp].se_extra temp4
                                    ife temp2 se_hitag ife temp4 0
                                    {
                                        getav[temp].light_toggle temp2
                                        ife temp2 0
                                        {
                                            set temp2 1
                                            set temp3 1
                                        }
                                        else
                                            set temp2 0
                                        setav[temp].light_toggle temp2
                                        setav[temp].light_overage 0
                                        setav[temp].light_wait 0
                                    }
                                }
                            }
                            ife temp3 1
                                ifand se_xvel 2
                                    set light_toggle se_zvel
                        }
                    }
                }
            }
        }
    }

    for temp6 sprofstat STAT_LIGHTFX
    {
        setu[].vm_sprite temp6
        ife st_do_once 0
        {
            ife se_extra 0
            {
                for temp spritesofsector sprite[].sectnum
                {
                    geta[temp].picnum surface_type
                    state get_surface_type
                    ife surface_type SURFACE_LIGHT
                    {
                        ifn sprite[temp].picnum A_MONITOR_1
                        {
                            ifn sprite[temp].picnum A_MONITOR_2
                            {
                                ifn sprite[temp].picnum A_MONITOR_3
                                {
                                    set temp4 0
                                    ifand tiledata[sprite[temp].picnum].gameflags 4
                                        set temp4 1
                                    else ifand sprite[temp].cstat 2048
                                        set temp4 1
                                    ife temp4 1
                                    {
                                        setav[temp].light_shade sprite[temp].shade
                                        setav[temp].light_newshade sprite[temp].shade
                                    }
                                }
                            }
                        }
                    }
                }
            }
            set st_do_once 1
        }
        ife se_extra 0
        {
            ife activateshit[se_lotag] 1
            {
                ife light_toggle 0
                    set light_toggle 1
                else
                    set light_toggle 0
                set light_overage 0
                set light_wait 0
            }

            ife light_overage 0 ife light_wait 0
            {
                ife light_toggle 1
                {
                    set temp 0
                    ifl counter sprite[].shade
                    {
                        add counter se_hitag
                        ifg counter sprite[].shade
                        {
                            set temp2 counter
                            sub temp2 sprite[].shade
                            set temp temp2
                            set counter sprite[].shade
                            set light_overage 1
                        }
                        else
                            set temp se_hitag
                    }
                    else ifg counter sprite[].shade
                    {
                        sub counter se_hitag
                        ifl counter sprite[].shade
                        {
                            set temp2 counter
                            sub temp2 sprite[].shade
                            set temp temp2
                            set counter sprite[].shade
                            set light_overage 1
                        }
                        else
                            set temp -se_hitag
                    }

                    ifn temp 0
                    {
                        ifand se_yvel 4
                        {
                            ifand se_yvel 16
                            {
                                for temp2 spritesofsector sprite[].sectnum
                                {
                                    geta[temp2].picnum surface_type
                                    state get_surface_type
                                    ife surface_type SURFACE_LIGHT
                                    {
                                        ifn sprite[temp2].picnum A_MONITOR_1
                                        {
                                            ifn sprite[temp2].picnum A_MONITOR_2
                                            {
                                                ifn sprite[temp2].picnum A_MONITOR_3
                                                {
                                                    set temp4 0
                                                    ifand tiledata[sprite[temp2].picnum].gameflags 4
                                                        set temp4 1
                                                    else ifand sprite[temp2].cstat 2048
                                                        set temp4 1
                                                    ife temp4 1
                                                    {
                                                        geta[temp2].shade temp3
                                                        add temp3 temp
                                                        set temp4 temp
                                                        ifg temp3 12
                                                            shiftr temp4 1
                                                        add temp3 temp4
                                                        seta[temp2].shade temp3
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    ifand tiledata[sprite[temp2].picnum].gameflags 4
                                        nullop
                                    else ifand sprite[temp2].cstat 2048
                                        nullop
                                    else ifand sprite[temp2].cstat 16
                                    {
                                        set temp3 0
                                        ife sprite[temp2].statnum STAT_DEFAULT
                                            set temp3 1
                                        else
                                        {
                                            getav[temp2].actor_switch temp4
                                            ife temp4 1
                                                set temp3 1
                                            else
                                            {
                                                getav[temp2].actor_static temp4
                                                ife temp4 1
                                                    set temp3 1
                                            }
                                        }
                                        ife temp3 1
                                        {
                                            geta[temp2].shade temp3
                                            add temp3 temp
                                            seta[temp2].shade temp3
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            for temp2 wallsofsector sprite[].sectnum
                            {
                                ifn wall[temp2].hitag 1
                                {
                                    getw[temp2].shade temp3
                                    add temp3 temp
                                    setw[temp2].shade temp3
                                    ifn sprite[].pal 0
                                        setw[temp2].pal sprite[].pal
                                    else ifand se_yvel 8
                                        setw[temp2].pal sprite[].pal
                                }
                            }
                            for temp2 spritesofsector sprite[].sectnum
                            {
                                geta[temp2].picnum surface_type
                                state get_surface_type
                                ife surface_type SURFACE_LIGHT
                                {
                                    ifn sprite[temp2].picnum A_MONITOR_1
                                    {
                                        ifn sprite[temp2].picnum A_MONITOR_2
                                        {
                                            ifn sprite[temp2].picnum A_MONITOR_3
                                            {
                                                set temp4 0
                                                ifand tiledata[sprite[temp2].picnum].gameflags 4
                                                    set temp4 1
                                                else ifand sprite[temp2].cstat 2048
                                                    set temp4 1
                                                ife temp4 1
                                                {
                                                    geta[temp2].shade temp3
                                                    add temp3 temp
                                                    set temp4 temp
                                                    ifg temp3 12
                                                        shiftr temp4 1
                                                    add temp3 temp4
                                                    seta[temp2].shade temp3
                                                }
                                            }
                                        }
                                    }
                                }
                                ifand tiledata[sprite[temp2].picnum].gameflags 4
                                    nullop
                                else ifand sprite[temp2].cstat 2048
                                        nullop
                                else ifand sprite[temp2].cstat 16
                                {
                                    set temp3 0
                                    ife sprite[temp2].statnum STAT_DEFAULT
                                        set temp3 1
                                    else
                                    {
                                        getav[temp2].actor_switch temp4
                                        ife temp4 1
                                            set temp3 1
                                        else
                                        {
                                            getav[temp2].actor_static temp4
                                            ife temp4 1
                                                set temp3 1
                                        }
                                    }
                                    ife temp3 1
                                    {
                                        geta[temp2].shade temp3
                                        add temp3 temp
                                        seta[temp2].shade temp3
                                    }
                                }
                            }
                        }
                        ifand se_yvel 2
                            nullop
                        else
                        {
                            gets[].floorshade temp2
                            gets[].floorstat temp3
                            and temp3 1
                            ifn temp3 1
                                add temp2 temp
                            sets[].floorshade temp2
                            ifn sprite[].pal 0
                                sets[].floorpal sprite[].pal
                            else ifand se_yvel 8
                                sets[].floorpal sprite[].pal
                        }

                        ifand se_yvel 1
                            nullop
                        else
                        {
                            gets[].ceilingshade temp2
                            gets[].ceilingstat temp3
                            and temp3 1
                            ifand se_yvel 64
                                set temp3 0
                            ifn temp3 1
                                add temp2 temp
                            sets[].ceilingshade temp2
                            ifn sprite[].pal 0
                                sets[].ceilingpal sprite[].pal
                            else ifand se_yvel 8
                                sets[].ceilingpal sprite[].pal
                        }
                        set st_do_once 1
                    }
                    else ife st_do_once 1
                    {
                        for temp2 spritesofsector sprite[].sectnum
                        {
                            geta[temp2].picnum surface_type
                            state get_surface_type
                            ife surface_type SURFACE_LIGHT
                            {
                                ifn sprite[temp2].picnum A_MONITOR_1
                                {
                                    ifn sprite[temp2].picnum A_MONITOR_2
                                    {
                                        ifn sprite[temp2].picnum A_MONITOR_3
                                        {
                                            set temp4 0
                                            ifand tiledata[sprite[temp2].picnum].gameflags 4
                                                set temp4 1
                                            else ifand sprite[temp2].cstat 2048
                                                set temp4 1
                                            ife temp4 1
                                            {
                                                getav[temp2].light_newshade temp
                                                ifl sprite[temp2].shade temp
                                                {
                                                    seta[temp2].shade 0
                                                    setav[temp2].light_newshade 0
                                                }
                                                else ifg sprite[temp2].shade temp
                                                {
                                                    getav[temp2].light_shade temp
                                                    ifg sector[].floorshade temp
                                                            set temp sector[].floorshade
                                                    else ifg sector[].floorshade 15
                                                    {
                                                        ifl temp sector[].floorshade
                                                            set temp sector[].floorshade
                                                    }
                                                    else ifl temp 15
                                                        set temp 15
                                                    seta[temp2].shade temp
                                                    setav[temp2].light_newshade temp
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        set st_do_once 2
                    }
                }
                else ife light_toggle 0
                {
                    set temp 0
                    ifl counter 0
                    {
                        add counter se_hitag
                        ifg counter 0
                        {
                            set temp2 counter
                            set temp temp2
                            set light_overage 1
                            set counter 0
                        }
                        else
                            set temp se_hitag
                    }
                    else ifg counter 0
                    {
                        sub counter se_hitag
                        ifl counter 0
                        {
                            set temp2 counter
                            set temp temp2
                            set light_overage 1
                            set counter 0
                        }
                        else
                            set temp -se_hitag
                    }

                    ifn temp 0
                    {
                        ifand se_yvel 4
                        {
                            ifand se_yvel 16
                            {
                                for temp2 spritesofsector sprite[].sectnum
                                {
                                    geta[temp2].picnum surface_type
                                    state get_surface_type
                                    ife surface_type SURFACE_LIGHT
                                    {
                                        ifn sprite[temp2].picnum A_MONITOR_1
                                        {
                                            ifn sprite[temp2].picnum A_MONITOR_2
                                            {
                                                ifn sprite[temp2].picnum A_MONITOR_3
                                                {
                                                    set temp4 0
                                                    ifand tiledata[sprite[temp2].picnum].gameflags 4
                                                        set temp4 1
                                                    else ifand sprite[temp2].cstat 2048
                                                        set temp4 1
                                                    ife temp4 1
                                                    {
                                                        geta[temp2].shade temp3
                                                        add temp3 temp
                                                        set temp4 temp
                                                        ifg temp3 12
                                                            shiftr temp4 1
                                                        add temp3 temp4
                                                        seta[temp2].shade temp3
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    ifand tiledata[sprite[temp2].picnum].gameflags 4
                                        nullop
                                    else ifand sprite[temp2].cstat 2048
                                        nullop
                                    else ifand sprite[temp2].cstat 16
                                    {
                                        set temp3 0
                                        ife sprite[temp2].statnum STAT_DEFAULT
                                            set temp3 1
                                        else
                                        {
                                            getav[temp2].actor_switch temp4
                                            ife temp4 1
                                                set temp3 1
                                            else
                                            {
                                                getav[temp2].actor_static temp4
                                                ife temp4 1
                                                    set temp3 1
                                            }
                                        }
                                        ife temp3 1
                                        {
                                            geta[temp2].shade temp3
                                            add temp3 temp
                                            seta[temp2].shade temp3
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            for temp2 wallsofsector sprite[].sectnum
                            {
                                ifn wall[temp2].hitag 1
                                {
                                    getw[temp2].shade temp3
                                    add temp3 temp
                                    setw[temp2].shade temp3
                                    ifand se_yvel 32
                                    {
                                        ifl counter 0
                                        {
                                            set temp4 temp
                                            add temp4 counter
                                            ifge temp4 0
                                            {
                                                ifn sprite[].pal 0
                                                {
                                                    set temp3 wallpal[temp2]
                                                    setw[temp2].pal temp3
                                                }
                                                else ifand se_yvel 8
                                                {
                                                    set temp3 wallpal[temp2]
                                                    setw[temp2].pal temp3
                                                }
                                            }
                                        }
                                        else ifg counter 0
                                        {
                                            set temp4 temp
                                            add temp4 counter
                                            ifle temp4 0
                                            {
                                                ifn sprite[].pal 0
                                                {
                                                    set temp3 wallpal[temp2]
                                                    setw[temp2].pal temp3
                                                }
                                                else ifand se_yvel 8
                                                {
                                                    set temp3 wallpal[temp2]
                                                    setw[temp2].pal temp3
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        ifn sprite[].pal 0
                                        {
                                            set temp3 wallpal[temp2]
                                            setw[temp2].pal temp3
                                        }
                                        else ifand se_yvel 8
                                        {
                                            set temp3 wallpal[temp2]
                                            setw[temp2].pal temp3
                                        }
                                    }
                                }
                            }
                            for temp2 spritesofsector sprite[].sectnum
                            {
                                geta[temp2].picnum surface_type
                                state get_surface_type
                                ife surface_type SURFACE_LIGHT
                                {
                                    ifn sprite[temp2].picnum A_MONITOR_1
                                    {
                                        ifn sprite[temp2].picnum A_MONITOR_2
                                        {
                                            ifn sprite[temp2].picnum A_MONITOR_3
                                            {
                                                set temp4 0
                                                ifand tiledata[sprite[temp2].picnum].gameflags 4
                                                    set temp4 1
                                                else ifand sprite[temp2].cstat 2048
                                                    set temp4 1
                                                ife temp4 1
                                                {
                                                    geta[temp2].shade temp3
                                                    add temp3 temp
                                                    set temp4 temp
                                                    ifg temp3 12
                                                        shiftr temp4 1
                                                    add temp3 temp4
                                                    seta[temp2].shade temp3
                                                }
                                            }
                                        }
                                    }
                                }
                                ifand tiledata[sprite[temp2].picnum].gameflags 4
                                    nullop
                                else ifand sprite[temp2].cstat 2048
                                        nullop
                                else ifand sprite[temp2].cstat 16
                                {
                                    set temp3 0
                                    ife sprite[temp2].statnum STAT_DEFAULT
                                        set temp3 1
                                    else
                                    {
                                        getav[temp2].actor_switch temp4
                                        ife temp4 1
                                            set temp3 1
                                        else
                                        {
                                            getav[temp2].actor_static temp4
                                            ife temp4 1
                                                set temp3 1
                                        }
                                    }
                                    ife temp3 1
                                    {
                                        geta[temp2].shade temp3
                                        add temp3 temp
                                        seta[temp2].shade temp3
                                    }
                                }
                            }
                        }
                        ifand se_yvel 2
                            nullop
                        else
                        {
                            gets[].floorshade temp2
                            gets[].floorstat temp3
                            and temp3 1
                            ifn temp3 1
                                add temp2 temp
                            sets[].floorshade temp2
                            ifand se_yvel 32
                            {
                                ifl counter 0
                                {
                                    set temp4 temp
                                    add temp4 counter
                                    ifge temp4 0
                                    {
                                        ifn sprite[].pal 0
                                        {
                                            set temp4 sprite[].sectnum
                                            set temp3 sectpal[temp4]
                                            sets[].floorpal temp3
                                        }
                                        else ifand se_yvel 8
                                        {
                                            set temp4 sprite[].sectnum
                                            set temp3 sectpal[temp4]
                                            sets[].floorpal temp3
                                        }
                                    }
                                }
                                else ifg counter 0
                                {
                                    set temp4 temp
                                    add temp4 counter
                                    ifle temp4 0
                                    {
                                        ifn sprite[].pal 0
                                        {
                                            set temp4 sprite[].sectnum
                                            set temp3 sectpal[temp4]
                                            sets[].floorpal temp3
                                        }
                                        else ifand se_yvel 8
                                        {
                                            set temp4 sprite[].sectnum
                                            set temp3 sectpal[temp4]
                                            sets[].floorpal temp3
                                        }
                                    }
                                }
                            }
                            else
                            {
                                ifn sprite[].pal 0
                                {
                                    set temp4 sprite[].sectnum
                                    set temp3 sectpal[temp4]
                                    sets[].floorpal temp3
                                }
                                else ifand se_yvel 8
                                {
                                    set temp4 sprite[].sectnum
                                    set temp3 sectpal[temp4]
                                    sets[].floorpal temp3
                                }
                            }
                            
                        }

                        ifand se_yvel 1
                            nullop
                        else
                        {
                            gets[].ceilingshade temp2
                            gets[].ceilingstat temp3
                            and temp3 1
                            ifand se_yvel 64
                                set temp3 0
                            ifn temp3 1
                                add temp2 temp
                            sets[].ceilingshade temp2
                            ifand se_yvel 32
                            {
                                ifl counter 0
                                {
                                    set temp4 temp
                                    add temp4 counter
                                    ifge temp4 0
                                    {
                                        ifn sprite[].pal 0
                                        {
                                            set temp4 sprite[].sectnum
                                            add temp4 NUMSECTORS
                                            set temp3 sectpal[temp4]
                                            sets[].ceilingpal temp3
                                        }
                                        else ifand se_yvel 8
                                        {
                                            set temp4 sprite[].sectnum
                                            add temp4 NUMSECTORS
                                            set temp3 sectpal[temp4]
                                            sets[].ceilingpal temp3
                                        }
                                    }
                                }
                                else ifg counter 0
                                {
                                    set temp4 temp
                                    add temp4 counter
                                    ifle temp4 0
                                    {
                                        ifn sprite[].pal 0
                                        {
                                            set temp4 sprite[].sectnum
                                            add temp4 NUMSECTORS
                                            set temp3 sectpal[temp4]
                                            sets[].ceilingpal temp3
                                        }
                                        else ifand se_yvel 8
                                        {
                                            set temp4 sprite[].sectnum
                                            add temp4 NUMSECTORS
                                            set temp3 sectpal[temp4]
                                            sets[].ceilingpal temp3
                                        }
                                    }
                                }
                            }
                            else
                            {
                                ifn sprite[].pal 0
                                {
                                    set temp4 sprite[].sectnum
                                    add temp4 NUMSECTORS
                                    set temp3 sectpal[temp4]
                                    sets[].ceilingpal temp3
                                }
                                else ifand se_yvel 8
                                {
                                    set temp4 sprite[].sectnum
                                    add temp4 NUMSECTORS
                                    set temp3 sectpal[temp4]
                                    sets[].ceilingpal temp3
                                }
                            }
                        }
                        set st_do_once 1
                    }
                    else ife st_do_once 1
                    {
                        for temp2 spritesofsector sprite[].sectnum
                        {
                            geta[temp2].picnum surface_type
                            state get_surface_type
                            ife surface_type SURFACE_LIGHT
                            {
                                ifn sprite[temp2].picnum A_MONITOR_1
                                {
                                    ifn sprite[temp2].picnum A_MONITOR_2
                                    {
                                        ifn sprite[temp2].picnum A_MONITOR_3
                                        {
                                            set temp4 0
                                            ifand tiledata[sprite[temp2].picnum].gameflags 4
                                                set temp4 1
                                            else ifand sprite[temp2].cstat 2048
                                                set temp4 1
                                            ife temp4 1
                                            {
                                                getav[temp2].light_newshade temp
                                                ifl sprite[temp2].shade temp
                                                {
                                                    seta[temp2].shade 0
                                                    setav[temp2].light_newshade 0
                                                }
                                                else ifg sprite[temp2].shade temp
                                                {
                                                    getav[temp2].light_shade temp
                                                    ifg sector[].floorshade temp
                                                            set temp sector[].floorshade
                                                    else ifg sector[].floorshade 15
                                                    {
                                                        ifl temp sector[].floorshade
                                                            set temp sector[].floorshade
                                                    }
                                                    else ifl temp 15
                                                        set temp 15
                                                    seta[temp2].shade temp
                                                    setav[temp2].light_newshade temp
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        set st_do_once 2
                    }
                }
            }
            ifg se_xvel 0
            {
                add light_wait 1
                ife light_wait se_xvel
                    set light_wait 0
            }
        }
    }
endevent
useractor notenemy A_LIGHT_FX
    sleeptime 300
enda


eventloadactor A_PROXIMITY_SENSOR
    geta[].lotag se_lotag
    seta[].lotag 0
    geta[].hitag se_hitag
    shiftr se_hitag 1
    set temp se_hitag
    shiftr temp 1
    add se_hitag temp
    seta[].hitag 0
    ife se_hitag 0
        set se_hitag 1024
    geta[].extra se_extra
    ifl se_extra 0
        set se_extra 0
    geta[].xvel se_xvel
    seta[].xvel 0
    seta[].cstat 32768
    geta[].owner tp_owner
    clamp tp_owner 0 65536
enda
var prox_toggle 0 2
var prox_trigger -1 0
var prox_target -1 0
appendevent EVENT_SPAWN
    ifactor A_PROXIMITY_SENSOR
        changespritestat THISACTOR STAT_PROXIMITY
endevent

useractor notenemy A_PROXIMITY_SENSOR
    changespritestat THISACTOR STAT_PROXIMITY
enda

appendevent EVENT_WORLD
    for temp7 sprofstat STAT_PROXIMITY
    {
        setu[].vm_sprite temp7
        setu[].vm_player myconnectindex
        ife sprite[].xrepeat 0
            changespritestat THISACTOR STAT_ACTOR
        else // ifn sprite[].xrepeat 0
        {
            ifg tp_owner 0
            {
                ife activateshit[tp_owner] 1
                    inv se_hitag
            }
            ifand se_xvel 64
            {
                ife st_do_once 0
                {
                    geta .z se_above
                    set st_do_once 1
                }
                else
                    seta .z se_above
            }
            dist temp THISACTOR player[].i
            setu[].vm_distance temp
            getu[].vm_distance temp
            set temp6 temp
            ifand se_xvel 128
                set temp6 -67108864

            ifand se_xvel 4
                nullop
            else
            {
                set temp5 0
                ifn num_flag32 0
                {
                    for temp5 range num_flag32
                    {
                        set temp2 gameflag32[temp5]
                        ifg sprite[temp2].extra 0
                        {
                            switch sprite[temp2].picnum
                                case A_CULTIST
                                case A_SHOTGUNNER
                                case A_GREATER
                                case A_PSEUDO_ENEMY
                                    getav[temp2].enemy_init temp4
                                    ifand se_xvel 256
                                        ifn sprite[temp2].picnum A_PSEUDO_ENEMY
                                            set temp4 0
                                    ife temp4 1
                                    {
                                        dist temp3 temp2 THISACTOR
                                        ifl temp3 temp6
                                        {
                                            set temp6 temp3
                                            set prox_target temp2
                                        }
                                        else ife temp6 -67108864
                                        {
                                            set temp6 temp3
                                            set prox_target temp2
                                        }
                                    }
                                    break
                            endswitch
                        }
                        // add temp5 1
                    }
                }
            }
            ifand se_xvel 128
            {
                abs temp6
                set temp temp6
            }
            else ifl temp6 temp
                set temp temp6
            else
                set prox_target player[].i
            ifspritepal 9
            {
                geta[].z temp2
                sub temp2 2048
                seta[].z temp2
                getp[].posz temp2
                sub temp2 8196
                setp[].posz temp2

                canseespr THISACTOR prox_target temp2
                ife temp2 1
                    nullop
                else
                    set temp 262144
                geta[].z temp2
                add temp2 2048
                seta[].z temp2
                getp[].posz temp2
                add temp2 8196
                setp[].posz temp2
            }
            ife counter 0
            {
                ifl temp se_hitag
                {
                    ife prox_toggle 0
                    {
                        state switch_activate
                        set counter se_extra
                        for temp4 sprofstat STAT_PROXIMITY
                        {
                            ife sprite[temp4].picnum A_PROXIMITY_SENSOR
                            {
                                ifn sprite[temp4].xrepeat 0
                                {
                                    getav[temp4].se_lotag temp3
                                    ife temp3 se_lotag
                                    {
                                        ife sprite[temp4].pal 9
                                        {
                                            getav[temp4].prox_toggle temp3
                                            ife temp3 0
                                                set temp3 2
                                            else ife temp3 2
                                                set temp3 0
                                            setav[temp4].prox_toggle temp3
                                        }
                                        ifn temp4 THISACTOR 
                                        {
                                            ifand se_xvel 8
                                            {
                                                ifand se_xvel 16
                                                {
                                                    ifand se_xvel 32
                                                        seta[temp4].xrepeat 0
                                                    else
                                                    {
                                                        getav[temp4].se_xvel temp3
                                                        ifand temp3 8
                                                            seta[temp4].xrepeat 0
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        set prox_toggle 1
                        ifand se_xvel 8
                            seta[].xrepeat 0
                    }
                }
                else
                {
                    ife prox_toggle 1
                    {
                        ifand se_xvel 1
                            add se_lotag 1

                        state switch_activate
                        set counter se_extra
                        for temp4 sprofstat STAT_PROXIMITY
                        {
                            ife sprite[temp4].picnum A_PROXIMITY_SENSOR
                            {
                                ife sprite[temp4].pal 9 ifn sprite[temp4].xrepeat 0
                                {
                                    getav[temp4].se_lotag temp3
                                    ife temp3 se_lotag
                                    {
                                        getav[temp4].prox_toggle temp3
                                        ife temp3 0
                                            set temp3 2
                                        else ife temp3 2
                                            set temp3 0
                                        setav[temp4].prox_toggle temp3
                                    }
                                }
                            }
                        }
                        set prox_toggle 0
                        ifand se_xvel 1
                            sub se_lotag 1
                    }
                }
            }
            else
            {
                ifand se_xvel 2
                {
                    ifn prox_toggle 0
                    {
                        ife prox_target player[].i
                            getu[].vm_distance temp
                        else
                            set temp temp6
                    }
                    ifg temp se_hitag
                        sub counter 1
                    else
                        set counter se_extra
                }
                else
                    sub counter 1
            }
        }
    }
endevent
// gradients!
appendevent EVENT_LOADACTOR
    switch sprite[].picnum
        case 6720
        case 6721
        case 7070
        case 7071
        case 7072
        case 7660
        case 7661
        case 7662
        case 7663
        case 7664
        case 7665
        case 7666
        case 7669
        case 7670
        case 8001
        case 8002
        case 8003
        case 8004
        case 8005
        case 8006
        case 8007
        case 8008
        case 8009
        case 8010
        case 8011
        case 8012
        case 8013
        case 8014
        case 8015
        case 8016
		case 8018
        case 8609
        case 8612
        case 8613
        case 9133 // skybox gradient 1
        case 9134 // skybox gradient 2
        case 9135 // skybox gradient 3
        case 9136 // skybox spotlight
        case 9139
        case 9140
        case 9141
        case 9144
        case 9145
        case 9146
        case 9147
        case 9148
        case 9149
        case 9150
        case 9151
        case 9418
        case 9419
            ifn sprite[].lotag 0
            {
                geta[].lotag se_lotag
                geta[].hitag se_hitag
                ife se_hitag 0
                    set se_hitag 1
                geta[].xvel se_xvel
                geta[].yvel se_yvel
                geta[].zvel se_zvel
                geta[].extra se_extra
                ifl se_extra 0
                    inv se_hitag

                geta[].shade se_shade

                seta[].lotag 0
                seta[].hitag 0
                seta[].xvel 0
                seta[].yvel 0
                seta[].zvel 0
                seta[].extra 0
                geta .owner tp_owner
                changespritestat THISACTOR STAT_GRADIENT
            }
            else ifand sprite[].xvel 1
            {
                geta[].lotag se_lotag
                geta[].hitag se_hitag
                ife se_hitag 0
                    set se_hitag 1
                geta[].xvel se_xvel
                geta[].yvel se_yvel
                geta[].zvel se_zvel
                geta[].extra se_extra
                ifl se_extra 0
                    inv se_hitag

                geta[].shade se_shade

                seta[].lotag 0
                seta[].hitag 0
                seta[].xvel 0
                seta[].yvel 0
                seta[].zvel 0
                seta[].extra 0
                geta .owner tp_owner
                changespritestat THISACTOR STAT_GRADIENT
            }
            break
    endswitch
endevent

gamevar grad_ocstat 0 2

appendevent EVENT_WORLD
    for temp sprofstat STAT_GRADIENT
    {
        setu[].vm_sprite temp
        ife st_do_once 0
        {
            set st_do_once 1
            geta[].htflags temp2
            or temp2 68
            seta[].htflags temp2
            ifand se_xvel 1
                ifand se_xvel 2
                    set light_toggle 1
            ifand se_xvel 4
            {
                geta[].cstat grad_ocstat
                ifand se_xvel 8
                    seta[].cstat 32768
            }
            set counter2 se_zvel
            ifg tp_owner 0
            {
                set temp 0
                for itervar sprofstat STAT_MASTER_MOVER
                {
                    ife actorvar[itervar].pivot_hitag tp_owner
                    {
                        set tp_owner itervar
                        set temp 1
                    }
                }
                ife temp 0
                    set tp_owner -1
            }
            else
                set tp_owner -1
            ifn tp_owner -1
            {
                geta[tp_owner].x temp3
                sub temp3 sprite.x
                setav .pivot_xoff temp3

                geta[tp_owner].y temp3
                sub temp3 sprite.y
                setav .pivot_yoff temp3
                setav .pivot_ang sprite.ang
                
                geta[tp_owner].z temp3
                sub temp3 sprite.z
                setav .pivot_zoff temp3
            }
        }
        
        ifn tp_owner -1
        {
            geta[tp_owner].x temp3
            getav .pivot_xoff temp4
            sub temp3 temp4
            seta .x temp3

            geta[tp_owner].y temp3
            getav .pivot_yoff temp4
            sub temp3 temp4
            seta .y temp3
            
            geta[tp_owner].z temp3
            getav .pivot_zoff temp4
            sub temp3 temp4
            seta .z temp3

            // using the previously saved difference rotatepoint and set a new location
            // doing this prevents error accumulation
            getav[tp_owner].pivot_angdiff temp3
            rotatepoint sprite[tp_owner].x sprite[tp_owner].y sprite .x sprite .y temp3 temp4 temp5

            seta .x temp4
            seta .y temp5

            // use the same diff to match the new angle
            getav .pivot_ang temp4
            add temp4 temp3
            and temp4 2047
            seta .ang temp4

            seta .sectnum sprite[tp_owner].sectnum
        }
        
        ife activateshit[se_lotag] 1
        {
            ifn se_lotag 0
            {
                ifand se_xvel 1 // constant cycle flag
                {
                    ife light_toggle 0
                        set light_toggle 1
                    else
                    {
                        set light_toggle 0
                        set counter 0
                    }
                    ifand se_xvel 4
                    {
                        ife sprite[].cstat grad_ocstat
                            seta[].cstat 32768
                        else
                            seta[].cstat grad_ocstat
                    }
                }
                else
                {
                    ife counter 0
                        set counter 1
                    else
                        set counter 0

                    ifand se_xvel 4
                    {
                        ife sprite[].cstat grad_ocstat
                            seta[].cstat 32768
                        else
                            seta[].cstat grad_ocstat
                    }
                }
            }
        }
        ifn counter2 0
        {
            abs counter2
            ife light_toggle 1
                sub counter2 1
            else ife se_lotag 0
                sub counter2 1
        }
            
        ife light_wait se_yvel
        {
            ifn counter2 0
                nullop
            else ife counter 0
            {
                ifn sprite[].shade se_shade
                {
                    geta[].shade temp2
                    sub temp2 se_hitag
                    ifl se_hitag 0
                    {
                        ifg temp2 se_shade
                            set temp2 se_shade
                    }
                    else
                    {
                        ifl temp2 se_shade
                            set temp2 se_shade
                    }
                    seta[].shade temp2
                }
                else
                {
                    ifand se_xvel 1
                    {
                        ifn se_lotag 0
                        {
                            ife light_toggle 1
                                set counter 1
                            else
                                set counter2 se_zvel
                        }
                        else
                            set counter 1
                    }
                }
            }
            else
            {
                set temp3 se_shade
                add temp3 se_extra
                ifn sprite[].shade temp3
                {
                    geta[].shade temp2
                    add temp2 se_hitag
                    ifl se_hitag 0
                    {
                        ifl temp2 temp3
                            set temp2 temp3
                    }
                    else
                    {
                        ifg temp2 temp3
                            set temp2 temp3
                    }
                    seta[].shade temp2
                }
                else
                {
                    ifand se_xvel 1
                    {
                        ifn se_lotag 0
                        {
                            ife light_toggle 1
                                set counter 0
                        }
                        else
                            set counter 0
                    }
                }
            }
            set light_wait 0
        }
        else
            add light_wait 1
    }
   // set gradient_trigger -1
endevent

var start_color 0 2
var dull_color 0 2
spritenoshade 10061
state neon_flicker
    geta[].htflags temp2
    or temp2 68
    seta[].htflags temp2
    ifg se_yvel 0
    {
        ife activateshit[se_yvel] 1
            xor counter2 1
    }
    else ifl se_yvel 0
    {
        inv se_yvel
        xor counter2 1
    }
    ife counter2 1
    {
        ifn counter 0
        {
            ifg se_extra 1
            {
                operateactivators se_extra THISACTOR
                operatemasterswitches se_extra
                operaterespawns se_extra
                setarray preloadactivations[se_extra] 1
            }
            set counter 0
        }
        set se_above se_zvel
        seta .pal dull_color
        seta .shade 23
        set counter3 1
        ifand se_xvel 1
            nullop
        else
            break
    }
    ife counter3 1
    {
        seta[].pal start_color
        seta[].shade se_shade
        set counter3 0
    }
    ifand se_xvel 1
        ife counter2 1
            break
    ifg se_zvel 0
    {
        ifg se_above 0
        {
            sub se_above 1
            ifand se_xvel 1
                nullop
            else
            {
                seta .pal dull_color
                seta .shade 23
            }
            break
        }
    }
    ife se_lotag 0
        break
    ife counter 0
    {
        rand temp 255
        ifl temp se_lotag
        {
            set counter se_hitag
            clamp counter 4 65536
            set light_wait counter
            set htzvel light_wait
            ifg se_extra 1
            {
                operateactivators se_extra THISACTOR
                operatemasterswitches se_extra
                operaterespawns se_extra
                setarray preloadactivations[se_extra] 1
            }
        }
    }
    ifg counter 0
    {
        set temp light_wait
        sub temp counter
        abs temp
        ifand se_xvel 2
        {
            ifand se_xvel 1
            {
                ife temp 1
                    ifg htzvel 0
                    {
                        sub htzvel 1
                        break
                    } 
            }
            else
            {
                ife counter 1
                    ifg htzvel 0
                    {
                        sub htzvel 1
                        seta[].pal start_color
                        seta[].shade se_shade
                        break
                    } 
            }
        }
        ifl temp 3
        {
            ifand se_xvel 1
            {
                switch temp
                    case 1
                        seta .pal dull_color
                        seta[].shade 24
                        break
                    case 0
                        seta .pal dull_color
                        seta[].shade 25
                        break
                    case 2
                        seta[].pal start_color
                        seta[].shade se_shade
                        break
                endswitch
            }
            else
            {
                switch temp
                    case 0
                        seta .pal dull_color
                        seta .shade 23
                        break
                    case 1
                        seta[].shade 24
                        break
                    case 2
                        seta[].shade 25
                        break
                endswitch
            }
        }
        else
        {
            ifand se_xvel 1
            {
                switch counter
                    case 3
                    case 2
                    case 1
                        seta[].pal start_color
                        seta[].shade se_shade
                        break
                endswitch
            }
            else
            {
                switch counter
                    case 2
                        seta[].shade 24
                        break
                    case 3
                        seta[].shade 25
                        break
                    case 1
                        seta[].pal start_color
                        seta[].shade se_shade
                        break
                endswitch
            }
        }
        sub counter 1
        ife counter 0
        {
            ifg se_extra 1
            {
                operateactivators se_extra THISACTOR
                operatemasterswitches se_extra
                operaterespawns se_extra
                setarray preloadactivations[se_extra] 1
            }
        }
    }
ends
appendevent EVENT_LOADACTOR
    switch sprite[].picnum
        case 10007
        case 10008
        case 10009
        case 10010
        case 10011
        case 10020
        case 10021
        case 10022
        case 10023
        case 10024
        case 10025
        case 10026
        case 10027
        case 10028
        case 10029
        case 10030
        case 10031
        case 10032
        case 10033
        case 10034
        case 10035
        case 10036
        case 10037
        case 10038
        case 10039
        case 10040
        case 10041
        case 10042
        case 10043
        case 10044
        case 10045
        case 10046
        case 10047
        case 10048
        case 10049
        case 10050
        case 10051
        case 10052
        case 10053
        case 10054
        case 10055
        case 10056
        case 10057
        case 10058
        case 10059
        case 10060
        case 10061
        case 10062
        case 10063
        case 10064
        case 10065
        case 10066
        case 10067
        case 10068
        case 10069
        case 10070
        case 10071
        case 10072
        case 10073
        case 10074
        case 10075
        case 10076
        case 10077
        case 10078
        case 10079
        case 10080
        case 10081
        case 10082
        case 10083
        case 10084
        case 10085
        case 10086
        case 10087
        case 10088
        case 10089
        case 10090
        case 10091
        case 10092
        case 10093
        case 10094
        case 10095
        case 10096
        case 10097
        case 10098
        case 10099
        case 10100
        case 10101
        case 10102
        case 10103
        case 10104
        case 10105
        case 10106
        case 10107
        case 10450
        case 10451
        case 10452
        case 10453
        case 10454
        case 10455
        case 10456
        case 10457
        case 10458
        case 10459
        case 10460
        case 10461
        case 10462
        case 10463
        case 10464
        case 10465
        case 10466
        case 10467
        case 10468
        case 10469
        case 10470
        case 10471
        case 10472
        case 10473
        case 10474
        case 10475
        case 10476
        case 10477
        case 10478
        case 10479
        case 10480
        case 10481
        case 10482
        case 10483
        case 10484
        case 10485
        case 10486
            ifn sprite[].lotag 0
            {
                geta[].pal start_color
                set dull_color 56
                geta[].shade se_shade
                geta[].lotag se_lotag
                geta[].hitag se_hitag
                geta[].extra se_extra
                geta[].yvel se_yvel
                geta[].xvel se_xvel
                geta[].zvel se_zvel
                ifg se_zvel 0
                    set se_above se_zvel
                seta[].lotag 0
                seta[].hitag 0
                seta[].xvel 0
                seta[].zvel 0
            }
            cstator 256
            ife sprite.statnum 0
                changespritestat THISACTOR STAT_NEONSIGN
            break
    endswitch
endevent
appendevent EVENT_WORLD
    for temp7 sprofstat STAT_NEONSIGN
    {
        setu[].vm_sprite temp7
        state neon_flicker
    }
endevent


useractor notenemy T_DARTBOARD_SWITCH 0 AC_SWITCH
    sleeptime 300
    strength 1
    cstator 256
    ife st_do_once 0
    {
        set st_do_once 1
        ifawayfromwall
            nullop
        else ifand sprite.cstat 16
        {
            geta .clipdist temp
            seta .clipdist 0
            seta .xvel 16
            ssp THISACTOR 0
            seta .clipdist temp
        }
        set pivot_xoff tilesizx[sprite.picnum]
        mul pivot_xoff sprite.xrepeat
        shiftr pivot_xoff 2
        
        shiftr pivot_xoff 6
        clamp pivot_xoff 16 65536
        set pivot_yoff tilesizx[sprite.picnum]
        shiftl pivot_yoff 2
        mul pivot_yoff sprite.xrepeat
        set pivot_zoff pivot_yoff
        shiftr pivot_zoff 5
        clamp pivot_zoff 32 65536
        ifand sprite.cstat 128
        {
            shiftr pivot_yoff 1
            geta .z temp
            add temp pivot_yoff
            seta .z temp
            geta .cstat temp
            xor temp 128
            seta .cstat temp
        }
        else
            shiftr pivot_yoff 1

    }
    ifand sprite.cstat 32
        nullop
    else
        cstator 16
    ifg counter 0
    {
        seta .htextra -1
        sub counter 1
        set counter3 -1
        break
    }
    geta .htowner temp
    ifhitweapon
    {
        set counter se_xvel
        ifwasweapon P_DART
        {
            ifn counter3 -1
            {
                set att_target counter3
                state angle_to_target
                ifle att_return 512
                {
                    ldist temp THISACTOR counter3
                    
                    geta .z temp3
                    geta[counter3].z temp2
                    sub temp3 pivot_yoff
                    
                    sub temp3 sprite[counter3].z
                    abs temp3
                    set temp6 0
                    ifl temp pivot_xoff
                    {
                        ifl temp3 pivot_zoff
                            set temp6 1
                    }
                    
                    ife temp6 1 ifg se_lotag 0
                    {
                        ife VOLUME EP_MAIN
                            ife LEVEL 16
                                or cheevo_tracker 262144
                        state switch_activate
                        ifg se_hitag 0
                            soundvar se_hitag
                        else
                        {
                            getp .sound_pitch temp
                            setp .sound_pitch 480
                            sound S_SWITCH_SNAPPY
                            setp .sound_pitch temp
                        }
                    }
                }
            }
        }
    }
    set counter3 -1
enda

